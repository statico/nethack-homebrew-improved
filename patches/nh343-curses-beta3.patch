diff -burN '--exclude=.svn' nethack-orig/doc/window.doc nethack-3.4.3/doc/window.doc
--- nethack-orig/doc/window.doc	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/doc/window.doc	2010-12-17 14:00:58.888525001 -0500
@@ -518,6 +518,9 @@
   |  fullscreen        | WC2_FULLSCREEN     | wc2_fullscreen     |boolean |
   |  softkeyboard      | WC2_SOFTKEYBOARD   | wc2_softkeyboard   |boolean |
   |  wraptext          | WC2_WRAPTEXT       | wc2_wraptext       |boolean |
+  |  term_cols         | WC2_TERM_COLS      | wc2_term_cols      |int     |
+  |  term_rows         | WC2_TERM_ROWS      | wc2_term_rows      |int     |
+  |  windowborders     | WC2_WINDOWBORDERS  | wc2_windowborders  |int     |
   +--------------------+--------------------+--------------------+--------+
 
 align_message	-- where to place message window (top, bottom, left, right)
@@ -548,6 +551,8 @@
 		   is this number of cells away from the edge of the window.
 softkeyboard    -- handhelds should display an on-screen keyboard if possible.
 splash_screen   -- port should/should not display an opening splashscreen.
+term_cols       -- Terminal should size itself to specified width, if possible.
+term_rows       -- Terminal should size itself to specified height, if possible.
 tiled_map	-- port should display a tiled map if it can.
 tile_width	-- port should display tiles with this width or round to closest
 		   if it can.
@@ -558,6 +563,8 @@
 use_inverse	-- port should display inverse when NetHack asks for it.
 vary_msgcount	-- port should display this number of messages at a time in
 		   the message window.
+windowborders   -- port should display borders around main NetHack windows.
+                Can be set to (1) on, (2) off, or (3) auto.
 windowcolors
 		-- port should use these colors for window foreground/background
 		   colors.  Syntax:
diff -burN '--exclude=.svn' nethack-orig/include/config.h nethack-3.4.3/include/config.h
--- nethack-orig/include/config.h	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/include/config.h	2010-12-17 14:00:58.478525002 -0500
@@ -42,7 +42,8 @@
  * Define all of those you want supported in your binary.
  * Some combinations make no sense.  See the installation document.
  */
-#define TTY_GRAPHICS	/* good old tty based graphics */
+/* #define TTY_GRAPHICS */	/* good old tty based graphics */
+#define CURSES_GRAPHICS     /* Proper curses interface */
 /* #define X11_GRAPHICS */	/* X11 interface */
 /* #define QT_GRAPHICS */	/* Qt interface */
 /* #define GNOME_GRAPHICS */	/* Gnome interface */
@@ -113,6 +114,12 @@
 # define HACKDIR "\\nethack"
 #endif
 
+#ifdef CURSES_GRAPHICS
+# ifndef DEFAULT_WINDOW_SYS
+#  define DEFAULT_WINDOW_SYS "curses"
+# endif
+#endif
+
 #ifndef DEFAULT_WINDOW_SYS
 # define DEFAULT_WINDOW_SYS "tty"
 #endif
@@ -169,11 +176,11 @@
 
 #ifdef UNIX
 /* path and file name extension for compression program */
-#define COMPRESS "/usr/bin/compress"	/* Lempel-Ziv compression */
-#define COMPRESS_EXTENSION ".Z"		/* compress's extension */
+/* #define COMPRESS "/usr/bin/compress" */	/* Lempel-Ziv compression */
+/* #define COMPRESS_EXTENSION ".Z"	*/	/* compress's extension */
 /* An example of one alternative you might want to use: */
-/* #define COMPRESS "/usr/local/bin/gzip" */	/* FSF gzip compression */
-/* #define COMPRESS_EXTENSION ".gz" */		/* normal gzip extension */
+#define COMPRESS "/bin/gzip"	/* FSF gzip compression */
+#define COMPRESS_EXTENSION ".gz"		/* normal gzip extension */
 #endif
 
 #ifndef COMPRESS
@@ -185,7 +192,7 @@
  *	a tar-like file, thus making a neater installation.  See *conf.h
  *	for detailed configuration.
  */
-/* #define DLB */	/* not supported on all platforms */
+#define DLB	/* not supported on all platforms */
 
 /*
  *	Defining INSURANCE slows down level changes, but allows games that
@@ -204,7 +211,7 @@
  * otherwise it will be the current directory.
  */
 # ifndef HACKDIR
-#  define HACKDIR "/usr/games/lib/nethackdir"
+/* #  define HACKDIR "/usr/games/lib/nethackdir" */
 # endif
 
 /*
diff -burN '--exclude=.svn' nethack-orig/include/flag.h nethack-3.4.3/include/flag.h
--- nethack-orig/include/flag.h	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/include/flag.h	2010-12-17 14:00:58.498525002 -0500
@@ -156,6 +156,9 @@
 
 struct instance_flags {
 	boolean  cbreak;	/* in cbreak mode, rogue format */
+#ifdef CURSES_GRAPHICS
+    boolean  cursesgraphics;    /* Use portable curses extended characters */
+#endif
 	boolean  DECgraphics;	/* use DEC VT-xxx extended character set */
 	boolean  echo;		/* 1 to echo characters */
 	boolean  IBMgraphics;	/* use IBM extended character set */
@@ -181,6 +184,8 @@
 #endif
 #ifdef TTY_GRAPHICS
 	char prevmsg_window;	/* type of old message window to use */
+#endif
+#if defined(TTY_GRAPHICS) || defined(CURSES_GRAPHICS)
 	boolean  extmenu;	/* extended commands use menu interface */
 #endif
 #ifdef MFLOPPY
@@ -263,6 +268,11 @@
 	boolean wc2_fullscreen;		/* run fullscreen */
 	boolean wc2_softkeyboard;	/* use software keyboard */
 	boolean wc2_wraptext;		/* wrap text */
+    int     wc2_term_cols;      /* terminal width, in characters */
+    int     wc2_term_rows;      /* terminal height, in characters */
+    int     wc2_windowborders;  /* display borders on NetHack windows */
+    int     wc2_petattr;        /* points to text attributes for pet */
+    boolean wc2_guicolor;       /* allow colors in GUI (outside map) */
 
 	boolean  cmdassist;	/* provide detailed assistance for some commands */
 	boolean	 obsolete;	/* obsolete options can point at this, it isn't used */
diff -burN '--exclude=.svn' nethack-orig/include/ntconf.h nethack-3.4.3/include/ntconf.h
--- nethack-orig/include/ntconf.h	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/include/ntconf.h	2010-12-17 14:00:58.498525002 -0500
@@ -159,7 +159,9 @@
 long _RTLENTRY _EXPFUNC lseek  (int __handle, long __offset, int __fromwhere);
 int  _RTLENTRY _EXPFUNC read  (int __handle, void _FAR *__buf, unsigned __len);
 #endif
-#include <conio.h>
+#ifndef CURSES_GRAPHICS
+# include <conio.h>
+#endif
 #undef kbhit		/* Use our special NT kbhit */
 #define kbhit (*nt_kbhit)
 
diff -burN '--exclude=.svn' nethack-orig/include/rm.h nethack-3.4.3/include/rm.h
--- nethack-orig/include/rm.h	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/include/rm.h	2010-12-17 14:00:58.488525002 -0500
@@ -234,6 +234,7 @@
 #define IBM_GRAPHICS	1	/* PC graphic characters */
 #define DEC_GRAPHICS	2	/* VT100 line drawing characters */
 #define MAC_GRAPHICS	3	/* Macintosh drawing characters */
+#define CURS_GRAPHICS   4   /* Portable curses drawing characters */
 
 /*
  * The 5 possible states of doors
diff -burN '--exclude=.svn' nethack-orig/include/system.h nethack-3.4.3/include/system.h
--- nethack-orig/include/system.h	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/include/system.h	2010-12-17 14:00:58.498525002 -0500
@@ -79,7 +79,7 @@
 # if !defined(__SC__) && !defined(LINUX)
 E  long NDECL(random);
 # endif
-# if (!defined(SUNOS4) && !defined(bsdi) && !defined(__FreeBSD__)) || defined(RANDOM)
+# if (!defined(SUNOS4) && !defined(bsdi) && !defined(__NetBSD__) && !defined(__FreeBSD__) && !defined(__DragonFly__) && !defined(__APPLE__)) || defined(RANDOM)
 E void FDECL(srandom, (unsigned int));
 # else
 #  if !defined(bsdi) && !defined(__FreeBSD__)
diff -burN '--exclude=.svn' nethack-orig/include/unixconf.h nethack-3.4.3/include/unixconf.h
--- nethack-orig/include/unixconf.h	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/include/unixconf.h	2010-12-17 14:00:58.508525002 -0500
@@ -37,7 +37,7 @@
 #define NETWORK		/* if running on a networked system */
 			/* e.g. Suns sharing a playground through NFS */
 /* #define SUNOS4 */	/* SunOS 4.x */
-/* #define LINUX */	/* Another Unix clone */
+#define LINUX	/* Another Unix clone */
 /* #define CYGWIN32 */	/* Unix on Win32 -- use with case sensitive defines */
 /* #define GENIX */	/* Yet Another Unix Clone */
 /* #define HISX */	/* Bull Unix for XPS Machines */
@@ -143,7 +143,7 @@
  * A stat system call is done on the mailbox every MAILCKFREQ moves.
  */
 
-#define MAIL			/* Deliver mail during the game */
+/* #define MAIL */			/* Deliver mail during the game */
 
 /* The Andrew Message System does mail a little differently from normal
  * UNIX.  Mail is deposited in the user's own directory in ~/Mailbox
diff -burN '--exclude=.svn' nethack-orig/include/wincurs.h nethack-3.4.3/include/wincurs.h
--- nethack-orig/include/wincurs.h	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/include/wincurs.h	2010-12-17 14:00:58.488525002 -0500
@@ -0,0 +1,291 @@
+#ifndef WINCURS_H
+#define WINCURS_H
+
+/* Global declarations for curses interface */
+
+int term_rows, term_cols; /* size of underlying terminal */
+
+WINDOW *base_term;    /* underlying terminal window */
+
+WINDOW *mapwin, *statuswin, *messagewin;    /* Main windows */
+
+boolean counting;   /* Count window is active */
+
+
+#define TEXTCOLOR   /* Allow color */
+#define NHW_END 19
+#define OFF 0
+#define ON 1
+#define NONE -1
+#define KEY_ESC 0x1b
+#define DIALOG_BORDER_COLOR CLR_MAGENTA
+#define SCROLLBAR_COLOR CLR_MAGENTA
+#define SCROLLBAR_BACK_COLOR CLR_BLACK
+#define HIGHLIGHT_COLOR CLR_WHITE
+#define MORECOLOR CLR_ORANGE
+#define STAT_UP_COLOR CLR_GREEN
+#define STAT_DOWN_COLOR CLR_RED
+#define MESSAGE_WIN 1
+#define STATUS_WIN  2
+#define MAP_WIN     3
+#define NHWIN_MAX   4
+#define MESG_HISTORY_MAX   200
+#if !defined(__APPLE__) || !defined(NCURSES_VERSION)
+# define USE_DARKGRAY /* Allow "bright" black; delete if not visible */
+#endif	/* !__APPLE__ && !PDCURSES */
+#define CURSES_DARK_GRAY    17
+#define MAP_SCROLLBARS
+#ifdef PDCURSES
+# define getmouse nc_getmouse
+# ifndef NCURSES_MOUSE_VERSION
+#  define NCURSES_MOUSE_VERSION
+# endif
+#endif
+
+
+typedef enum orient_type
+{
+    CENTER,
+    UP,
+    DOWN,
+    RIGHT,
+    LEFT,
+    UNDEFINED
+} orient;
+
+
+/* cursmain.c */
+
+extern struct window_procs curses_procs;
+
+extern void curses_init_nhwindows(int* argcp, char** argv);
+
+extern void curses_player_selection(void);
+
+extern void curses_askname(void);
+
+extern void curses_get_nh_event(void);
+
+extern void curses_exit_nhwindows(const char *str);
+
+extern void curses_suspend_nhwindows(const char *str);
+
+extern void curses_resume_nhwindows(void);
+
+extern winid curses_create_nhwindow(int type);
+
+extern void curses_clear_nhwindow(winid wid);
+
+extern void curses_display_nhwindow(winid wid, BOOLEAN_P block);
+
+extern void curses_destroy_nhwindow(winid wid);
+
+extern void curses_curs(winid wid, int x, int y);
+
+extern void curses_putstr(winid wid, int attr, const char *text);
+
+extern void curses_display_file(const char *filename,BOOLEAN_P must_exist);
+
+extern void curses_start_menu(winid wid);
+
+extern void curses_add_menu(winid wid, int glyph, const ANY_P * identifier,
+		CHAR_P accelerator, CHAR_P group_accel, int attr, 
+		const char *str, BOOLEAN_P presel);
+
+extern void curses_end_menu(winid wid, const char *prompt);
+
+extern int curses_select_menu(winid wid, int how, MENU_ITEM_P **selected);
+
+extern void curses_update_inventory(void);
+
+extern void curses_mark_synch(void);
+
+extern void curses_wait_synch(void);
+
+extern void curses_cliparound(int x, int y);
+
+extern void curses_print_glyph(winid wid,XCHAR_P x,XCHAR_P y,int glyph);
+
+extern void curses_raw_print(const char *str);
+
+extern void curses_raw_print_bold(const char *str);
+
+extern int curses_nhgetch(void);
+
+extern int curses_nh_poskey(int *x, int *y, int *mod);
+
+extern void curses_nhbell(void);
+
+extern int curses_doprev_message(void);
+
+extern char curses_yn_function(const char *question, const char *choices, CHAR_P def);
+
+extern void curses_getlin(const char *question, char *input);
+
+extern int curses_get_ext_cmd(void);
+
+extern void curses_number_pad(int state);
+
+extern void curses_delay_output(void);
+
+extern void curses_start_screen(void);
+
+extern void curses_end_screen(void);
+
+extern void curses_outrip(winid wid, int how);
+
+extern void genl_outrip(winid tmpwin, int how);
+
+extern void curses_preference_update(const char *pref);
+
+
+/* curswins.c */
+
+extern WINDOW *curses_create_window(int width, int height, orient orientation);
+
+extern void curses_destroy_win(WINDOW *win);
+
+extern WINDOW *curses_get_nhwin(winid wid);
+
+extern void curses_add_nhwin(winid wid, int height, int width, int y,
+ int x, orient orientation, boolean border);
+
+extern void curses_add_wid(winid wid);
+
+extern void curses_refresh_nhwin(winid wid);
+
+extern void curses_refresh_nethack_windows(void);
+
+extern void curses_del_nhwin(winid wid);
+
+extern void curses_del_wid(winid wid);
+
+extern void curses_putch(winid wid, int x, int y, int ch, int color, int attrs);
+
+extern void curses_get_window_size(winid wid, int *height, int *width);
+
+extern boolean curses_window_has_border(winid wid);
+
+extern boolean curses_window_exists(winid wid);
+
+extern int curses_get_window_orientation(winid wid);
+
+extern void curses_get_window_xy(winid wid, int *x, int *y);
+
+extern void curses_puts(winid wid, int attr, const char *text);
+
+extern void curses_clear_nhwin(winid wid);
+
+extern void curses_draw_map(int sx, int sy, int ex, int ey);
+
+extern boolean curses_map_borders(int *sx, int *sy, int *ex, int *ey,
+ int ux, int uy);
+
+
+/* cursmisc.c */
+
+extern int curses_read_char(void);
+
+extern void curses_toggle_color_attr(WINDOW *win, int color, int attr, int onoff);
+
+extern void curses_bail(const char *mesg);
+
+extern winid curses_get_wid(int type);
+
+extern char *curses_copy_of(const char *s);
+
+extern int curses_num_lines(const char *str, int width);
+
+extern char *curses_break_str(const char *str, int width, int line_num);
+
+extern char *curses_str_remainder(const char *str, int width, int line_num);
+
+extern boolean curses_is_menu(winid wid);
+
+extern boolean curses_is_text(winid wid);
+
+extern int curses_convert_glyph(int ch, int glyph);
+
+extern void curses_move_cursor(winid wid, int x, int y);
+
+extern void curses_prehousekeeping(void);
+
+extern void curses_posthousekeeping(void);
+
+extern void curses_view_file(const char *filename, boolean must_exist);
+
+extern void curses_rtrim(char *str);
+
+extern int curses_get_count(int first_digit);
+
+extern int curses_convert_attr(int attr);
+
+extern int curses_read_attrs(char *attrs);
+
+extern int curses_convert_keys(int key);
+
+extern int curses_get_mouse(int *mousex, int *mousey, int *mod);
+
+/* cursdial.c */
+
+extern void curses_line_input_dialog(const char *prompt, char *answer, int buffer);
+
+extern int curses_character_input_dialog(const char *prompt, const char *choices, CHAR_P def);
+
+extern int curses_ext_cmd(void);
+
+extern void curses_create_nhmenu(winid wid);
+
+extern void curses_add_nhmenu_item(winid wid, const ANY_P *identifier,
+ CHAR_P accelerator, CHAR_P group_accel, int attr, const char *str,
+ BOOLEAN_P presel);
+
+extern void curses_finalize_nhmenu(winid wid, const char *prompt);
+
+extern int curses_display_nhmenu(winid wid, int how, MENU_ITEM_P **_selected);
+
+extern boolean curses_menu_exists(winid wid);
+
+extern void curses_del_menu(winid wid);
+
+
+/* cursstat.c */
+
+extern void curses_update_stats(boolean redraw);
+
+extern void curses_decrement_highlight(void);
+
+
+/* cursinit.c */
+
+extern void curses_create_main_windows(void);
+
+extern void curses_init_nhcolors(void);
+
+extern void curses_choose_character(void);
+
+extern int curses_character_dialog(const char** choices, const char *prompt);
+
+extern void curses_init_options(void);
+
+extern void curses_display_splash_window(void);
+
+
+/* cursmesg.c */
+
+extern void curses_message_win_puts(const char *message, boolean recursed);
+
+extern int curses_more(void);
+
+extern void curses_clear_unhighlight_message_window(void);
+
+extern void curses_last_messages(void);
+
+extern void curses_init_mesg_history(void);
+
+extern void curses_prev_mesg(void);
+
+extern void curses_count_window(const char *count_text);
+
+#endif  /* WINCURS_H */
+
diff -burN '--exclude=.svn' nethack-orig/include/winprocs.h nethack-3.4.3/include/winprocs.h
--- nethack-orig/include/winprocs.h	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/include/winprocs.h	2010-12-17 14:00:58.478525002 -0500
@@ -176,8 +176,13 @@
 
 #define WC2_FULLSCREEN		0x01L	/* 01 display full screen                    */
 #define WC2_SOFTKEYBOARD	0x02L	/* 02 software keyboard                      */
-#define WC2_WRAPTEXT		0x04L	/* 04 wrap long lines of text                */
-					/* 29 free bits */
+#define WC2_WRAPTEXT		0x04L	/* 03 wrap long lines of text                */
+#define WC2_TERM_COLS		0x08L	/* 04 supports setting terminal width        */
+#define WC2_TERM_ROWS		0x10L	/* 05 supports setting terminal height       */
+#define WC2_WINDOWBORDERS   0x20L	/* 06 display borders for NetHack windows    */
+#define WC2_PETATTR         0x40L	/* 07 attributes for highlight_pet */
+#define WC2_GUICOLOR        0x80L	/* 08 attributes for highlight_pet */
+					/* 25 free bits */
 
 #define ALIGN_LEFT	1
 #define ALIGN_RIGHT	2
diff -burN '--exclude=.svn' nethack-orig/README-curses.txt nethack-3.4.3/README-curses.txt
--- nethack-orig/README-curses.txt	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/README-curses.txt	2010-12-18 16:00:00.418308195 -0500
@@ -0,0 +1,168 @@
+Current documentation may be found on the project homepage at:
+
+http://nethack-curses.wikia.com/wiki/NetHack_Curses_Interface_Wiki
+
+The "curses" windowport is a new text-based interface for NetHack,
+using high-level curses routines to control the display. Currently, it
+has been compiled and tested on Linux, Windows, and Mac OS X, but it
+should also be portable to a number of other systems, such as other
+forms of UNIX, MSDOS, and OS/2.
+
+Features
+========
+
+Some features of this interface compared to the traditional tty
+interface include:
+  * Dynamic window resizing (e.g. maximizing a terminal window)
+
+  * Dynamic configurable placement of status and message windows,
+    relative to the map
+
+  * Makes better use of larger and smaller terminal windows, such as a
+    multi-line message window if there is space
+
+  * Optional mouse support (click to move player, etc) 
+
+  * Menu text search/selection 
+
+  * Fancier display (e.g. window borders, optional popup dialogs,
+    splash screen, and better menus)
+
+  * Improved keyboard navigation of menus
+
+  * "cursesgraphics" option for fancier line-drawing characters for
+    drawing the dungeon - this should work on most terminals/platforms
+
+Gameplay
+========
+
+Gameplay should be similar to the tty interface for NetHack; the
+differences are primarily visual. This windowport supports dymanic
+resizing of the terminal window, so you can play with it to see how it
+looks best to you during a game. Also, the align_status and
+align_message options may be set during the game or in the config file
+to place the status and message windows where you like, so you can
+experiment to see what arrangement looks best to you.
+
+For menus, in addition to the normal configurable keybindings for menu
+navigation described in the Guidebook, you can use the right and left
+arrows to to forward or backward one page, respectively, and the home
+and end keys to go to the first and last pages, respectively.
+
+Configuration Options
+=====================
+
+Some configuration options that are specific to or relevant to the
+curses windowport are shown below. Copy any of these that you like to
+your nethack configuration file (e.g. .nethackrc for UNIX or
+NetHack.cnf for Windows):
+#
+# Use this if the binary was compiled with multiple window interfaces,
+# and curses is not the default
+OPTIONS=windowtype:curses
+#
+# Set this for Windows systems, or for PDCurses for SDL on any system.
+# The latter uses a cp437 font, which works with this option
+#OPTIONS=IBMgraphics
+#
+# Set this if IBMgraphics above won't work for your system.  Mutually
+# exclusive with the above option, and should work on nearly any
+# system.
+OPTIONS=cursesgraphics
+#
+# Optionally specify the alignment of the message and status windows
+# relative to the map window.  If not specified, the code will default
+# to the locations used in the tty interface: message window on top,
+# and status window on bottom.  Placing either of these on the right or
+# left really only works well for winder terminal windows.
+OPTIONS=align_message:bottom,align_status:right
+#
+# Use a small popup "window" for short prompts, e.g. "Really save?".
+# If this is not set, the message window will be used for these as is
+# done for the tty interface.
+OPTIONS=popup_dialog
+#
+# Specify the initial window size for NetHack in units of characters.
+# This is supported on PDCurses for SDL as well as PDCurses for
+# Windows.
+OPTIONS=term_cols:110,term_rows:32
+#
+# Controls the usage of window borders for the main NetHack windows
+# (message, map, and status windows).  A value of 1 forces the borders
+# to be drawn, a value of 2 forces them to be off, and a value of 3
+# allows the code to decide if they should be drawn based on the size
+# of the terminal window.
+OPTIONS=windowborders:3
+#
+# Whether or not to display a fancy ascii-graphics splash screen on
+# startup.
+OPTIONS=splash_screen
+#
+# This controls what text attributes are used to highlight any pets.
+# Any combination of single letters representing each text attribute
+# may be used.  Not all attributes work on all terminals.
+#
+# Attributes may be one or more of: Bold, Inverse, Underline, blinK,
+# iTalic, Rightline, or Leftline.  The default is underline.
+OPTIONS=petattr:u
+#
+# Controls whether color and attributes are used for menu headers,
+# window borders, message text, etc.  This is separate from the color
+# option, which only controls the color of the map itself.
+OPTIONS=guicolor
+#
+# Use the mouse for moving around.  This option defaults to false.
+#
+OPTIONS=mouse_support
+
+Compiling From Source
+=====================
+
+Linux / Other UNIXes:
+
+   Follow the instructions in sys/unix/Install.unx. By default, the
+   Makefile is setup to compile with ncurses. Edit Makefile.src if you
+   wish to compile against a different curses library, such as PDCurses
+   for SDL. Curses implementations other than Ncurses and PDCurses will
+   likely work, too, but have not been tested.
+
+Windows:
+
+  * Make sure your development environment is setup correctly to
+    compile NetHack. You may want to try building it unmodified before
+    trying to add the patch. The makefile that I provide is for
+    Mingw32, so if you use a different compiler, you will have to edit
+    the appropriate makefile by hand.
+  * Download SDL for Windows. Just the base SDL library is needed.
+  * Download PDCurses, and compile PDCurses-SDL in the sdl1
+    subdirectory. The provided makefile assumes you are using Mingw32.
+  * Place both libraries (SDL and PDCurses) somewhere where the NetHack
+    build can use them. The makefile I provide is setup to look for the
+    static versions of these libraries in a lib subdirectory under the
+    main nethack directory.
+  * As an alternative to installing/compiling the SDL and PDCurses-SDL
+    libraries, you may download precompiled versions of these, and
+    unzip them into your NetHack source directory:
+    http://nethack.edeca.net/karl/winlibs.zip
+  * Follow the instructions in sys/winnt/Install.nt witht he following
+    exception:
+       + Instead of typing "mingw32-make -f Makefile.gcc install" you
+         will type "mingw32-make -f cursmake.gcc install"
+
+Make sure you are compiling from a standard Windows command prompt and
+not a UNIX-style shell, or else it will not work!
+
+
+Known Issues
+============
+
+The current list may be found at:
+
+http://nethack-curses.wikia.com/wiki/Known_Issues
+
+Contact
+=======
+
+The curses windowport was written by Karl Garrison. I may be contacted
+at kgarrison@pobox.com.
+
diff -burN '--exclude=.svn' nethack-orig/src/cmd.c nethack-3.4.3/src/cmd.c
--- nethack-orig/src/cmd.c	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/src/cmd.c	2010-12-17 14:01:00.128525001 -0500
@@ -322,7 +322,7 @@
 	return 0;
 }
 
-#ifdef TTY_GRAPHICS
+#if defined(TTY_GRAPHICS) || defined(CURSES_GRAPHICS)
 #define MAX_EXT_CMD 40		/* Change if we ever have > 40 ext cmds */
 /*
  * This is currently used only by the tty port and is
diff -burN '--exclude=.svn' nethack-orig/src/drawing.c nethack-3.4.3/src/drawing.c
--- nethack-orig/src/drawing.c	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/src/drawing.c	2010-12-17 14:01:00.098525001 -0500
@@ -4,7 +4,6 @@
 
 #include "hack.h"
 #include "tcap.h"
-
 /* Relevent header information in rm.h and objclass.h. */
 
 #ifdef C
@@ -314,6 +313,10 @@
 void NDECL((*ibmgraphics_mode_callback)) = 0;	/* set in tty_start_screen() */
 #endif /* PC9800 */
 
+#ifdef CURSES_GRAPHICS
+void NDECL((*cursesgraphics_mode_callback)) = 0;
+#endif
+
 static uchar ibm_graphics[MAXPCHARS] = {
 /* 0*/	g_FILLER(S_stone),
 	0xb3,	/* S_vwall:	meta-3, vertical rule */
@@ -674,6 +677,9 @@
  */
 	    iflags.IBMgraphics = TRUE;
 	    iflags.DECgraphics = FALSE;
+#ifdef CURSES_GRAPHICS
+        iflags.cursesgraphics = FALSE;
+#endif
 	    assign_graphics(ibm_graphics, SIZE(ibm_graphics), MAXPCHARS, 0);
 #ifdef PC9800
 	    if (ibmgraphics_mode_callback) (*ibmgraphics_mode_callback)();
@@ -687,6 +693,9 @@
  */
 	    iflags.DECgraphics = TRUE;
 	    iflags.IBMgraphics = FALSE;
+#ifdef CURSES_GRAPHICS
+        iflags.cursesgraphics = FALSE;
+#endif
 	    assign_graphics(dec_graphics, SIZE(dec_graphics), MAXPCHARS, 0);
 	    if (decgraphics_mode_callback) (*decgraphics_mode_callback)();
 	    break;
@@ -696,6 +705,14 @@
 	    assign_graphics(mac_graphics, SIZE(mac_graphics), MAXPCHARS, 0);
 	    break;
 #endif
+#ifdef CURSES_GRAPHICS
+    case CURS_GRAPHICS:
+	    assign_graphics((uchar *)0, 0, MAXPCHARS, 0);
+        iflags.cursesgraphics = TRUE;
+	    iflags.IBMgraphics = FALSE;
+	    iflags.DECgraphics = FALSE;
+        break;
+#endif
 	}
     return;
 }
diff -burN '--exclude=.svn' nethack-orig/src/options.c nethack-3.4.3/src/options.c
--- nethack-orig/src/options.c	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/src/options.c	2010-12-17 14:01:00.138525001 -0500
@@ -23,6 +23,10 @@
 #define PREFER_TILED FALSE
 #endif
 
+#ifdef CURSES_GRAPHICS
+extern int curses_read_attrs(char *attrs);
+#endif
+
 /*
  *  NOTE:  If you add (or delete) an option, please update the short
  *  options help (option_help()), the long options help (dat/opthelp),
@@ -69,19 +73,24 @@
 	{"checkspace", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
 	{"cmdassist", &iflags.cmdassist, TRUE, SET_IN_GAME},
-# if defined(MICRO) || defined(WIN32)
+# if defined(MICRO) || defined(WIN32) || defined(CURSES_GRAPHICS)
 	{"color",         &iflags.wc_color,TRUE, SET_IN_GAME},		/*WC*/
 # else	/* systems that support multiple terminals, many monochrome */
 	{"color",         &iflags.wc_color, FALSE, SET_IN_GAME},	/*WC*/
 # endif
 	{"confirm",&flags.confirm, TRUE, SET_IN_GAME},
+#ifdef CURSES_GRAPHICS
+	{"cursesgraphics", &iflags.cursesgraphics, TRUE, SET_IN_GAME},
+#else
+	{"cursesgraphics", (boolean *)0, FALSE, SET_IN_FILE},
+#endif
 #if defined(TERMLIB) && !defined(MAC_GRAPHICS_ENV)
 	{"DECgraphics", &iflags.DECgraphics, FALSE, SET_IN_GAME},
 #else
 	{"DECgraphics", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
 	{"eight_bit_tty", &iflags.wc_eight_bit_input, FALSE, SET_IN_GAME},	/*WC*/
-#ifdef TTY_GRAPHICS
+#if defined(TTY_GRAPHICS) || defined(CURSES_GRAPHICS)
 	{"extmenu", &iflags.extmenu, FALSE, SET_IN_GAME},
 #else
 	{"extmenu", (boolean *)0, FALSE, SET_IN_FILE},
@@ -99,6 +108,7 @@
 	{"flush", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
 	{"fullscreen", &iflags.wc2_fullscreen, FALSE, SET_IN_FILE},
+	{"guicolor", &iflags.wc2_guicolor, TRUE, SET_IN_GAME},
 	{"help", &flags.help, TRUE, SET_IN_GAME},
 	{"hilite_pet",    &iflags.wc_hilite_pet, FALSE, SET_IN_GAME},	/*WC*/
 #ifdef ASCIIGRAPH
@@ -131,7 +141,11 @@
 #else
 	{"menu_tab_sep", (boolean *)0, FALSE, SET_IN_FILE},
 #endif
+#ifdef CURSES_GRAPHICS
+	{"mouse_support", &iflags.wc_mouse_support, FALSE, DISP_IN_GAME},	/*WC*/
+#else
 	{"mouse_support", &iflags.wc_mouse_support, TRUE, DISP_IN_GAME},	/*WC*/
+#endif
 #ifdef NEWS
 	{"news", &iflags.news, TRUE, DISP_IN_GAME},
 #else
@@ -288,6 +302,7 @@
 						15, SET_IN_FILE },
 # endif
 #endif
+	{ "petattr",  "attributes for highlighting pets", 12, SET_IN_FILE },
 	{ "pettype",  "your preferred initial pet type", 4, DISP_IN_GAME },
 	{ "pickup_burden",  "maximum burden picked up before prompt",
 						20, SET_IN_GAME },
@@ -2043,6 +2058,63 @@
 		return;
 	}
 
+	/* WINCAP2
+	 * term_cols:amount */
+	fullname = "term_cols";
+	if (match_optname(opts, fullname, sizeof("term_cols")-1, TRUE)) {
+		op = string_for_opt(opts, negated);
+		iflags.wc2_term_cols = atoi(op);
+		if (negated) bad_negation(fullname, FALSE);
+		return;
+	}
+
+	/* WINCAP2
+	 * term_rows:amount */
+	fullname = "term_rows";
+	if (match_optname(opts, fullname, sizeof("term_rows")-1, TRUE)) {
+		op = string_for_opt(opts, negated);
+		iflags.wc2_term_rows = atoi(op);
+		if (negated) bad_negation(fullname, FALSE);
+		return;
+	}
+
+
+	/* WINCAP2
+	 * petattr:string */
+	fullname = "petattr";
+	if (match_optname(opts, fullname, sizeof("petattr")-1, TRUE)) {
+		op = string_for_opt(opts, negated);
+		if (op && !negated) {
+		    iflags.wc2_petattr = curses_read_attrs(op);
+		    if (!curses_read_attrs(op))
+		    	badoption(opts);
+		} else if (negated) bad_negation(fullname, TRUE);
+		return;
+	}
+
+
+	/* WINCAP2
+	 * windowborders:n */
+	fullname = "windowborders";
+	if (match_optname(opts, fullname, sizeof("windowborders")-1, TRUE)) {
+		op = string_for_opt(opts, negated);
+		if (negated && op) bad_negation(fullname, TRUE);
+		else {
+		    if (negated)
+		        iflags.wc2_windowborders = 2; /* Off */
+		    else if (!op)
+		        iflags.wc2_windowborders = 1; /* On */
+		    else    /* Value supplied */
+		        iflags.wc2_windowborders = atoi(op);
+		    if ((iflags.wc2_windowborders > 3) ||
+		     (iflags.wc2_windowborders < 1)) {
+		        iflags.wc2_windowborders = 0;
+		        badoption(opts);
+		    }
+		}
+		return;
+	}
+
 	/* menustyle:traditional or combo or full or partial */
 	if (match_optname(opts, "menustyle", 4, TRUE)) {
 		int tmp;
@@ -2149,7 +2221,7 @@
 
 			duplicate_opt_detection(boolopt[i].name, 0);
 
-#if defined(TERMLIB) || defined(ASCIIGRAPH) || defined(MAC_GRAPHICS_ENV)
+#if defined(TERMLIB) || defined(ASCIIGRAPH) || defined(MAC_GRAPHICS_ENV) || defined(CURSES_GRAPHICS)
 			if (FALSE
 # ifdef TERMLIB
 				 || (boolopt[i].addr) == &iflags.DECgraphics
@@ -2160,6 +2232,9 @@
 # ifdef MAC_GRAPHICS_ENV
 				 || (boolopt[i].addr) == &iflags.MACgraphics
 # endif
+# ifdef CURSES_GRAPHICS
+				 || (boolopt[i].addr) == &iflags.cursesgraphics
+# endif
 				) {
 # ifdef REINCARNATION
 			    if (!initial && Is_rogue_level(&u.uz))
@@ -2181,6 +2256,11 @@
 				switch_graphics(iflags.MACgraphics ?
 						MAC_GRAPHICS : ASCII_GRAPHICS);
 # endif
+# ifdef CURSES_GRAPHICS
+			    if ((boolopt[i].addr) == &iflags.cursesgraphics)
+				switch_graphics(iflags.cursesgraphics ?
+						CURS_GRAPHICS : ASCII_GRAPHICS);
+# endif
 # ifdef REINCARNATION
 			    if (!initial && Is_rogue_level(&u.uz))
 				assign_rogue_graphics(TRUE);
@@ -2223,9 +2303,15 @@
 			}
 			else if ((boolopt[i].addr) == &iflags.use_inverse ||
 					(boolopt[i].addr) == &iflags.showrace ||
-					(boolopt[i].addr) == &iflags.hilite_pet) {
+					(boolopt[i].addr) == &iflags.hilite_pet ||
+					(boolopt[i].addr) == &iflags.wc2_guicolor) {
 			    need_redraw = TRUE;
 			}
+#ifdef CURSES_GRAPHICS
+			else if ((boolopt[i].addr) == &iflags.cursesgraphics) {
+			    need_redraw = TRUE;
+			}
+#endif
 #ifdef TEXTCOLOR
 			else if ((boolopt[i].addr) == &iflags.use_color) {
 			    need_redraw = TRUE;
@@ -3087,6 +3173,14 @@
 			FEATURE_NOTICE_VER_MIN,
 			FEATURE_NOTICE_VER_PATCH);
 	}
+	else if (!strcmp(optname, "term_cols")) {
+		if (iflags.wc2_term_cols) Sprintf(buf, "%d",iflags.wc2_term_cols);
+		else Strcpy(buf, defopt);
+	}
+	else if (!strcmp(optname, "term_rows")) {
+		if (iflags.wc2_term_rows) Sprintf(buf, "%d",iflags.wc2_term_rows);
+		else Strcpy(buf, defopt);
+	}
 	else if (!strcmp(optname, "tile_file"))
 		Sprintf(buf, "%s", iflags.wc_tile_file ? iflags.wc_tile_file : defopt);
 	else if (!strcmp(optname, "tile_height")) {
@@ -3120,6 +3214,11 @@
 			ttycolors[CLR_BRIGHT_MAGENTA],
 			ttycolors[CLR_BRIGHT_CYAN]);
 #endif /* VIDEOSHADES */
+	else if (!strcmp(optname,"windowborders"))
+		Sprintf(buf, "%s", iflags.wc2_windowborders == 1     ? "1=on" :
+				   iflags.wc2_windowborders == 2             ? "2=off" :
+				   iflags.wc2_windowborders == 3             ? "3=auto" :
+				   defopt);
 	else if (!strcmp(optname, "windowtype"))
 		Sprintf(buf, "%s", windowprocs.name);
 	else if (!strcmp(optname, "windowcolors"))
@@ -3593,6 +3692,11 @@
 	{"fullscreen", WC2_FULLSCREEN},
 	{"softkeyboard", WC2_SOFTKEYBOARD},
 	{"wraptext", WC2_WRAPTEXT},
+	{"term_cols", WC2_TERM_COLS},
+	{"term_rows", WC2_TERM_ROWS},
+	{"windowborders", WC2_WINDOWBORDERS},
+	{"petattr", WC2_PETATTR},
+	{"guicolor", WC2_GUICOLOR},
 	{(char *)0, 0L}
 };
 
diff -burN '--exclude=.svn' nethack-orig/src/rip.c nethack-3.4.3/src/rip.c
--- nethack-orig/src/rip.c	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/src/rip.c	2010-12-17 14:01:00.138525001 -0500
@@ -8,7 +8,7 @@
 
 extern const char * const killed_by_prefix[];	/* from topten.c */
 
-#if defined(TTY_GRAPHICS) || defined(X11_GRAPHICS) || defined(GEM_GRAPHICS) || defined(MSWIN_GRAPHICS)
+#if defined(TTY_GRAPHICS) || defined(X11_GRAPHICS) || defined(GEM_GRAPHICS) || defined(MSWIN_GRAPHICS) || defined(CURSES_GRAPHICS)
 # define TEXT_TOMBSTONE
 #endif
 #if defined(mac) || defined(__BEOS__) || defined(WIN32_GRAPHICS)
diff -burN '--exclude=.svn' nethack-orig/src/windows.c nethack-3.4.3/src/windows.c
--- nethack-orig/src/windows.c	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/src/windows.c	2010-12-17 14:01:00.098525001 -0500
@@ -6,6 +6,9 @@
 #ifdef TTY_GRAPHICS
 #include "wintty.h"
 #endif
+#ifdef CURSES_GRAPHICS
+extern struct window_procs curses_procs;
+#endif
 #ifdef X11_GRAPHICS
 /* cannot just blindly include winX.h without including all of X11 stuff */
 /* and must get the order of include files right.  Don't bother */
@@ -53,6 +56,9 @@
 #ifdef TTY_GRAPHICS
     { &tty_procs, win_tty_init },
 #endif
+#ifdef CURSES_GRAPHICS
+    { &curses_procs, 0 },
+#endif
 #ifdef X11_GRAPHICS
     { &X11_procs, win_X11_init },
 #endif
diff -burN '--exclude=.svn' nethack-orig/sys/unix/Makefile.src nethack-3.4.3/sys/unix/Makefile.src
--- nethack-orig/sys/unix/Makefile.src	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/sys/unix/Makefile.src	2010-12-17 14:01:03.698525001 -0500
@@ -61,7 +61,7 @@
 #	if you get setcgtty() warnings during execution, you are feeding gcc
 #		a non-ANSI <sys/ioctl.h> -- either run fixincludes on it or use
 #		-traditional in CFLAGS
-# CC = gcc
+CC = gcc
 #
 #	For Bull DPX/2 systems at B.O.S. 2.0 or higher use the following:
 #
@@ -141,6 +141,17 @@
 #LINK = gcc
 #LFLAGS = -Xlinker -soname=_APP_
 
+# Compile with PDCurses installed in a separate directory that doesn't
+# conflict with the system curses/ncurses library
+#CFLAGS = -O -I../include -I/usr/local/include/pdcurses
+# Same as above, but for Mac OS X
+#CFLAGS = -O2 -I../include
+# Same as above, but for XCurses
+#CFLAGS = -O -DXCURSES -I../include -I/usr/local/include/pdcurses
+# Compile against system curses library, such as ncurses
+CFLAGS = -O -I../include
+
+
 # Only used for the Gnome interface.
 # When including the Gnome interface, you need to include gnome specific
 # directories.  The ones given below is the usual spot for linux systems.
@@ -151,8 +162,8 @@
 # flags for debugging:
 # CFLAGS = -g -I../include
 
-CFLAGS = -O -I../include
-LFLAGS = 
+#CFLAGS = -O -I../include
+#LFLAGS = 
 
 # The Qt and Be window systems are written in C++, while the rest of
 # NetHack is standard C.  If using Qt, uncomment the LINK line here to get
@@ -174,6 +185,14 @@
 	../win/tty/wintty.c
 WINTTYOBJ = getline.o termcap.o topl.o wintty.o
 #
+# Files for curses interface
+WINCURSESSRC = ../win/curses/cursmain.c ../win/curses/curswins.c \
+	../win/curses/cursmisc.c ../win/curses/cursdial.c \
+	../win/curses/cursstat.c ../win/curses/cursinit.c \
+	../win/curses/cursmesg.c
+WINCURSESOBJ = cursmain.o curswins.o cursmisc.o cursdial.o cursstat.o \
+	cursinit.o cursmesg.o
+#
 # files for an X11 port
 # (tile.c is a generated source file)
 WINX11SRC = ../win/X11/Window.c ../win/X11/dialogs.c ../win/X11/winX.c \
@@ -214,8 +233,8 @@
 
 #
 #
-WINSRC = $(WINTTYSRC)
-WINOBJ = $(WINTTYOBJ)
+WINSRC = $(WINCURSESSRC)
+WINOBJ = $(WINCURSESOBJ)
 
 # on some systems the termcap library is in -ltermcap or -lcurses
 # on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
@@ -231,8 +250,15 @@
 # WINTTYLIB = -lcurses
 # WINTTYLIB = -lcurses16
 # WINTTYLIB = -lncurses
-WINTTYLIB = -ltermlib
+# WINTTYLIB = -ltermlib
 #
+# libraries for curses port
+# link with ncurses
+WINCURSESLIB = -lncurses
+# link with pdcurses for SDL, installed in a separate directory
+#WINCURSESLIB = -L/usr/local/lib -lpdcurses $(shell sdl-config --libs)
+# same as above, for XCurses
+#WINCURSESLIB = -L/usr/local/lib -lXCurses -lXaw -lXmu -lXext -lXt -lX11
 # libraries for X11
 # If USE_XPM is defined in config.h, you will also need -lXpm here.
 WINX11LIB = -lXaw -lXmu -lXext -lXt -lX11
@@ -255,7 +281,7 @@
 # libraries for BeOS 
 WINBELIB = -lbe
 
-WINLIB = $(WINTTYLIB)
+WINLIB = $(WINCURSESLIB)
 
 # any other strange libraries your system needs (for Sysunix only -- the more
 # specialized targets should already be right)
@@ -605,6 +631,26 @@
 wintty.o: ../win/tty/wintty.c $(HACK_H) ../include/dlb.h \
 		../include/patchlevel.h ../include/tcap.h
 	$(CC) $(CFLAGS) -c ../win/tty/wintty.c
+cursmain.o: ../win/curses/cursmain.c $(HACK_H) ../include/wincurs.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursmain.c
+curswins.o: ../win/curses/curswins.c $(HACK_H) ../include/func_tab.h \
+		../include/wincurs.h ../win/curses/curswins.h
+	$(CC) $(CFLAGS) -c ../win/curses/curswins.c
+cursmisc.o: ../win/curses/cursmisc.c $(HACK_H) ../include/wincurs.h \
+		../win/curses/cursmisc.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursmisc.c
+cursdial.o: ../win/curses/cursdial.c $(HACK_H) ../include/func_tab.h \
+		../include/wincurs.h ../win/curses/cursdial.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursdial.c
+cursstat.o: ../win/curses/cursstat.c $(HACK_H) ../include/wincurs.h \
+		../win/curses/cursstat.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursstat.c
+cursinit.o: ../win/curses/cursinit.c $(HACK_H) ../include/wincurs.h \
+		../win/curses/cursinit.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursinit.c
+cursmesg.o: ../win/curses/cursmesg.c $(HACK_H) ../include/wincurs.h \
+		../win/curses/cursmesg.h
+	$(CC) $(CFLAGS) -c ../win/curses/cursmesg.c
 Window.o: ../win/X11/Window.c ../include/xwindowp.h ../include/xwindow.h \
 		$(CONFIG_H)
 	$(CC) $(CFLAGS) -c ../win/X11/Window.c
diff -burN '--exclude=.svn' nethack-orig/sys/winnt/cursmake.gcc nethack-3.4.3/sys/winnt/cursmake.gcc
--- nethack-orig/sys/winnt/cursmake.gcc	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/sys/winnt/cursmake.gcc	2010-12-17 14:01:02.688525001 -0500
@@ -0,0 +1,1348 @@
+#   SCCS Id: @(#)Makefile.gcc       3.4     $Date: 2003/11/16 04:50:57 $
+#   Copyright (c) NetHack PC Development Team 1993-2003
+#
+#   NetHack 3.4.x Makefile for MinGW
+#
+#   Win32 Compilers Tested:
+#                  - MinGW 1.0 (gcc version 2.95.3-6) (Console NetHack only)
+#                  - MinGW 2.0 (gcc version 3.2)
+#
+#   If you don't have this compiler, you can get it at:
+#       http://www.mingw.org/
+#
+#   This is used for building two versions of NetHack:
+#   A tty port utilizing the Win32 Console I/O subsystem, Console
+#       NetHack;
+#   A Win32 native port built on the Windows API, Graphical NetHack or
+#       NetHackW.
+#
+#   In addition to your C compiler,
+#
+#     if you want to change     you will need a
+#     files with suffix         workalike for
+#         .y                     yacc   (such as bison)
+#         .l                     lex    (such as flex)
+#
+#
+#   If you have any questions read the sys/winnt/Install.nt file included
+#   with the distribution.
+#
+#   --
+#   Dion Nicolaas
+#==============================================================================
+# Graphical interface
+# Set to Y for a graphical version
+# Set to anything else (or undefine) for a tty version
+
+GRAPHICAL = N
+
+# Debug
+# Set to Y for Debug support (to produce debug information)
+# Set to anything else (or undefine) for a "release" version
+# You can set your debug options below.
+
+DEBUG = Y
+
+cc     = gcc
+rc     = windres
+link   = gcc
+
+cflags = -mms-bitfields
+lflags  = 
+ifeq  "$(DEBUG)" "Y"
+cdebug = -g
+linkdebug = -g
+else
+cdebug =
+linkdebug =
+endif
+
+#
+#  Set the gamedir according to your preference.
+#  If not present prior to compilation it gets created.
+
+ifeq  "$(GRAPHICAL)" "Y"
+# Game Name
+GAME    = NetHackW
+else
+# Game Name
+GAME    = NetHackC
+endif
+# Game directory
+GAMEDIR = ../binary
+
+#
+#  Source directories.    Makedefs hardcodes these, don't change them.
+#
+
+# NetHack include files
+INCL  = ../include
+# NetHack data files
+DAT   = ../dat
+# NetHack documentation files
+DOC   = ../doc
+# Utility source
+UTIL  = ../util
+# Main source
+SRC   = ../src
+# Shared system files
+SSYS  = ../sys/share
+# NT Win32 specific files
+NTSYS = ../sys/winnt
+# window port files (tty)
+#TTY   = ../win/tty
+TTY   = ../win/curses
+# window port files (Win32)
+WIN32 = ../win/win32
+# Tile support files
+WSHR  = ../win/share
+
+#
+#  Object directory.
+#
+
+OBJ = o
+
+
+#
+#==========================================
+# Exe File Info.
+#==========================================
+
+# Yacc/Lex ... if you got 'em.
+#
+# If you have yacc and lex programs (or work-alike such as bison
+# and flex), comment out the upper two macros and uncomment
+# the lower two.
+#
+
+DO_YACC = YACC_MSG
+DO_LEX  = LEX_MSG
+#DO_YACC  = YACC_ACT
+#DO_LEX   = LEX_ACT
+
+# - Specify your yacc and lex programs (or work-alikes) here.
+
+#YACC   = bison -y
+YACC   = byacc
+#YACC   = yacc
+
+#LEX    = lex
+LEX     = flex
+
+#
+# - Specify your flex skeleton file (if needed).
+#
+
+FLEXSKEL =
+#FLEXSKEL = -S../tools/flex.ske
+
+YTABC   = y_tab.c
+YTABH   = y_tab.h
+LEXYYC  = lexyy.c
+
+#
+# Optional high-quality BSD random number generation routines
+# (see pcconf.h). Set to nothing if not used.
+#
+
+RANDOM  = $(OBJ)/random.o
+#RANDOM =
+
+#===============================================
+#======= End of Modification Section ===========
+#===============================================
+################################################
+#                                              #
+# Nothing below here should have to be changed.#
+#                                              #
+################################################
+
+ifeq  "$(GRAPHICAL)" "Y"
+WINPORT  = $(O)tile.o $(O)mhaskyn.o $(O)mhdlg.o \
+	$(O)mhfont.o $(O)mhinput.o $(O)mhmain.o $(O)mhmap.o \
+	$(O)mhmenu.o $(O)mhmsgwnd.o $(O)mhrip.o $(O)mhsplash.o \
+	$(O)mhstatus.o $(O)mhtext.o $(O)mswproc.o $(O)winhack.o
+WINPFLAG   = -DTILES -DMSWIN_GRAPHICS -D_WIN32_IE=0x0400
+NHRES   = $(O)winres.o
+WINPINC = -I$(WIN32)
+WINPHDR = $(WIN32)/mhaskyn.h $(WIN32)/mhdlg.h $(WIN32)/mhfont.h \
+	$(WIN32)/mhinput.h $(WIN32)/mhmain.h $(WIN32)/mhmap.h \
+	$(WIN32)/mhmenu.h $(WIN32)/mhmsg.h $(WIN32)/mhmsgwnd.h \
+	$(WIN32)/mhrip.h $(WIN32)/mhstatus.h \
+	$(WIN32)/mhtext.h $(WIN32)/resource.h $(WIN32)/winMS.h
+WINPLIBS =  -lcomctl32 -lwinmm
+else
+WINPORT = $(O)nttty.o
+#WINPFLAG= -DWIN32CON
+WINPHDR =
+NHRES   = $(O)console.o
+WINPINC =
+#WINPLIBS = ../lib/pdcurses.a -lwinmm
+WINPLIBS = ../lib/libpdcurses.a ../lib/libSDL.a -lwinmm
+endif
+
+TILEUTIL16  = $(UTIL)/tile2bmp.exe
+TILEBMP16   = $(SRC)/tiles.bmp
+
+TILEUTIL32  = $(UTIL)/til2bm32.exe
+TILEBMP32   = $(SRC)/tiles32.bmp
+
+SOUND = $(OBJ)/ntsound.o
+
+#SOUND =
+
+# To store all the level files,
+# help files, etc. in a single library file.
+# USE_DLB = Y is left uncommented
+
+USE_DLB = Y
+
+ifeq  "$(USE_DLB)" "Y"
+DLBFLG = -DDLB
+else
+DLBFLG =
+endif
+
+#==========================================
+# Setting up the compiler and linker
+# macros. All builds include the base ones.
+#==========================================
+
+CFLAGSBASE  = -c $(cflags) -I$(INCL) $(WINPINC) $(cdebug)
+LFLAGSBASEC = $(linkdebug) -mwindows
+LFLAGSBASEG = $(linkdebug) -mwindows
+
+#==========================================
+# Util builds
+#==========================================
+
+CFLAGSU = $(CFLAGSBASE) $(WINPFLAG)
+LFLAGSU = $(LFLAGSBASEC)
+
+#==========================================
+# - Game build
+#==========================================
+
+CFLAGS   = $(CFLAGSBASE) $(WINPFLAG) $(DLBFLG)
+lflags  = $(LFLAGSBASE)
+ifeq "$(GRAPHICAL)" "Y"
+lflags  = $(LFLAGSBASEG)
+else
+lflags  = $(LFLAGSBASEC)
+endif
+
+GAMEFILE = $(GAMEDIR)/$(GAME).exe # whole thing
+
+ifeq  "$(USE_DLB)" "Y"
+DLB = nhdat
+else
+DLB =
+endif
+
+#==========================================
+#================ RULES ==================
+#==========================================
+
+.SUFFIXES: .exe .o .til .uu .c .y .l
+
+#==========================================
+# Rules for files in src
+#==========================================
+
+$(OBJ)/%.o : /%.c
+	$(cc) $(CFLAGS)  -o$@ $<
+
+$(OBJ)/%.o : $(SRC)/%.c
+	$(cc) $(CFLAGS)   -o$@  $<
+
+#==========================================
+# Rules for files in sys/share
+#==========================================
+
+$(OBJ)/%.o : $(SSYS)/%.c
+	$(cc) $(CFLAGS)  -o$@  $<
+
+#==========================================
+# Rules for files in sys/winnt
+#==========================================
+
+$(OBJ)/%.o : $(NTSYS)/%.c
+	$(cc) $(CFLAGS)  -o$@  $<
+
+$(INCL)/%.h : $(NTSYS)/%.h
+	@copy $< $@
+
+#==========================================
+# Rules for files in util
+#==========================================
+
+$(OBJ)/%.o : $(UTIL)/%.c
+	$(cc) $(CFLAGSU) -o$@ $<
+
+#==========================================
+# Rules for files in win/share
+#==========================================
+
+$(OBJ)/%.o : $(WSHR)/%.c
+	$(cc) $(CFLAGS)  -o$@ $<
+
+$(INCL)/%.h : $(WSHR)/%.h
+	@copy $< $@
+
+#{$(WSHR)}.txt{$(DAT)}.txt:
+#	@copy $< $@
+
+#==========================================
+# Rules for files in win/tty
+#==========================================
+
+$(OBJ)/%.o : $(TTY)/%.c
+	$(cc) $(CFLAGS)  -o$@  $<
+
+#==========================================
+# Rules for files in win/win32
+#==========================================
+
+$(OBJ)/%.o : $(WIN32)/%.c
+	$(cc) $(CFLAGS)  -o$@  $<
+
+#==========================================
+#================ MACROS ==================
+#==========================================
+# This section creates shorthand macros for many objects
+# referenced later on in the Makefile.
+#
+
+DEFFILE = $(NTSYS)/$(GAME).def
+
+#
+# Shorten up the location for some files
+#
+
+O  = $(OBJ)/
+
+U  = $(UTIL)/
+
+#
+# Utility Objects.
+#
+
+MAKESRC        = $(U)makedefs.c
+
+SPLEVSRC       = $(U)lev_yacc.c  $(U)lev_$(LEX).c $(U)lev_main.c  $(U)panic.c
+
+DGNCOMPSRC     = $(U)dgn_yacc.c  $(U)dgn_$(LEX).c $(U)dgn_main.c
+
+MAKEOBJS       = $(O)makedefs.o $(O)monst.o $(O)objects.o
+
+SPLEVOBJS      = $(O)lev_yacc.o  $(O)lev_$(LEX).o $(O)lev_main.o \
+	$(O)alloc.o   $(O)decl.o      $(O)drawing.o \
+	$(O)monst.o   $(O)objects.o   $(O)panic.o
+
+DGNCOMPOBJS    = $(O)dgn_yacc.o  $(O)dgn_$(LEX).o $(O)dgn_main.o \
+	$(O)alloc.o   $(O)panic.o
+
+RECOVOBJS      = $(O)recover.o
+
+TILEFILES      = $(WSHR)/monsters.txt $(WSHR)/objects.txt $(WSHR)/other.txt
+
+#
+# These are not invoked during a normal game build in 3.4
+#
+TEXT_IO        = $(O)tiletext.o  $(O)tiletxt.o   $(O)drawing.o \
+	$(O)decl.o    $(O)monst.o     $(O)objects.o
+
+TEXT_IO32      = $(O)tilete32.o $(O)tiletx32.o $(O)drawing.o \
+	$(O)decl.o    $(O)monst.o     $(O)objects.o
+
+GIFREADERS     = $(O)gifread.o   $(O)alloc.o $(O)panic.o
+GIFREADERS32   = $(O)gifrd32.o $(O)alloc.o $(O)panic.o
+
+PPMWRITERS     = $(O)ppmwrite.o $(O)alloc.o $(O)panic.o
+
+#
+#  Object files for the game itself.
+#
+
+VOBJ01 = $(O)allmain.o  $(O)alloc.o    $(O)apply.o    $(O)artifact.o
+VOBJ02 = $(O)attrib.o   $(O)ball.o     $(O)bones.o    $(O)botl.o
+VOBJ03 = $(O)cmd.o      $(O)dbridge.o  $(O)decl.o     $(O)detect.o
+VOBJ04 = $(O)dig.o      $(O)display.o  $(O)do.o       $(O)do_name.o
+VOBJ05 = $(O)do_wear.o  $(O)dog.o      $(O)dogmove.o  $(O)dokick.o
+VOBJ06 = $(O)dothrow.o  $(O)drawing.o  $(O)dungeon.o  $(O)eat.o
+VOBJ07 = $(O)end.o      $(O)engrave.o  $(O)exper.o    $(O)explode.o
+VOBJ08 = $(O)extralev.o $(O)files.o    $(O)fountain.o $(O)hack.o
+VOBJ09 = $(O)hacklib.o  $(O)invent.o   $(O)light.o    $(O)lock.o
+VOBJ10 = $(O)mail.o     $(O)makemon.o  $(O)mapglyph.o $(O)mcastu.o
+VOBJ11 = $(O)mhitm.o    $(O)mhitu.o    $(O)minion.o   $(O)mklev.o
+VOBJ12 = $(O)mkmap.o    $(O)mkmaze.o   $(O)mkobj.o    $(O)mkroom.o
+VOBJ13 = $(O)mon.o      $(O)mondata.o  $(O)monmove.o  $(O)monst.o
+VOBJ14 = $(O)monstr.o   $(O)mplayer.o  $(O)mthrowu.o  $(O)muse.o
+VOBJ15 = $(O)music.o    $(O)o_init.o   $(O)objects.o  $(O)objnam.o
+VOBJ16 = $(O)options.o  $(O)pager.o    $(O)pickup.o   $(O)pline.o
+VOBJ17 = $(O)polyself.o $(O)potion.o   $(O)pray.o     $(O)priest.o
+VOBJ18 = $(O)quest.o    $(O)questpgr.o $(RANDOM)      $(O)read.o
+VOBJ19 = $(O)rect.o     $(O)region.o   $(O)restore.o  $(O)rip.o
+VOBJ20 = $(O)rnd.o      $(O)role.o     $(O)rumors.o   $(O)save.o
+VOBJ21 = $(O)shk.o      $(O)shknam.o   $(O)sit.o      $(O)sounds.o
+VOBJ22 = $(O)sp_lev.o   $(O)spell.o    $(O)steal.o    $(O)steed.o
+VOBJ23 = $(O)teleport.o $(O)timeout.o  $(O)topten.o   $(O)track.o
+VOBJ24 = $(O)trap.o     $(O)u_init.o   $(O)uhitm.o    $(O)vault.o
+VOBJ25 = $(O)vis_tab.o  $(O)vision.o   $(O)weapon.o   $(O)were.o
+VOBJ26 = $(O)wield.o    $(O)windows.o  $(O)wizard.o   $(O)worm.o
+VOBJ27 = $(O)worn.o     $(O)write.o    $(O)zap.o
+
+DLBOBJ = $(O)dlb.o
+
+#TTYOBJ = $(O)topl.o     $(O)getline.o  $(O)wintty.o
+TTYOBJ = $(O)cursmain.o $(O)curswins.o  $(O)cursmisc.o $(O)cursdial.o \
+	$(O)cursstat.o $(O)cursinit.o $(O)cursmesg.o 
+
+SOBJ   = $(O)winnt.o    $(O)pcsys.o      $(O)pcunix.o  \
+	$(SOUND) $(O)pcmain.o $(O)mapimail.o $(O)nhlan.o
+
+OBJS   = $(VOBJ01) $(VOBJ02) $(VOBJ03) $(VOBJ04) $(VOBJ05) \
+	$(VOBJ06) $(VOBJ07) $(VOBJ08) $(VOBJ09) $(VOBJ10) \
+	$(VOBJ11) $(VOBJ12) $(VOBJ13) $(VOBJ14) $(VOBJ15) \
+	$(VOBJ16) $(VOBJ17) $(VOBJ18) $(VOBJ19) $(VOBJ20) \
+	$(VOBJ21) $(VOBJ22) $(VOBJ23) $(VOBJ24) $(VOBJ25) \
+	$(VOBJ26) $(VOBJ27)
+
+WINPOBJ = $(WINPORT)
+
+VVOBJ  = $(O)version.o
+
+ALLOBJ  = $(WINPOBJ) $(SOBJ) $(DLBOBJ)  $(TTYOBJ) $(WOBJ) $(OBJS) $(VVOBJ)
+
+ifeq "$(GRAPHICAL)" "Y"
+OPTIONS_FILE = $(DAT)/guioptions
+else
+OPTIONS_FILE = $(DAT)/ttyoptions
+endif
+
+#==========================================
+# Header file macros
+#==========================================
+
+CONFIG_H = $(INCL)/config.h $(INCL)/config1.h $(INCL)/tradstdc.h \
+	       $(INCL)/global.h $(INCL)/coord.h $(INCL)/vmsconf.h \
+	       $(INCL)/system.h $(INCL)/unixconf.h $(INCL)/os2conf.h \
+	       $(INCL)/micro.h $(INCL)/pcconf.h $(INCL)/tosconf.h \
+	       $(INCL)/amiconf.h $(INCL)/macconf.h $(INCL)/beconf.h \
+	       $(INCL)/ntconf.h $(INCL)/nhlan.h
+
+HACK_H = $(INCL)/hack.h $(CONFIG_H) $(INCL)/align.h \
+	       $(INCL)/dungeon.h $(INCL)/monsym.h $(INCL)/mkroom.h \
+	       $(INCL)/objclass.h $(INCL)/youprop.h $(INCL)/prop.h \
+	       $(INCL)/permonst.h $(INCL)/monattk.h \
+	       $(INCL)/monflag.h $(INCL)/mondata.h $(INCL)/pm.h \
+	       $(INCL)/wintype.h $(INCL)/decl.h $(INCL)/quest.h \
+	       $(INCL)/spell.h $(INCL)/color.h $(INCL)/obj.h \
+	       $(INCL)/you.h $(INCL)/attrib.h $(INCL)/monst.h \
+	       $(INCL)/skills.h $(INCL)/onames.h $(INCL)/timeout.h \
+	       $(INCL)/trap.h $(INCL)/flag.h $(INCL)/rm.h \
+	       $(INCL)/vision.h $(INCL)/display.h $(INCL)/engrave.h \
+	       $(INCL)/rect.h $(INCL)/region.h $(INCL)/winprocs.h \
+	       $(INCL)/wintty.h $(INCL)/trampoli.h
+
+LEV_H       = $(INCL)/lev.h
+DGN_FILE_H  = $(INCL)/dgn_file.h
+LEV_COMP_H  = $(INCL)/lev_comp.h
+SP_LEV_H    = $(INCL)/sp_lev.h
+TILE_H      = ../win/share/tile.h
+
+#==========================================
+# Miscellaneous
+#==========================================
+
+DATABASE = $(DAT)/data.base
+
+#
+#  The name of the game.
+#
+
+GAMEFILE = $(GAMEDIR)/$(GAME).exe
+
+
+#==========================================
+#=============== TARGETS ==================
+#==========================================
+
+# Since DOS doesn't allow / as path separator, and GCC doesn't allow \ as
+# path separator, we must change all pathnames when performing DOS commands.
+# This is done by blindly applying $(subst /,\, ...) on every command.
+# Where any command contain / for another reason (switch char, or echoing
+# comment lines to lev/dungeon files) a little more care is taken.
+
+#
+#  The default make target (so just typing 'nmake' is useful).
+#
+default : $(GAMEFILE)
+
+#
+#  The main target.
+#
+
+$(GAME) : $(O)obj.tag $(O)utility.tag graphicschk $(GAMEFILE)
+	@echo $(GAME) is up to date.
+
+#
+#  Everything
+#
+
+all :   install
+
+install: graphicschk $(GAME) $(O)install.tag
+	@echo Done.
+
+
+$(O)install.tag:  $(DAT)/data    $(DAT)/rumors    $(DAT)/dungeon \
+	       $(DAT)/oracles $(DAT)/quest.dat $(O)sp_lev.tag $(DLB)
+ifeq  "$(USE_DLB)" "Y"
+	$(subst /,\,copy nhdat                $(GAMEDIR))
+	$(subst /,\,copy $(DAT)/license       $(GAMEDIR))
+	$(subst /,\,copy $(DAT)/opthelp       $(GAMEDIR))
+else
+	$(subst /,\,copy $(DAT)/*.            $(GAMEDIR))
+	$(subst /,\,copy $(DAT)/*.dat         $(GAMEDIR))
+	$(subst /,\,copy $(DAT)/*.lev         $(GAMEDIR))
+	$(subst /,\,if exist $(GAMEDIR)/makefile del $(GAMEDIR)/makefile)
+endif
+	$(subst /,\,if exist $(DOC)/guidebook.txt copy $(DOC)/guidebook.txt $(GAMEDIR)/Guidebook.txt)
+	$(subst /,\,if exist $(DOC)/nethack.txt copy $(DOC)/nethack.txt $(GAMEDIR)/NetHack.txt)
+	$(subst /,\,copy $(NTSYS)/defaults.nh   $(GAMEDIR)/defaults.nh)
+	$(subst /,\,copy $(TTY)/Readme.txt      $(GAMEDIR)/curses-readme.txt)
+	$(subst /,\,copy $(TTY)/Todo.txt      $(GAMEDIR)/curses-todo.txt)
+	$(subst /,\,copy $(TTY)/Bugs.txt      $(GAMEDIR)/curses-bugs.txt)
+	$(subst /,\,echo install done > $@)
+
+#  copy $(NTSYS)/winnt.hlp    $(GAMEDIR)
+
+recover: $(U)recover.exe
+	$(subst /,\,if exist $(U)recover.exe copy $(U)recover.exe  $(GAMEDIR))
+	$(subst /,\,if exist $(DOC)/recover.txt copy $(DOC)/recover.txt $(GAMEDIR)/recover.txt)
+
+$(O)sp_lev.tag: $(O)utility.tag $(DAT)/bigroom.des  $(DAT)/castle.des \
+	 $(DAT)/endgame.des $(DAT)/gehennom.des $(DAT)/knox.des   \
+	 $(DAT)/medusa.des  $(DAT)/oracle.des   $(DAT)/tower.des  \
+	 $(DAT)/yendor.des  $(DAT)/arch.des     $(DAT)/barb.des   \
+	 $(DAT)/caveman.des $(DAT)/healer.des   $(DAT)/knight.des \
+	 $(DAT)/monk.des    $(DAT)/priest.des   $(DAT)/ranger.des \
+	 $(DAT)/rogue.des   $(DAT)/samurai.des  $(DAT)/sokoban.des \
+	 $(DAT)/tourist.des $(DAT)/valkyrie.des $(DAT)/wizard.des
+	$(subst /,\,$(U)lev_comp $(DAT)/bigroom.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/castle.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/endgame.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/gehennom.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/knox.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/mines.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/medusa.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/oracle.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/sokoban.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/tower.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/yendor.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/arch.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/barb.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/caveman.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/healer.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/knight.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/monk.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/priest.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/ranger.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/rogue.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/samurai.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/tourist.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/valkyrie.des)
+	$(subst /,\,$(U)lev_comp $(DAT)/wizard.des)
+	$(subst /,\,copy *.lev $(DAT))
+	$(subst /,\,del *.lev)
+	$(subst /,\,echo sp_levs done > $(O)sp_lev.tag)
+
+$(O)utility.tag: $(INCL)/date.h $(INCL)/onames.h $(INCL)/pm.h \
+	 $(SRC)/monstr.c $(SRC)/vis_tab.c $(U)lev_comp.exe $(INCL)/vis_tab.h \
+	 $(U)dgn_comp.exe $(TILEUTIL16)
+	$(subst /,\,@echo utilities made >$@)
+	@echo utilities made.
+
+tileutil: $(U)gif2txt.exe $(U)gif2tx32.exe $(U)txt2ppm.exe
+	@echo Optional tile development utilities are up to date.
+
+ifeq  "$(GRAPHICAL)" "Y"
+$(NHRES): $(TILEBMP16) $(WIN32)/winhack.rc $(WIN32)/mnsel.bmp \
+	 $(WIN32)/mnselcnt.bmp $(WIN32)/mnunsel.bmp \
+	 $(WIN32)/petmark.bmp $(WIN32)/NetHack.ico $(WIN32)/rip.bmp \
+	 $(WIN32)/splash.bmp
+	@$(rc) -o$@ --include-dir $(WIN32) -i $(WIN32)/winhack.rc
+else
+$(NHRES): $(NTSYS)/console.rc $(NTSYS)/NetHack.ico 
+	@$(rc) -o$@ --include-dir $(NTSYS) -i $(NTSYS)/console.rc
+endif
+
+#==========================================
+#  The main target.
+#==========================================
+$(O)gamedir.tag:
+	$(subst /,\,@if not exist $(GAMEDIR)/*.* echo creating directory $(GAMEDIR))
+	$(subst /,\,@if not exist $(GAMEDIR)/*.* mkdir $(GAMEDIR))
+	$(subst /,\,@echo directory created > $@)
+
+ifeq  "$(GRAPHICAL)" "Y"
+$(GAMEFILE) : $(ALLOBJ) $(NHRES) $(O)gamedir.tag
+else
+#$(GAMEFILE) : $(ALLOBJ) $(NHRES) $(O)gamedir.tag \
+#	 $(GAMEDIR)/nhdefkey.dll $(GAMEDIR)/nh340key.dll $(GAMEDIR)/nhraykey.dll
+$(GAMEFILE) : $(ALLOBJ) $(NHRES) $(O)gamedir.tag
+endif
+	@echo Linking....
+	$(link) $(lflags) -o$@ $(ALLOBJ) $(NHRES) $(WINPLIBS)
+	$(subst /,\,@if exist $(O)install.tag del $(O)install.tag)
+
+
+$(O)nhdefkey.o:
+	$(cc) $(CFLAGS) -DBUILD_DLL -o$@ $(NTSYS)/nhdefkey.c 
+
+$(GAMEDIR)/nhdefkey.dll : $(O)nhdefkey.o $(O)gamedir.tag
+	@echo Linking $@
+	$(cc) -shared -Wl,--export-all-symbols \
+		-Wl,--add-stdcall-alias -o $@ $<
+
+$(O)nh340key.o:
+	$(cc) $(CFLAGS) -DBUILD_DLL -o$@ $(NTSYS)/nh340key.c 
+
+$(GAMEDIR)/nh340key.dll : $(O)nh340key.o $(O)gamedir.tag
+	@echo Linking $@
+	$(cc) -shared -Wl,--export-all-symbols \
+		-Wl,--add-stdcall-alias -o $@ $<
+
+$(O)nhraykey.o:
+		$(cc) $(CFLAGS) -DBUILD_DLL -o$@ $(NTSYS)/nhraykey.c 
+
+$(GAMEDIR)/nhraykey.dll : $(O)nhraykey.o $(O)gamedir.tag
+	@echo Linking $@
+	$(cc) -shared -Wl,--export-all-symbols \
+		-Wl,--add-stdcall-alias -o $@ $<
+
+$(GAME)_.ico : $(NTSYS)/$(GAME).ico
+	$(subst /,\,@copy $(NTSYS)/$(GAME).ico $@)
+
+#==========================================
+# Create directory for holding object files
+#==========================================
+
+graphicschk:
+ifeq  "$(GRAPHICAL)" "Y"
+	@echo ----
+	@echo NOTE: This build will include tile support.
+	@echo ----
+endif
+	$(subst /,\,@echo graphicschk > graphicschk)
+
+#
+#  Secondary Targets.
+#
+
+#==========================================
+# Makedefs Stuff
+#==========================================
+
+$(U)makedefs.exe: $(MAKEOBJS)
+	@$(link) $(LFLAGSU) -o$@ $(MAKEOBJS)
+
+$(O)makedefs.o: $(CONFIG_H) $(INCL)/monattk.h $(INCL)/monflag.h \
+	 $(INCL)/objclass.h $(INCL)/monsym.h $(INCL)/qtext.h \
+	 $(INCL)/patchlevel.h $(U)makedefs.c $(O)obj.tag
+	$(cc) $(CFLAGSU) -o$@ $(U)makedefs.c
+
+#
+#  date.h should be remade every time any of the source or include
+#  files is modified.
+#
+
+$(INCL)/date.h $(OPTIONS_FILE): $(U)makedefs.exe
+	$(subst /,\,$(U)makedefs -v)
+
+#$(OPTIONS_FILE): $(U)makedefs.exe
+#	$(subst /,\,$(U)makedefs -v)
+
+$(INCL)/onames.h : $(U)makedefs.exe
+	$(subst /,\,$(U)makedefs -o)
+
+$(INCL)/pm.h : $(U)makedefs.exe
+	$(subst /,\,$(U)makedefs -p)
+
+#$(INCL)/trap.h : $(U)makedefs.exe
+#  $(U)makedefs -t
+
+$(SRC)/monstr.c: $(U)makedefs.exe
+	$(subst /,\,$(U)makedefs -m)
+
+$(INCL)/vis_tab.h: $(U)makedefs.exe
+	$(subst /,\,$(U)makedefs -z)
+
+$(SRC)/vis_tab.c: $(U)makedefs.exe
+	$(subst /,\,$(U)makedefs -z)
+
+#==========================================
+# uudecode utility and uuencoded targets
+#==========================================
+
+$(U)uudecode.exe: $(O)uudecode.o
+	@$(link) $(LFLAGSU) -o$@ $(O)uudecode.o
+
+$(O)uudecode.o: $(SSYS)/uudecode.c
+
+$(NTSYS)/NetHack.ico : $(U)uudecode.exe $(NTSYS)/nhico.uu
+	$(subst /,\,$(U)uudecode.exe $(NTSYS)/nhico.uu)
+	$(subst /,\,copy NetHack.ico $@)
+	del NetHack.ico
+
+$(WIN32)/NetHack.ico : $(NTSYS)/NetHack.ico
+	$(subst /,\,copy $< $@)
+
+$(WIN32)/mnsel.bmp: $(U)uudecode.exe $(WIN32)/mnsel.uu
+	$(subst /,\,$(U)uudecode.exe $(WIN32)/mnsel.uu)
+	$(subst /,\,copy mnsel.bmp $@)
+	del mnsel.bmp
+
+$(WIN32)/mnselcnt.bmp: $(U)uudecode.exe $(WIN32)/mnselcnt.uu
+	$(subst /,\,$(U)uudecode.exe $(WIN32)/mnselcnt.uu)
+	$(subst /,\,copy mnselcnt.bmp $@)
+	del mnselcnt.bmp
+
+$(WIN32)/mnunsel.bmp: $(U)uudecode.exe $(WIN32)/mnunsel.uu
+	$(subst /,\,$(U)uudecode.exe $(WIN32)/mnunsel.uu)
+	$(subst /,\,copy mnunsel.bmp $@)
+	del mnunsel.bmp
+
+$(WIN32)/petmark.bmp: $(U)uudecode.exe $(WIN32)/petmark.uu
+	$(subst /,\,$(U)uudecode.exe $(WIN32)/petmark.uu)
+	$(subst /,\,copy petmark.bmp $@)
+	del petmark.bmp
+
+$(WIN32)/rip.bmp: $(U)uudecode.exe $(WIN32)/rip.uu
+	$(subst /,\,$(U)uudecode.exe $(WIN32)/rip.uu)
+	$(subst /,\,copy rip.bmp $@)
+	del rip.bmp
+
+$(WIN32)/splash.bmp: $(U)uudecode.exe $(WIN32)/splash.uu
+	$(subst /,\,$(U)uudecode.exe $(WIN32)/splash.uu)
+	$(subst /,\,copy splash.bmp $@)
+	del splash.bmp
+
+
+#==========================================
+# Level Compiler Stuff
+#==========================================
+
+LEVCFLAGS=$(cflags) -c -DWIN32 -D_WIN32 -I../include $(cdebug) -DDLB
+
+$(U)lev_comp.exe: $(SPLEVOBJS)
+	@echo Linking $@...
+	@$(link) $(LFLAGSU) -o$@ $(SPLEVOBJS)
+
+$(O)lev_yacc.o: $(HACK_H)   $(SP_LEV_H) $(INCL)/lev_comp.h $(U)lev_yacc.c
+	$(cc) $(LEVCFLAGS) -o$@ $(U)lev_yacc.c
+
+$(O)lev_$(LEX).o: $(HACK_H)   $(INCL)/lev_comp.h $(SP_LEV_H) \
+	$(U)lev_$(LEX).c
+	$(cc) $(LEVCFLAGS) -o$@ $(U)lev_$(LEX).c
+
+$(O)lev_main.o:   $(U)lev_main.c $(HACK_H)   $(SP_LEV_H)
+	$(cc) $(LEVCFLAGS) -o$@ $(U)lev_main.c
+
+
+$(U)lev_yacc.c $(INCL)/lev_comp.h : $(U)lev_comp.y
+ifeq  "$(DO_YACC)" "YACC_ACT"
+	$(subst /,\,$(YACC) -d $(U)lev_comp.y)
+	$(subst /,\,copy $(YTABC) $(U)lev_yacc.c)
+	$(subst /,\,copy $(YTABH) $(INCL)/lev_comp.h)
+	$(subst /,\,@del $(YTABC))
+	$(subst /,\,@del $(YTABH))
+
+else
+	@echo $(U)lev_comp.y has changed.
+	@echo To update $(U)lev_yacc.c and $(INCL)/lev_comp.h run $(YACC).
+	@echo ---
+	@echo For now, we will copy the prebuilt lev_yacc.c and
+	@echo lev_comp.h from $(SSYS) into $(UTIL) and use them.
+	$(subst /,\,@copy $(SSYS)/lev_yacc.c $(U)lev_yacc.c >nul)
+	$(subst /,\,@copy $(SSYS)/lev_comp.h $(INCL)/lev_comp.h >nul)
+	$(subst /,\,echo.>>$(U)lev_yacc.c)
+	$(subst /,\,echo.>>$(INCL)/lev_comp.h)
+endif
+
+$(U)lev_$(LEX).c: $(U)lev_comp.l
+ifeq  "$(DO_LEX)" "LEX_ACT"
+	$(subst /,\,$(LEX) $(FLEXSKEL) $(U)lev_comp.l)
+	$(subst /,\,copy $(LEXYYC) $@)
+	$(subst /,\,@del $(LEXYYC))
+else
+	@echo $(U)lev_comp.l has changed. To update $@ run $(LEX).
+	@echo ---
+	@echo For now, we will copy the prebuilt lev_lex.c
+	@echo from $(SSYS) into $(UTIL) and use it.
+	$(subst /,\,@copy $(SSYS)/lev_lex.c $@ >nul)
+	$(subst /,\,echo.>>$@)
+endif
+
+#==========================================
+# Dungeon Compiler Stuff
+#==========================================
+
+$(U)dgn_comp.exe: $(DGNCOMPOBJS)
+	@echo Linking $@...
+	@$(link) $(LFLAGSU) -o$@ $(DGNCOMPOBJS)
+
+
+$(O)dgn_yacc.o:   $(HACK_H)   $(DGN_FILE_H) $(INCL)/dgn_comp.h $(U)dgn_yacc.c
+	$(cc) $(LEVCFLAGS) -o$@ $(U)dgn_yacc.c
+
+$(O)dgn_$(LEX).o: $(HACK_H)   $(DGN_FILE_H)  $(INCL)/dgn_comp.h \
+	 $(U)dgn_$(LEX).c
+	$(cc) $(LEVCFLAGS) -o$@ $(U)dgn_$(LEX).c
+
+$(O)dgn_main.o:   $(HACK_H) $(U)dgn_main.c
+	$(cc) $(LEVCFLAGS) -o$@ $(U)dgn_main.c
+
+$(U)dgn_yacc.c $(INCL)/dgn_comp.h : $(U)dgn_comp.y
+ifeq  "$(DO_YACC)" "YACC_ACT"
+	$(subst /,\,$(YACC) -d $(U)dgn_comp.y)
+	$(subst /,\,copy $(YTABC) $(U)dgn_yacc.c)
+	$(subst /,\,copy $(YTABH) $(INCL)/dgn_comp.h)
+	$(subst /,\,@del $(YTABC))
+	$(subst /,\,@del $(YTABH))
+else
+	@echo $(U)dgn_comp.y has changed. To update dgn_yacc.c and
+	@echo $(INCL)/dgn_comp.h run $(YACC).
+	@echo ---
+	@echo For now, we will copy the prebuilt $(U)dgn_yacc.c and
+	@echo dgn_comp.h from $(SSYS) into $(UTIL) and use them.
+	$(subst /,\,@copy $(SSYS)/dgn_yacc.c $(U)dgn_yacc.c >nul)
+	$(subst /,\,@copy $(SSYS)/dgn_comp.h $(INCL)/dgn_comp.h >nul)
+	$(subst /,\,echo.>>$(U)dgn_yacc.c)
+	$(subst /,\,echo.>>$(INCL)/dgn_comp.h)
+endif
+
+$(U)dgn_$(LEX).c: $(U)dgn_comp.l
+ifeq  "$(DO_LEX)" "LEX_ACT"
+	$(subst /,\,$(LEX) $(FLEXSKEL) $(U)dgn_comp.l)
+	$(subst /,\,copy $(LEXYYC) $@)
+	$(subst /,\,@del $(LEXYYC))
+else
+	@echo $(U)dgn_comp.l has changed. To update $@ run $(LEX).
+	@echo ---
+	@echo For now, we will copy the prebuilt dgn_lex.c
+	@echo from $(SSYS) into $(UTIL) and use it.
+	$(subst /,\,@copy $(SSYS)/dgn_lex.c $@ >nul)
+	$(subst /,\,echo.>>$@)
+endif
+
+#==========================================
+# Create directory for holding object files
+#==========================================
+
+$(O)obj.tag:
+	$(subst /,\,@if not exist $(OBJ)/*.* echo creating directory $(OBJ))
+	$(subst /,\,@if not exist $(OBJ)/*.* mkdir $(OBJ))
+	$(subst /,\,@echo directory created > $@)
+
+
+#==========================================
+#=========== SECONDARY TARGETS ============
+#==========================================
+
+#===========================================
+# Header files NOT distributed in ../include
+#===========================================
+
+$(INCL)/win32api.h: $(NTSYS)/win32api.h
+	$(subst /,\,copy $(NTSYS)/win32api.h $@)
+
+
+#==========================================
+# DLB utility and nhdat file creation
+#==========================================
+
+$(U)dlb_main.exe: $(DLBOBJ) $(O)dlb.o
+	@$(link) $(LFLAGSU) -o$@ $(O)dlb_main.o $(O)dlb.o $(O)alloc.o $(O)panic.o
+
+
+$(O)dlb.o:   $(O)dlb_main.o $(O)alloc.o $(O)panic.o $(INCL)/dlb.h
+	$(cc) $(CFLAGS) -o$@ $(SRC)/dlb.c
+
+$(O)dlb_main.o: $(UTIL)/dlb_main.c $(INCL)/config.h $(INCL)/dlb.h
+	$(cc) $(CFLAGS) -o$@ $(UTIL)/dlb_main.c
+
+$(DAT)/porthelp: $(NTSYS)/porthelp
+	$(subst /,\,@copy $(NTSYS)/porthelp $@ >nul)
+
+nhdat:  $(U)dlb_main.exe $(DAT)/data $(DAT)/oracles $(OPTIONS_FILE) \
+	 $(DAT)/quest.dat $(DAT)/rumors $(DAT)/help $(DAT)/hh $(DAT)/cmdhelp \
+	 $(DAT)/history $(DAT)/opthelp $(DAT)/wizhelp $(DAT)/dungeon \
+	 $(DAT)/porthelp $(DAT)/license $(O)sp_lev.tag
+	$(subst /,\,echo data >$(DAT)/dlb.lst)
+	$(subst /,\,echo oracles >>$(DAT)/dlb.lst)
+	$(subst /,\,if exist $(DAT)/options echo options >>$(DAT)/dlb.lst)
+	$(subst /,\,if exist $(DAT)/ttyoptions echo ttyoptions >>$(DAT)/dlb.lst)
+	$(subst /,\,if exist $(DAT)/guioptions echo guioptions >>$(DAT)/dlb.lst)
+	$(subst /,\,if exist $(DAT)/porthelp echo porthelp >>$(DAT)/dlb.lst)
+	$(subst /,\,echo quest.dat >>$(DAT)/dlb.lst)
+	$(subst /,\,echo rumors >>$(DAT)/dlb.lst)
+	$(subst /,\,echo help >>$(DAT)/dlb.lst)
+	$(subst /,\,echo hh >>$(DAT)/dlb.lst)
+	$(subst /,\,echo cmdhelp >>$(DAT)/dlb.lst)
+	$(subst /,\,echo history >>$(DAT)/dlb.lst)
+	$(subst /,\,echo opthelp >>$(DAT)/dlb.lst)
+	$(subst /,\,echo wizhelp >>$(DAT)/dlb.lst)
+	$(subst /,\,echo dungeon >>$(DAT)/dlb.lst)
+	$(subst /,\,echo license >>$(DAT)/dlb.lst)
+	dir /l /b /-p $(subst /,\,$(DAT)/*.lev >>$(DAT)/dlb.lst)
+	$(subst /,\,$(U)dlb_main CcIf $(DAT) dlb.lst $(SRC)/nhdat)
+
+#==========================================
+#  Recover Utility
+#==========================================
+
+$(U)recover.exe: $(RECOVOBJS)
+	$(link) $(LFLAGSU) -o$@ $(RECOVOBJS)
+
+$(O)recover.o: $(CONFIG_H) $(U)recover.c $(INCL)/win32api.h
+	$(cc) $(CFLAGSU) -o$@ $(U)recover.c
+
+#==========================================
+#  Tile Mapping
+#==========================================
+
+$(SRC)/tile.c: $(U)tilemap.exe
+	@echo A new $@ has been created
+	@$(U)tilemap
+
+$(U)tilemap.exe: $(O)tilemap.o
+	@$(link) $(LFLAGSU) -o$@ $(O)tilemap.o
+
+$(O)tilemap.o: $(WSHR)/tilemap.c $(HACK_H)
+	$(cc) $(CFLAGSU) -o$@ $(WSHR)/tilemap.c
+
+$(O)tiletx32.o: $(WSHR)/tilemap.c $(HACK_H)
+	$(cc) $(CFLAGS) -DTILETEXT -DTILE_X=32 -DTILE_Y=32 -o$@ $(WSHR)/tilemap.c
+
+$(O)tiletxt.o: $(WSHR)/tilemap.c $(HACK_H)
+	$(cc) $(CFLAGS) -DTILETEXT -o$@ $(WSHR)/tilemap.c
+
+$(O)gifread.o: $(WSHR)/gifread.c  $(CONFIG_H) $(TILE_H)
+	$(cc) $(CFLAGS) -I$(WSHR) -o$@ $(WSHR)/gifread.c
+
+$(O)gifrd32.o: $(WSHR)/gifread.c  $(CONFIG_H) $(TILE_H)
+	$(cc) $(CFLAGS) -I$(WSHR) -DTILE_X=32 -DTILE_Y=32 -o$@ $(WSHR)/gifread.c
+
+$(O)ppmwrite.o: $(WSHR)/ppmwrite.c $(CONFIG_H) $(TILE_H)
+	$(cc) $(CFLAGS) -I$(WSHR) -o$@ $(WSHR)/ppmwrite.c
+
+$(O)tiletext.o: $(WSHR)/tiletext.c  $(CONFIG_H) $(TILE_H)
+	$(cc) $(CFLAGS) -I$(WSHR) -o$@ $(WSHR)/tiletext.c
+
+$(O)tilete32.o: $(WSHR)/tiletext.c  $(CONFIG_H) $(TILE_H)
+	$(cc) $(CFLAGS) -I$(WSHR) -DTILE_X=32 -DTILE_Y=32 -o$@ $(WSHR)/tiletext.c
+
+#==========================================
+# Optional Tile Utilities
+#==========================================
+
+$(U)gif2txt.exe: $(GIFREADERS) $(TEXT_IO)
+	@echo Linking $@...
+	@$(link) $(LFLAGSU) -o$@ $(GIFREADERS) $(TEXT_IO)
+
+$(U)gif2tx32.exe: $(GIFREADERS32) $(TEXT_IO32)
+	@echo Linking $@...
+	@$(link) $(LFLAGSU) -o$@ $(GIFREADERS32) $(TEXT_IO32)
+
+
+$(U)txt2ppm.exe: $(PPMWRITERS) $(TEXT_IO)
+	@echo Linking $@...
+	@$(link) $(LFLAGSU) -o$@ $(PPMWRITERS) $(TEXT_IO)
+
+
+ifeq  "$(GRAPHICAL)" "Y"
+$(TILEBMP16): $(TILEUTIL16) $(TILEFILES)
+	@echo Creating 16x16 binary tile files (this may take some time)
+	$(subst /,\,@$(U)tile2bmp $(TILEBMP16))
+#$(TILEBMP32): $(TILEUTIL32) $(TILEFILES32)
+#	@echo Creating 32x32 binary tile files (this may take some time)
+#	$(subst /,\,@$(U)til2bm32 $(TILEBMP32))
+else
+$(TILEBMP16):
+$(TILEBMP32):
+endif
+
+$(U)tile2bmp.exe: $(O)tile2bmp.o $(TEXT_IO)
+	@echo Linking $@...
+	@$(link) $(LFLAGSU) -o$@ $(O)tile2bmp.o $(TEXT_IO)
+
+$(U)til2bm32.exe: $(O)til2bm32.o $(TEXT_IO32)
+	@echo Linking $@...
+	@$(link) $(LFLAGSU) -o$@ $(O)til2bm32.o $(TEXT_IO32)
+
+$(O)tile2bmp.o: $(WSHR)/tile2bmp.c $(HACK_H) $(TILE_H) $(INCL)/win32api.h
+	$(cc) $(CFLAGS) -I$(WSHR) -o$@ $(WSHR)/tile2bmp.c
+
+$(O)til2bm32.o: $(WSHR)/til2bm32.c $(HACK_H) $(TILE_H) $(INCL)/win32api.h
+	$(cc) $(CFLAGS) -I$(WSHR) -DTILE_X=32 -DTILE_Y=32 -o$@ $(WSHR)/til2bm32.c
+
+#==========================================
+# Housekeeping
+#==========================================
+
+spotless: clean
+	$(subst /,\,if exist graphicschk       del graphicschk)
+	$(subst /,\,if exist $(INCL)/date.h    del $(INCL)/date.h)
+	$(subst /,\,if exist $(INCL)/onames.h  del $(INCL)/onames.h)
+	$(subst /,\,if exist $(INCL)/pm.h      del $(INCL)/pm.h)
+	$(subst /,\,if exist $(INCL)/vis_tab.h del $(INCL)/vis_tab.h)
+	$(subst /,\,if exist $(SRC)/vis_tab.c  del $(SRC)/vis_tab.c)
+	$(subst /,\,if exist $(SRC)/tile.c     del $(SRC)/tile.c)
+	$(subst /,\,if exist $(U)*.lnk         del $(U)*.lnk)
+	$(subst /,\,if exist $(U)*.map         del $(U)*.map)
+	$(subst /,\,if exist $(DAT)/data       del $(DAT)/data)
+	$(subst /,\,if exist $(DAT)/rumors     del $(DAT)/rumors)
+	$(subst /,\,if exist $(DAT)/???-fil?.lev      del $(DAT)/???-fil?.lev)
+	$(subst /,\,if exist $(DAT)/???-goal.lev      del $(DAT)/???-goal.lev)
+	$(subst /,\,if exist $(DAT)/???-loca.lev      del $(DAT)/???-loca.lev)
+	$(subst /,\,if exist $(DAT)/???-strt.lev      del $(DAT)/???-strt.lev)
+	$(subst /,\,if exist $(DAT)/air.lev      del $(DAT)/air.lev)
+	$(subst /,\,if exist $(DAT)/asmodeus.lev      del $(DAT)/asmodeus.lev)
+	$(subst /,\,if exist $(DAT)/astral.lev   del $(DAT)/astral.lev)
+	$(subst /,\,if exist $(DAT)/baalz.lev    del $(DAT)/baalz.lev)
+	$(subst /,\,if exist $(DAT)/bigrm-*.lev  del $(DAT)/bigrm-*.lev)
+	$(subst /,\,if exist $(DAT)/castle.lev   del $(DAT)/castle.lev)
+	$(subst /,\,if exist $(DAT)/data    del $(DAT)/data)
+	$(subst /,\,if exist $(DAT)/dungeon      del $(DAT)/dungeon)
+	$(subst /,\,if exist $(DAT)/dungeon.pdf  del $(DAT)/dungeon.pdf)
+	$(subst /,\,if exist $(DAT)/earth.lev    del $(DAT)/earth.lev)
+	$(subst /,\,if exist $(DAT)/fakewiz?.lev      del $(DAT)/fakewiz?.lev)
+	$(subst /,\,if exist $(DAT)/fire.lev     del $(DAT)/fire.lev)
+	$(subst /,\,if exist $(DAT)/juiblex.lev  del $(DAT)/juiblex.lev)
+	$(subst /,\,if exist $(DAT)/knox.lev     del $(DAT)/knox.lev)
+	$(subst /,\,if exist $(DAT)/medusa-?.lev      del $(DAT)/medusa-?.lev)
+	$(subst /,\,if exist $(DAT)/mine*.lev    del $(DAT)/mine*.lev)
+	$(subst /,\,if exist $(DAT)/options      del $(DAT)/options)
+	$(subst /,\,if exist $(DAT)/ttyoptions   del $(DAT)/ttyoptions)
+	$(subst /,\,if exist $(DAT)/guioptions   del $(DAT)/guioptions)
+	$(subst /,\,if exist $(DAT)/oracle.lev   del $(DAT)/oracle.lev)
+	$(subst /,\,if exist $(DAT)/oracles      del $(DAT)/oracles)
+	$(subst /,\,if exist $(DAT)/orcus.lev    del $(DAT)/orcus.lev)
+	$(subst /,\,if exist $(DAT)/rumors  del $(DAT)/rumors)
+	$(subst /,\,if exist $(DAT)/quest.dat    del $(DAT)/quest.dat)
+	$(subst /,\,if exist $(DAT)/sanctum.lev  del $(DAT)/sanctum.lev)
+	$(subst /,\,if exist $(DAT)/soko?-?.lev  del $(DAT)/soko?-?.lev)
+	$(subst /,\,if exist $(DAT)/tower?.lev   del $(DAT)/tower?.lev)
+	$(subst /,\,if exist $(DAT)/valley.lev   del $(DAT)/valley.lev)
+	$(subst /,\,if exist $(DAT)/water.lev    del $(DAT)/water.lev)
+	$(subst /,\,if exist $(DAT)/wizard?.lev  del $(DAT)/wizard?.lev)
+	$(subst /,\,if exist $(O)sp_lev.tag     del $(O)sp_lev.tag)
+	$(subst /,\,if exist $(SRC)/monstr.c    del $(SRC)/monstr.c)
+	$(subst /,\,if exist $(SRC)/vis_tab.c   del $(SRC)/vis_tab.c)
+	$(subst /,\,if exist $(U)recover.exe    del $(U)recover.exe)
+	$(subst /,\,if exist $(DAT)/dlb.lst      del $(DAT)/dlb.lst)
+	$(subst /,\,if exist nhdat.         del nhdat.)
+	$(subst /,\,if exist $(O)install.tag    del $(O)install.tag)
+	$(subst /,\,if exist $(O)obj.tag    del $(O)obj.tag)
+	$(subst /,\,if exist $(O)gamedir.tag    del $(O)gamedir.tag)
+ifneq "$(OBJ)" ""
+	$(subst /,\,rmdir $(OBJ)) /s /Q
+endif
+
+clean:
+	$(subst /,\,if exist $(O)*.o del $(O)*.o)
+	$(subst /,\,if exist $(O)utility.tag   del $(O)utility.tag)
+	$(subst /,\,if exist $(U)makedefs.exe  del $(U)makedefs.exe)
+	$(subst /,\,if exist $(U)lev_comp.exe  del $(U)lev_comp.exe)
+	$(subst /,\,if exist $(U)dgn_comp.exe  del $(U)dgn_comp.exe)
+	$(subst /,\,if exist $(SRC)/*.lnk      del $(SRC)/*.lnk)
+	$(subst /,\,if exist $(SRC)/*.map      del $(SRC)/*.map)
+	$(subst /,\,if exist $(TILEBMP16)      del $(TILEBMP16))
+	$(subst /,\,if exist $(TILEBMP32)      del $(TILEBMP32))
+
+#===================================================================
+# OTHER DEPENDENCIES
+#===================================================================
+
+#
+# dat dependencies
+#
+
+$(DAT)/data: $(O)utility.tag    $(DATABASE)
+	$(subst /,\,$(U)makedefs -d)
+
+$(DAT)/rumors: $(O)utility.tag    $(DAT)/rumors.tru   $(DAT)/rumors.fal
+	$(subst /,\,$(U)makedefs -r)
+
+$(DAT)/quest.dat: $(O)utility.tag  $(DAT)/quest.txt
+	$(subst /,\,$(U)makedefs -q)
+
+$(DAT)/oracles: $(O)utility.tag    $(DAT)/oracles.txt
+	$(subst /,\,$(U)makedefs -h)
+
+$(DAT)/dungeon: $(O)utility.tag  $(DAT)/dungeon.def
+	$(subst /,\,$(U)makedefs -e)
+	$(subst /,\,$(U)dgn_comp $(DAT)/dungeon.pdf)
+
+#
+# NT dependencies
+#
+
+$(O)nttty.o:   $(HACK_H) $(TILE_H) $(INCL)/win32api.h $(NTSYS)/nttty.c
+	$(cc) $(CFLAGS) -I$(WSHR) -o$@  $(NTSYS)/nttty.c
+$(O)winnt.o: $(HACK_H) $(INCL)/win32api.h $(NTSYS)/winnt.c
+	$(cc) $(CFLAGS) -o$@  $(NTSYS)/winnt.c
+$(O)ntsound.o: $(HACK_H) $(NTSYS)/ntsound.c
+	$(cc) $(CFLAGS)  -o$@ $(NTSYS)/ntsound.c
+$(O)mapimail.o: $(HACK_H) $(INCL)/nhlan.h $(NTSYS)/mapimail.c
+	$(cc) $(CFLAGS) -DMAPI_VERBOSE  -o$@ $(NTSYS)/mapimail.c
+
+#
+# util dependencies
+#
+
+$(O)panic.o:  $(U)panic.c $(CONFIG_H)
+	$(cc) $(CFLAGS) -o$@ $(U)panic.c
+
+#
+# The rest are stolen from sys/unix/Makefile.src,
+# with the following changes:
+#   * ../include changed to $(INCL)
+#   * -c (which is included in CFLAGS) substituted
+#	with -o$@
+#   * targets prefixed with $(O)
+#   * $(CC) changed to $(cc)
+# but otherwise untouched. 
+# That means that there is some irrelevant stuff
+# in here, but maintenance should be easier.
+#
+$(O)tos.o: ../sys/atari/tos.c $(HACK_H) $(INCL)/tcap.h
+	$(cc) $(CFLAGS) -o$@ ../sys/atari/tos.c
+$(O)pcmain.o: ../sys/share/pcmain.c $(HACK_H) $(INCL)/dlb.h \
+		$(INCL)/win32api.h
+	$(cc) $(CFLAGS) -o$@ ../sys/share/pcmain.c
+$(O)pcsys.o: ../sys/share/pcsys.c $(HACK_H)
+	$(cc) $(CFLAGS) -o$@ ../sys/share/pcsys.c
+$(O)pctty.o: ../sys/share/pctty.c $(HACK_H)
+	$(cc) $(CFLAGS) -o$@ ../sys/share/pctty.c
+$(O)pcunix.o: ../sys/share/pcunix.c $(HACK_H)
+	$(cc) $(CFLAGS) -o$@ ../sys/share/pcunix.c
+$(O)random.o: ../sys/share/random.c $(HACK_H)
+	$(cc) $(CFLAGS) -o$@ ../sys/share/random.c
+$(O)ioctl.o: ../sys/share/ioctl.c $(HACK_H) $(INCL)/tcap.h
+	$(cc) $(CFLAGS) -o$@ ../sys/share/ioctl.c
+$(O)unixtty.o: ../sys/share/unixtty.c $(HACK_H)
+	$(cc) $(CFLAGS) -o$@ ../sys/share/unixtty.c
+$(O)unixmain.o: ../sys/unix/unixmain.c $(HACK_H) $(INCL)/dlb.h
+	$(cc) $(CFLAGS) -o$@ ../sys/unix/unixmain.c
+$(O)unixunix.o: ../sys/unix/unixunix.c $(HACK_H)
+	$(cc) $(CFLAGS) -o$@ ../sys/unix/unixunix.c
+$(O)unixres.o: ../sys/unix/unixres.c $(CONFIG_H)
+	$(cc) $(CFLAGS) -o$@ ../sys/unix/unixres.c
+$(O)bemain.o: ../sys/be/bemain.c $(HACK_H) $(INCL)/dlb.h
+	$(cc) $(CFLAGS) -o$@ ../sys/be/bemain.c
+$(O)getline.o: ../win/tty/getline.c $(HACK_H) $(INCL)/func_tab.h
+	$(cc) $(CFLAGS) -o$@ ../win/tty/getline.c
+$(O)termcap.o: ../win/tty/termcap.c $(HACK_H) $(INCL)/tcap.h
+	$(cc) $(CFLAGS) -o$@ ../win/tty/termcap.c
+$(O)topl.o: ../win/tty/topl.c $(HACK_H) $(INCL)/tcap.h
+	$(cc) $(CFLAGS) -o$@ ../win/tty/topl.c
+$(O)wintty.o: ../win/tty/wintty.c $(HACK_H) $(INCL)/dlb.h \
+		$(INCL)/patchlevel.h $(INCL)/tcap.h
+	$(cc) $(CFLAGS) -o$@ ../win/tty/wintty.c
+$(O)Window.o: ../win/X11/Window.c $(INCL)/xwindowp.h $(INCL)/xwindow.h \
+		$(CONFIG_H)
+	$(cc) $(CFLAGS) -o$@ ../win/X11/Window.c
+$(O)dialogs.o: ../win/X11/dialogs.c $(CONFIG_H)
+	$(cc) $(CFLAGS) -o$@ ../win/X11/dialogs.c
+$(O)winX.o: ../win/X11/winX.c $(HACK_H) $(INCL)/winX.h $(INCL)/dlb.h \
+		$(INCL)/patchlevel.h ../win/X11/nh72icon \
+		../win/X11/nh56icon ../win/X11/nh32icon
+	$(cc) $(CFLAGS) -o$@ ../win/X11/winX.c
+$(O)winmap.o: ../win/X11/winmap.c $(INCL)/xwindow.h $(HACK_H) $(INCL)/dlb.h \
+		$(INCL)/winX.h $(INCL)/tile2x11.h
+	$(cc) $(CFLAGS) -o$@ ../win/X11/winmap.c
+$(O)winmenu.o: ../win/X11/winmenu.c $(HACK_H) $(INCL)/winX.h
+	$(cc) $(CFLAGS) -o$@ ../win/X11/winmenu.c
+$(O)winmesg.o: ../win/X11/winmesg.c $(INCL)/xwindow.h $(HACK_H) $(INCL)/winX.h
+	$(cc) $(CFLAGS) -o$@ ../win/X11/winmesg.c
+$(O)winmisc.o: ../win/X11/winmisc.c $(HACK_H) $(INCL)/func_tab.h \
+		$(INCL)/winX.h
+	$(cc) $(CFLAGS) -o$@ ../win/X11/winmisc.c
+$(O)winstat.o: ../win/X11/winstat.c $(HACK_H) $(INCL)/winX.h
+	$(cc) $(CFLAGS) -o$@ ../win/X11/winstat.c
+$(O)wintext.o: ../win/X11/wintext.c $(HACK_H) $(INCL)/winX.h $(INCL)/xwindow.h
+	$(cc) $(CFLAGS) -o$@ ../win/X11/wintext.c
+$(O)winval.o: ../win/X11/winval.c $(HACK_H) $(INCL)/winX.h
+	$(cc) $(CFLAGS) -o$@ ../win/X11/winval.c
+$(O)tile.o: tile.c $(HACK_H)
+$(O)gnaskstr.o: ../win/gnome/gnaskstr.c ../win/gnome/gnaskstr.h \
+		../win/gnome/gnmain.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnaskstr.c
+$(O)gnbind.o: ../win/gnome/gnbind.c ../win/gnome/gnbind.h ../win/gnome/gnmain.h \
+		../win/gnome/gnaskstr.h ../win/gnome/gnyesno.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnbind.c
+$(O)gnglyph.o: ../win/gnome/gnglyph.c ../win/gnome/gnglyph.h $(INCL)/tile2x11.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnglyph.c
+$(O)gnmain.o: ../win/gnome/gnmain.c ../win/gnome/gnmain.h ../win/gnome/gnsignal.h \
+		../win/gnome/gnbind.h ../win/gnome/gnopts.h $(HACK_H) \
+		$(INCL)/date.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnmain.c
+$(O)gnmap.o: ../win/gnome/gnmap.c ../win/gnome/gnmap.h ../win/gnome/gnglyph.h \
+		../win/gnome/gnsignal.h $(HACK_H)
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnmap.c
+$(O)gnmenu.o: ../win/gnome/gnmenu.c ../win/gnome/gnmenu.h ../win/gnome/gnmain.h \
+		../win/gnome/gnbind.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnmenu.c
+$(O)gnmesg.o: ../win/gnome/gnmesg.c ../win/gnome/gnmesg.h ../win/gnome/gnsignal.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnmesg.c
+$(O)gnopts.o: ../win/gnome/gnopts.c ../win/gnome/gnopts.h ../win/gnome/gnglyph.h \
+		../win/gnome/gnmain.h ../win/gnome/gnmap.h $(HACK_H)
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnopts.c
+$(O)gnplayer.o: ../win/gnome/gnplayer.c ../win/gnome/gnplayer.h \
+		../win/gnome/gnmain.h $(HACK_H)
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnplayer.c
+$(O)gnsignal.o: ../win/gnome/gnsignal.c ../win/gnome/gnsignal.h \
+		../win/gnome/gnmain.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnsignal.c
+$(O)gnstatus.o: ../win/gnome/gnstatus.c ../win/gnome/gnstatus.h \
+		../win/gnome/gnsignal.h ../win/gnome/gn_xpms.h \
+		../win/gnome/gnomeprv.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnstatus.c
+$(O)gntext.o: ../win/gnome/gntext.c ../win/gnome/gntext.h ../win/gnome/gnmain.h \
+		../win/gnome/gn_rip.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gntext.c
+$(O)gnworn.o: ../win/gnome/gnworn.c ../win/gnome/gnworn.h ../win/gnome/gnglyph.h \
+		../win/gnome/gnsignal.h ../win/gnome/gnomeprv.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnworn.c
+$(O)gnyesno.o: ../win/gnome/gnyesno.c ../win/gnome/gnbind.h ../win/gnome/gnyesno.h
+	$(cc) $(CFLAGS) $(GNOMEINC) -o$@ ../win/gnome/gnyesno.c
+$(O)wingem.o: ../win/gem/wingem.c $(HACK_H) $(INCL)/func_tab.h $(INCL)/dlb.h \
+		$(INCL)/patchlevel.h $(INCL)/wingem.h
+	$(cc) $(CFLAGS) -o$@ ../win/gem/wingem.c
+$(O)wingem1.o: ../win/gem/wingem1.c $(INCL)/gem_rsc.h $(INCL)/load_img.h \
+		$(INCL)/gr_rect.h $(INCL)/wintype.h $(INCL)/wingem.h
+	$(cc) $(CFLAGS) -o$@ ../win/gem/wingem1.c
+$(O)load_img.o: ../win/gem/load_img.c $(INCL)/load_img.h
+	$(cc) $(CFLAGS) -o$@ ../win/gem/load_img.c
+$(O)gr_rect.o: ../win/gem/gr_rect.c $(INCL)/gr_rect.h
+	$(cc) $(CFLAGS) -o$@ ../win/gem/gr_rect.c
+$(O)tile.o: tile.c $(HACK_H)
+$(O)qt_win.o: ../win/Qt/qt_win.cpp $(HACK_H) $(INCL)/func_tab.h \
+		$(INCL)/dlb.h $(INCL)/patchlevel.h $(INCL)/tile2x11.h \
+		$(INCL)/qt_win.h $(INCL)/qt_clust.h $(INCL)/qt_kde0.h \
+		$(INCL)/qt_xpms.h qt_win.moc qt_kde0.moc qttableview.moc
+	$(CXX) $(CXXFLAGS) -o$@ ../win/Qt/qt_win.cpp
+$(O)qt_clust.o: ../win/Qt/qt_clust.cpp $(INCL)/qt_clust.h
+	$(CXX) $(CXXFLAGS) -o$@ ../win/Qt/qt_clust.cpp
+$(O)qttableview.o: ../win/Qt/qttableview.cpp $(INCL)/qttableview.h
+	$(CXX) $(CXXFLAGS) -o$@ ../win/Qt/qttableview.cpp
+$(O)monstr.o: monstr.c $(CONFIG_H)
+$(O)vis_tab.o: vis_tab.c $(CONFIG_H) $(INCL)/vis_tab.h
+$(O)allmain.o: allmain.c $(HACK_H)
+$(O)alloc.o: alloc.c $(CONFIG_H)
+$(O)apply.o: apply.c $(HACK_H) $(INCL)/edog.h
+$(O)artifact.o: artifact.c $(HACK_H) $(INCL)/artifact.h $(INCL)/artilist.h
+$(O)attrib.o: attrib.c $(HACK_H)
+$(O)ball.o: ball.c $(HACK_H)
+$(O)bones.o: bones.c $(HACK_H) $(INCL)/lev.h
+$(O)botl.o: botl.c $(HACK_H)
+$(O)cmd.o: cmd.c $(HACK_H) $(INCL)/func_tab.h
+$(O)dbridge.o: dbridge.c $(HACK_H)
+$(O)decl.o: decl.c $(HACK_H)
+$(O)detect.o: detect.c $(HACK_H) $(INCL)/artifact.h
+$(O)dig.o: dig.c $(HACK_H) $(INCL)/edog.h
+$(O)display.o: display.c $(HACK_H)
+$(O)dlb.o: dlb.c $(CONFIG_H) $(INCL)/dlb.h
+$(O)do.o: do.c $(HACK_H) $(INCL)/lev.h
+$(O)do_name.o: do_name.c $(HACK_H)
+$(O)do_wear.o: do_wear.c $(HACK_H)
+$(O)dog.o: dog.c $(HACK_H) $(INCL)/edog.h
+$(O)dogmove.o: dogmove.c $(HACK_H) $(INCL)/mfndpos.h $(INCL)/edog.h
+$(O)dokick.o: dokick.c $(HACK_H) $(INCL)/eshk.h
+$(O)dothrow.o: dothrow.c $(HACK_H) $(INCL)/edog.h
+$(O)drawing.o: drawing.c $(HACK_H) $(INCL)/tcap.h
+$(O)dungeon.o: dungeon.c $(HACK_H) $(INCL)/dgn_file.h $(INCL)/dlb.h
+$(O)eat.o: eat.c $(HACK_H)
+$(O)end.o: end.c $(HACK_H) $(INCL)/eshk.h $(INCL)/dlb.h
+$(O)engrave.o: engrave.c $(HACK_H) $(INCL)/lev.h
+$(O)exper.o: exper.c $(HACK_H)
+$(O)explode.o: explode.c $(HACK_H)
+$(O)extralev.o: extralev.c $(HACK_H)
+$(O)files.o: files.c $(HACK_H) $(INCL)/dlb.h
+$(O)fountain.o: fountain.c $(HACK_H)
+$(O)hack.o: hack.c $(HACK_H)
+$(O)hacklib.o: hacklib.c $(HACK_H)
+$(O)invent.o: invent.c $(HACK_H)
+$(O)light.o: light.c $(HACK_H) $(INCL)/lev.h
+$(O)lock.o: lock.c $(HACK_H)
+$(O)mail.o: mail.c $(HACK_H) $(INCL)/mail.h
+$(O)makemon.o: makemon.c $(HACK_H) $(INCL)/epri.h $(INCL)/emin.h \
+		$(INCL)/edog.h
+$(O)mapglyph.o: mapglyph.c $(HACK_H)
+$(O)mcastu.o: mcastu.c $(HACK_H)
+$(O)mhitm.o: mhitm.c $(HACK_H) $(INCL)/artifact.h $(INCL)/edog.h
+$(O)mhitu.o: mhitu.c $(HACK_H) $(INCL)/artifact.h $(INCL)/edog.h
+$(O)minion.o: minion.c $(HACK_H) $(INCL)/emin.h $(INCL)/epri.h
+$(O)mklev.o: mklev.c $(HACK_H)
+$(O)mkmap.o: mkmap.c $(HACK_H) $(INCL)/sp_lev.h
+$(O)mkmaze.o: mkmaze.c $(HACK_H) $(INCL)/sp_lev.h $(INCL)/lev.h
+$(O)mkobj.o: mkobj.c $(HACK_H)
+$(O)mkroom.o: mkroom.c $(HACK_H)
+$(O)mon.o: mon.c $(HACK_H) $(INCL)/mfndpos.h $(INCL)/edog.h
+$(O)mondata.o: mondata.c $(HACK_H) $(INCL)/eshk.h $(INCL)/epri.h
+$(O)monmove.o: monmove.c $(HACK_H) $(INCL)/mfndpos.h $(INCL)/artifact.h \
+		$(INCL)/epri.h
+$(O)monst.o: monst.c $(CONFIG_H) $(INCL)/permonst.h $(INCL)/align.h \
+		$(INCL)/monattk.h $(INCL)/monflag.h $(INCL)/monsym.h \
+		$(INCL)/dungeon.h $(INCL)/eshk.h $(INCL)/vault.h \
+		$(INCL)/epri.h $(INCL)/color.h
+$(O)mplayer.o: mplayer.c $(HACK_H)
+$(O)mthrowu.o: mthrowu.c $(HACK_H)
+$(O)muse.o: muse.c $(HACK_H) $(INCL)/edog.h
+$(O)music.o: music.c $(HACK_H) #interp.c
+$(O)o_init.o: o_init.c $(HACK_H) $(INCL)/lev.h
+$(O)objects.o: objects.c $(CONFIG_H) $(INCL)/obj.h $(INCL)/objclass.h \
+		$(INCL)/prop.h $(INCL)/skills.h $(INCL)/color.h
+$(O)objnam.o: objnam.c $(HACK_H)
+$(O)options.o: options.c $(CONFIG_H) $(INCL)/objclass.h $(INCL)/flag.h \
+		$(HACK_H) $(INCL)/tcap.h
+$(O)pager.o: pager.c $(HACK_H) $(INCL)/dlb.h
+$(O)pickup.o: pickup.c $(HACK_H)
+$(O)pline.o: pline.c $(HACK_H) $(INCL)/epri.h $(INCL)/edog.h
+$(O)polyself.o: polyself.c $(HACK_H)
+$(O)potion.o: potion.c $(HACK_H)
+$(O)pray.o: pray.c $(HACK_H) $(INCL)/epri.h
+$(O)priest.o: priest.c $(HACK_H) $(INCL)/mfndpos.h $(INCL)/eshk.h \
+		$(INCL)/epri.h $(INCL)/emin.h
+$(O)quest.o: quest.c $(HACK_H) $(INCL)/qtext.h
+$(O)questpgr.o: questpgr.c $(HACK_H) $(INCL)/dlb.h $(INCL)/qtext.h
+$(O)read.o: read.c $(HACK_H)
+$(O)rect.o: rect.c $(HACK_H)
+$(O)region.o: region.c $(HACK_H) $(INCL)/lev.h
+$(O)restore.o: restore.c $(HACK_H) $(INCL)/lev.h $(INCL)/tcap.h
+$(O)rip.o: rip.c $(HACK_H)
+$(O)rnd.o: rnd.c $(HACK_H)
+$(O)role.o: role.c $(HACK_H)
+$(O)rumors.o: rumors.c $(HACK_H) $(INCL)/lev.h $(INCL)/dlb.h
+$(O)save.o: save.c $(HACK_H) $(INCL)/lev.h
+$(O)shk.o: shk.c $(HACK_H) $(INCL)/eshk.h
+$(O)shknam.o: shknam.c $(HACK_H) $(INCL)/eshk.h
+$(O)sit.o: sit.c $(HACK_H) $(INCL)/artifact.h
+$(O)sounds.o: sounds.c $(HACK_H) $(INCL)/edog.h
+$(O)sp_lev.o: sp_lev.c $(HACK_H) $(INCL)/dlb.h $(INCL)/sp_lev.h
+$(O)spell.o: spell.c $(HACK_H)
+$(O)steal.o: steal.c $(HACK_H)
+$(O)steed.o: steed.c $(HACK_H)
+$(O)teleport.o: teleport.c $(HACK_H)
+$(O)timeout.o: timeout.c $(HACK_H) $(INCL)/lev.h
+$(O)topten.o: topten.c $(HACK_H) $(INCL)/dlb.h $(INCL)/patchlevel.h
+$(O)track.o: track.c $(HACK_H)
+$(O)trap.o: trap.c $(HACK_H)
+$(O)u_init.o: u_init.c $(HACK_H)
+$(O)uhitm.o: uhitm.c $(HACK_H)
+$(O)vault.o: vault.c $(HACK_H) $(INCL)/vault.h
+$(O)version.o: version.c $(HACK_H) $(INCL)/date.h $(INCL)/patchlevel.h
diff -burN '--exclude=.svn' nethack-orig/sys/winnt/defaults.nh nethack-3.4.3/sys/winnt/defaults.nh
--- nethack-orig/sys/winnt/defaults.nh	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/sys/winnt/defaults.nh	2010-12-17 14:01:02.708525001 -0500
@@ -11,7 +11,16 @@
 #
 # Use the IBM character set rather than just plain ascii characters
 # for tty window-port.
+#
+# This also works for the curses interface compiled with the PDCurses-SDL
+# library.
+#
 OPTIONS=IBMGraphics
+#
+# cursesgraphics may be set for the curses interface if the IBMGraphics
+# option above doesn't work with your curses implementation.
+#
+#OPTIONS=cursesgraphics
 
 # Keyboard handling
 # Different keyboard handlers can be loaded.
@@ -22,6 +31,53 @@
 # NetHack 3.4.0 keyboard handling
 # OPTIONS=altkeyhandler:nh340key.dll
 
+# *** Curses Options ***
+#
+# Use this if the binary was compiled with multiple window interfaces,
+# and curses is not the default
+OPTIONS=windowtype:curses
+#
+# Optionally specify the alignment of the message and status windows
+# relative to the map window.  If not specified, the code will default
+# to the locations used in the tty interface: message window on top,
+# and status window on bottom.  Placing either of these on the right or
+# left really only works well for winder terminal windows.
+OPTIONS=align_message:bottom,align_status:right
+#
+# Use a small popup "window" for short prompts, e.g. "Really save?".
+# If this is not set, the message window will be used for these as is
+# done for the tty interface.
+OPTIONS=popup_dialog
+#
+# Specify the initial window size for NetHack in units of characters.
+# This is supported on PDCurses for SDL as well as PDCurses for
+# Windows.
+OPTIONS=term_cols:110,term_rows:32
+#
+# Controls the usage of window borders for the main NetHack windows
+# (message, map, and status windows).  A value of 1 forces the borders
+# to be drawn, a value of 2 forces them to be off, and a value of 3
+# allows the code to decide if they should be drawn based on the size
+# of the terminal window.
+OPTIONS=windowborders:3
+#
+# Whether or not to display a fancy ascii-graphics splash screen on
+# startup.
+OPTIONS=splash_screen
+#
+# This controls what text attributes are used to highlight any pets.
+# Any combination of single letters representing each text attribute
+# may be used.  Not all attributes work on all terminals.
+#
+# Attributes may be one or more of: Bold, Inverse, Underline, blinK,
+# iTalic, Rightline, or Leftline.  The default is underline.
+OPTIONS=petattr:u
+#
+# Controls whether color and attributes are used for menu headers,
+# window borders, message text, etc.  This is separate from the color
+# option, which only controls the color of the map itself.
+OPTIONS=guicolor
+
 # *** Personal Preferences ***
 # Some options to set personal preferences.  Uncomment and change these to
 # suit your personal preference.  If several people are to use the same
@@ -30,19 +86,65 @@
 #OPTIONS=name:Janet,role:Valkyrie,race:Human,gender:female,align:lawful
 #OPTIONS=dogname:Fido,catname:Morris,fruit:guava
 #OPTIONS=horsename:Silver
-#OPTIONS=autopickup,pickup_types:$"=/!?+
+#OPTIONS=autopickup,pickup_types:$
 #OPTIONS=packorder:")[%?+/=!(*0_`
 #OPTIONS=scores:10 top/2 around/own
 #OPTIONS=nolegacy,noverbose
 #OPTIONS=menustyle:traditional
 
 #
+# *** Menucolors Configuration ***
+# Highlight menu items as defined below.  This is useful e.g. to
+# see what items are blessed and cursed at a quick glance.
+# A sample configuration is given below.  See README.menucolor
+# for more details
+OPTIONS=menucolors
+MENUCOLOR="* blessed *"=white
+MENUCOLOR="* holy *"=yellow
+MENUCOLOR="* cursed *"=black&bold
+MENUCOLOR="* unholy *"=red
+MENUCOLOR="* cursed * (being worn)"=red
+MENUCOLOR="* cursed * (weapon in hand"=red
+MENUCOLOR="* cursed * (wielded)"=red
+
+#
+# *** Statuscolors Configuration ***
+# Highlight status line items as defined below.  This is handy to
+# track hit points to see when you are running low, or make dangerous
+# conditions like foodpoisining stand out more.
+# The curses interface already does highlighting to show when something
+# on the status line has gone up or down.  Items configured below
+# override this behavior, but the remaining status line items (e.g.
+# stats) still highlight when changed as normal.
+# A sample configuration is given below.  See README.statuscolor
+# for more details:
+OPTIONS=statuscolors
+# HP
+STATUSCOLOR=hp%100:green,hp%66:yellow,hp%33:red
+STATUSCOLOR=hp%15:red&inverse,hp%5:orange&inverse
+# Pw
+STATUSCOLOR=pw%100:green,pw%66:yellow,pw%33:red
+# Carry
+STATUSCOLOR=burdened:yellow,stressed:red,strained:red&inverse
+STATUSCOLOR=overtaxed:orange,overloaded:orange&inverse
+# Hunger
+STATUSCOLOR=satiated:green,hungry:yellow,weak:red
+STATUSCOLOR=fainting:red&inverse,fainted:orange&inverse
+# Mental
+STATUSCOLOR=hallu:yellow,conf:cyan,stun:red
+# Health
+STATUSCOLOR=ill:orange&inverse,foodpois:orange&inverse
+STATUSCOLOR=slime:lightgreen&inverse
+# Other
+STATUSCOLOR=held:red&inverse,blind:red
+
+#
 # General options.  You might also set "silent" so as not to attract
 # the boss's attention.
 #
 # number_pad option can have an optional value of 0 (off), 1 (on), 
 # or 2(on,legacy-mode) which causes 5='g', alt-5='G', alt-0='I'
-OPTIONS=time,noshowexp,number_pad:2,lit_corridor
+OPTIONS=!time,noshowexp,number_pad:1,lit_corridor,topten
 #
 # If you want to get rid of "use #quit to quit..." use:
 OPTIONS=suppress_alert:3.3.1
@@ -60,22 +162,22 @@
 # possible map_mode options include: tiles|ascii4x6|ascii6x8|ascii8x8|ascii16x8|
 #                                    ascii7x12|ascii8x12|ascii16x12|ascii12x16|
 #                                    ascii10x18|fit_to_screen
-OPTIONS=map_mode:tiles,scroll_margin:5
+# OPTIONS=map_mode:tiles,scroll_margin:5
 
 # Message window settings
-OPTIONS=font_message:Arial,font_size_message:9,align_message:top
+# OPTIONS=font_message:Arial,font_size_message:9,align_message:top
 
 # Menu settings
-OPTIONS=font_menu:Arial,font_size_menu:9
+#OPTIONS=font_menu:Arial,font_size_menu:9
 
 # Text settings
-OPTIONS=font_text:Courier New,font_size_text:9
+# OPTIONS=font_text:Courier New,font_size_text:9
 
 # Status window settings
-OPTIONS=font_status:Courier New,font_size_status:9
+# OPTIONS=font_status:Courier New,font_size_status:9
 
 # Other
-OPTIONS=hilite_pet,!toptenwin
+OPTIONS=hilite_pet
 #OPTIONS=!splash_screen,player_selection:prompts
 
 # Status/message window colors
@@ -182,4 +284,3 @@
 #          048 035 064 042                         \
 #          047 045 092 058 058 092 045 047         \
 #          047 045 092 058 032 058 092 045 047
-
diff -burN '--exclude=.svn' nethack-orig/sys/winnt/nhsetup.bat nethack-3.4.3/sys/winnt/nhsetup.bat
--- nethack-orig/sys/winnt/nhsetup.bat	2003-12-07 18:40:26.000000000 -0500
+++ nethack-3.4.3/sys/winnt/nhsetup.bat	2010-12-17 14:01:02.688525001 -0500
@@ -52,6 +52,17 @@
 copy Makefile.gcc ..\..\src\Makefile.gcc >nul
 echo MinGW Makefile copied ok.
 
+echo Copying MinGW Makefile for curses - cursmake.gcc to ..\..\src\cursmake.gcc
+if NOT exist ..\..\src\cursmake.gcc goto :docurs
+copy ..\..\src\cursmake.gcc ..\..\src\cursmake.gcc-orig >nul
+echo      Your existing
+echo           ..\..\src\cursmake.gcc
+echo      has been renamed to
+echo           ..\..\src\cursmake.gcc-orig
+:docurs
+copy cursmake.gcc ..\..\src\cursmake.gcc >nul
+echo MinGW Makefile for curses copied ok.
+
 :do_win
 if not exist ..\..\win\win32\nethack.dsw goto :err_win
 echo.
diff -burN '--exclude=.svn' nethack-orig/util/makedefs.c nethack-3.4.3/util/makedefs.c
--- nethack-orig/util/makedefs.c	2003-12-07 18:39:13.000000000 -0500
+++ nethack-3.4.3/util/makedefs.c	2010-12-17 14:01:01.058525001 -0500
@@ -782,6 +782,9 @@
 #ifdef TTY_GRAPHICS
 		"traditional tty-based graphics",
 #endif
+#ifdef CURSES_GRAPHICS
+        "curses",
+#endif
 #ifdef X11_GRAPHICS
 		"X11",
 #endif
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursdial.c nethack-3.4.3/win/curses/cursdial.c
--- nethack-orig/win/curses/cursdial.c	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursdial.c	2010-12-17 14:01:01.908525001 -0500
@@ -0,0 +1,1591 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursdial.h"
+#include "func_tab.h"
+#include <ctype.h>
+
+/* Dialog windows for curses interface */
+
+
+/* Private declarations */
+
+typedef struct nhmi
+{
+    winid wid;  /* NetHack window id */
+    anything identifier; /* Value returned if item selected */
+    CHAR_P accelerator;  /* Character used to select item from menu */
+    CHAR_P group_accel; /* Group accelerator for menu item, if any */
+    int attr;  /* Text attributes for item */
+    const char *str;  /* Text of menu item */
+    BOOLEAN_P presel; /* Whether menu item should be preselected */
+    boolean selected;   /* Whether item is currently selected */
+    int page_num;   /* Display page number for entry */
+    int line_num;   /* Line number on page where entry begins */
+    int num_lines;  /* Number of lines entry uses on page */
+    int count;      /* Count for selected item */
+    struct nhmi *prev_item;    /* Pointer to previous entry */
+    struct nhmi *next_item;    /* Pointer to next entry */
+} nhmenu_item;
+
+typedef struct nhm
+{
+    winid wid;  /* NetHack window id */
+    const char *prompt;  /* Menu prompt text */
+    nhmenu_item *entries;   /* Menu entries */
+    int num_entries;          /* Number of menu entries */
+    int num_pages;            /* Number of display pages for entry */
+    int height;               /* Window height of menu */
+    int width;                /* Window width of menu */
+    boolean reuse_accels;     /* Non-unique accelerators per page */
+    struct nhm *prev_menu;    /* Pointer to previous entry */
+    struct nhm *next_menu;    /* Pointer to next entry */
+} nhmenu;
+
+typedef enum menu_op_type
+{
+    SELECT,
+    DESELECT,
+    INVERT
+} menu_op;
+
+#ifdef MENU_COLOR
+extern struct menucoloring *menu_colorings;
+#endif
+
+static nhmenu *get_menu(winid wid);
+
+static char menu_get_accel(boolean first);
+
+static void menu_determine_pages(nhmenu *menu);
+
+static boolean menu_is_multipage(nhmenu *menu, int width, int height);
+
+static void menu_win_size(nhmenu *menu);
+
+static void menu_display_page(nhmenu *menu, WINDOW *win, int page_num);
+
+static int menu_get_selections(WINDOW *win, nhmenu *menu, int how);
+
+static void menu_select_deselect(WINDOW *win, nhmenu_item *item, menu_op operation);
+
+static int menu_operation(WINDOW *win, nhmenu *menu, menu_op operation,
+ int page_num);
+
+static void menu_clear_selections(nhmenu *menu);
+
+static boolean get_menu_coloring(char *str, int *color, int *attr);
+
+static int menu_max_height(void);
+
+static nhmenu *nhmenus = NULL;  /* NetHack menu array */
+
+
+/* Get a line of text from the player, such as asking for a character name or a wish */
+
+void curses_line_input_dialog(const char *prompt, char *answer, int buffer)
+{
+    int map_height, map_width, maxwidth, remaining_buf, winx, winy, count;
+    WINDOW *askwin, *bwin;
+    char input[buffer];
+    char *tmpstr;
+    int prompt_width = strlen(prompt) + buffer + 1;
+    int prompt_height = 1;
+    int height = prompt_height;
+
+    maxwidth = term_cols - 2;
+
+    if (iflags.window_inited)
+    {
+        curses_get_window_size(MAP_WIN, &map_height, &map_width);
+        if ((prompt_width + 2) > map_width)
+            maxwidth = map_width - 2;
+    }
+    
+    if (prompt_width > maxwidth)
+    {
+        prompt_height = curses_num_lines(prompt, maxwidth);
+        height = prompt_height;
+        prompt_width = maxwidth;
+        tmpstr = curses_break_str(prompt, maxwidth, prompt_height);
+        remaining_buf = buffer - (strlen(tmpstr) - 1);
+        if (remaining_buf > 0 )
+        {
+            height += (remaining_buf / prompt_width);
+            if ((remaining_buf % prompt_width) > 0)
+            {
+                height++;
+            }
+        }
+    }
+    
+    if (iflags.window_inited)
+    {
+        bwin = curses_create_window(prompt_width, height, UP);
+        wrefresh(bwin);
+        getbegyx(bwin, winy, winx);
+        askwin = newwin(height, prompt_width, winy + 1, winx + 1);
+    }
+    else
+    {
+        bwin = curses_create_window(prompt_width, height, CENTER);
+        wrefresh(bwin);
+        getbegyx(bwin, winy, winx);
+        askwin = newwin(height, prompt_width, winy + 1, winx + 1);
+    }
+    for (count = 0; count < prompt_height; count++)
+    {
+        tmpstr = curses_break_str(prompt, maxwidth, count + 1);
+        if (count == (prompt_height - 1))    /* Last line */
+        {
+            mvwprintw(askwin, count, 0, "%s ", tmpstr);
+        }
+        else
+        {
+            mvwaddstr(askwin, count, 0, tmpstr);
+        }
+        free(tmpstr);
+    }
+    
+    echo();
+    curs_set(1);
+    wgetnstr(askwin, input, buffer-1);
+    curs_set(0);
+    strcpy(answer, input);
+    werase(bwin);
+    delwin(bwin);
+    curses_destroy_win(askwin);
+    noecho();
+}
+
+
+/* Get a single character response from the player, such as a y/n prompt */
+
+int curses_character_input_dialog(const char *prompt, const char *choices, CHAR_P def)
+{
+    WINDOW *askwin = NULL;
+    int answer, count, maxwidth, map_height, map_width;
+    char *linestr;
+    char askstr[BUFSZ + QBUFSZ];
+    char choicestr[QBUFSZ];
+    int prompt_width = strlen(prompt);
+    int prompt_height = 1;
+    boolean any_choice = FALSE;
+    boolean accept_count = FALSE;
+
+    if (invent || (moves > 1))
+    {
+        curses_get_window_size(MAP_WIN, &map_height, &map_width);
+    }
+    else
+    {
+        map_height = term_rows;
+        map_width = term_cols;
+    }
+    
+    maxwidth = map_width - 2;
+    
+    if (choices != NULL)
+    {
+        for (count = 0; choices[count] != '\0'; count++)
+        {
+            if (choices[count] == '#')   /* Accept a count */
+            {
+                accept_count = TRUE;
+            }
+        }
+        choicestr[0] = ' ';
+        choicestr[1] = '[';
+        for (count = 0; choices[count] != '\0'; count++)
+        {
+            if (choices[count] == '\033')   /* Escape */
+            {
+                break;
+            }
+            choicestr[count + 2] = choices[count];
+        }
+        choicestr[count + 2] = ']';
+        if (((def >= 'A') && (def <= 'Z')) || ((def >= 'a') && (def <= 'z')))
+        {
+            choicestr[count + 3] = ' ';
+            choicestr[count + 4] = '(';
+            choicestr[count + 5] = def;
+            choicestr[count + 6] = ')';
+            choicestr[count + 7] = '\0';
+        }
+        else    /* No usable default choice */
+        {
+            choicestr[count + 3] = '\0';
+            def = '\0'; /* Mark as no default */
+        }
+        strcpy(askstr, prompt);
+        strcat(askstr, choicestr);
+    }
+    else
+    {
+        strcpy(askstr, prompt);
+        any_choice = TRUE;
+    }
+    
+    prompt_width = strlen(askstr);
+    
+    if ((prompt_width + 2) > maxwidth)
+    {
+        prompt_height = curses_num_lines(askstr, maxwidth);
+        prompt_width = map_width - 2;
+    }
+
+    if (iflags.wc_popup_dialog)
+    {
+        askwin = curses_create_window(prompt_width, prompt_height, UP);
+        for (count = 0; count < prompt_height; count++)
+        {
+            linestr = curses_break_str(askstr, maxwidth, count + 1);
+            mvwaddstr(askwin, count + 1, 1, linestr);
+            free(linestr);
+        }
+    
+        wrefresh(askwin);
+    }
+    else
+    {
+        linestr = curses_copy_of(askstr);
+        pline("%s", linestr);
+        free(linestr);
+        curs_set(1);
+    }
+
+    while (1)
+    {
+        answer = getch();
+        answer = curses_convert_keys(answer);
+
+        if (answer==KEY_ESC)
+        {
+            if (choices == NULL)
+            {
+                break;
+            }
+            answer = def;
+            for (count = 0; choices[count] != '\0'; count++)
+            {
+                if (choices[count] == 'q') /* q is preferred over n */
+                {
+                    answer = 'q';
+                }
+                else if ((choices[count] == 'n') && answer != 'q')
+                {
+                    answer = 'n';
+                }
+            }
+            break;
+        }
+        else if ((answer == '\n') || (answer == '\r') ||
+         (answer == ' '))
+        {
+            if ((choices != NULL) && (def != '\0'))
+            {
+                answer = def;
+            }
+            break;
+        }
+        
+        if (digit(answer))
+        {
+            if (accept_count)
+            {
+                if (answer != '0')
+                {
+                    yn_number = curses_get_count(answer - '0');
+                    touchwin(askwin);
+                    refresh();
+                }
+                
+                answer = '#';
+                break;
+            }
+        }
+        
+        if (any_choice)
+        {
+            break;
+        }
+        
+        if (choices != NULL)
+        {
+            for (count = 0; count < strlen(choices); count++)
+            {
+                if (choices[count] == answer)
+                {
+                    break;
+                }
+            }
+            if (choices[count] == answer)
+            {
+                break;
+            }
+        }
+    }
+
+    if (iflags.wc_popup_dialog)
+    {
+        /* Kludge to make prompt visible after window is dismissed
+        when inputting a number */
+        if (digit(answer))
+        {
+            linestr = curses_copy_of(askstr);
+            pline("%s", linestr);
+            free(linestr);
+            curs_set(1);
+        }
+
+        curses_destroy_win(askwin);
+    }
+    else
+    {
+        curses_clear_unhighlight_message_window();
+        curs_set(0);
+    }
+
+    return answer;
+}
+
+
+/* Return an extended command from the user */
+
+int curses_ext_cmd()
+{
+    int count, letter, prompt_width, startx, starty, winx, winy;
+    int messageh, messagew;
+    int ret = -1;
+    char cur_choice[BUFSZ];
+    int matches = 0;
+    WINDOW *extwin = NULL;
+
+    if (iflags.extmenu)
+    {
+        return extcmd_via_menu();
+    }
+    
+    if (iflags.wc_popup_dialog) /* Prompt in popup window */
+    {
+        startx = 1;
+        starty = 1;
+        extwin = curses_create_window(25, 1, UP);
+    }
+    else
+    {
+        curses_get_window_xy(MESSAGE_WIN, &winx, &winy);
+        curses_get_window_size(MESSAGE_WIN, &messageh, &messagew);
+        
+        if (curses_window_has_border(MESSAGE_WIN))
+        {
+            winx++;
+            winy++;
+        }
+        
+        winy += messageh - 1;
+        extwin = newwin(1, 25, winy, winx);
+        startx = 0;
+        starty = 0;
+        pline("#");
+    }
+
+    cur_choice[0] = '\0';
+
+    while (1)
+    {
+        wmove(extwin, starty, startx);
+        waddstr(extwin, "# ");
+        wmove(extwin, starty, startx + 2);
+        curses_toggle_color_attr(extwin, NONE, A_UNDERLINE, ON);
+        waddstr(extwin, cur_choice);
+        curses_toggle_color_attr(extwin, NONE, A_UNDERLINE, OFF);
+        wmove(extwin, starty, strlen(cur_choice) + startx + 2);
+        wprintw(extwin, "          ", cur_choice);
+
+        if (matches == 1)
+        {
+            wmove(extwin, starty, strlen(cur_choice) + startx + 2);
+            wprintw(extwin, "%s          ", extcmdlist[ret].ef_txt
+             + strlen(cur_choice));
+        }
+
+        wrefresh(extwin);
+        letter = getch();
+	    prompt_width = strlen(cur_choice);
+        matches = 0;
+
+        if (letter == '\033')
+        {
+            ret = -1;
+            break;
+        }
+
+        if ((letter == '\r') || (letter == '\n'))
+        {
+            break;
+        }
+
+        if ((letter == '\b') || (letter == KEY_BACKSPACE))
+        {
+            if (prompt_width == 0)
+            {
+                ret = -1;
+                break;
+            }
+            else
+            {
+                cur_choice[prompt_width - 1] = '\0';
+                letter = '*';
+                prompt_width--;
+            }
+        }
+        
+        for (count = 0; extcmdlist[count].ef_txt; count++)
+        {
+            if (strlen(extcmdlist[count].ef_txt) > prompt_width)
+            {
+                if (strncmp(cur_choice, extcmdlist[count].ef_txt,
+                 prompt_width) == 0)
+                {
+                    if ((extcmdlist[count].ef_txt[prompt_width] ==
+                     letter) || letter == '*')
+                    {
+                        if ((matches == 0) && (letter != '*'))
+                        {
+                            ret = count;
+                            cur_choice[prompt_width] = letter;
+                            cur_choice[prompt_width + 1] = '\0';
+                        }
+
+                        matches++;
+                    }
+                }
+            }
+	    }
+	}    
+    
+    curses_destroy_win(extwin);
+    return ret;
+}
+
+
+/* Initialize a menu from given NetHack winid */
+
+void curses_create_nhmenu(winid wid)
+{
+    nhmenu *new_menu = NULL;
+    nhmenu *menuptr = nhmenus;
+    nhmenu_item *menu_item_ptr = NULL;
+    nhmenu_item *tmp_menu_item = NULL;
+    
+    new_menu = get_menu(wid);
+    
+    if (new_menu != NULL)
+    {
+        /* Reuse existing menu, clearing out current entries */
+        menu_item_ptr = new_menu->entries;
+        
+        if (menu_item_ptr != NULL)
+        {
+            while (menu_item_ptr->next_item != NULL)
+            {
+                tmp_menu_item = menu_item_ptr->next_item;
+                free(menu_item_ptr);
+                menu_item_ptr = tmp_menu_item;
+            }
+            free(menu_item_ptr);    /* Last entry */
+            new_menu->entries = NULL;
+        }
+        if (new_menu->prompt != NULL)   /* Reusing existing menu */
+        {
+            free((char *)new_menu->prompt);
+        }    
+        return;
+    }
+    
+    new_menu = malloc(sizeof(nhmenu));
+    new_menu->wid = wid;
+    new_menu->prompt = NULL;
+    new_menu->entries = NULL;
+    new_menu->num_pages = 0;
+    new_menu->height = 0;
+    new_menu->width = 0;
+    new_menu->reuse_accels = FALSE;
+    new_menu->next_menu = NULL;
+    
+    if (nhmenus == NULL)    /* no menus in memory yet */
+    {
+        new_menu->prev_menu = NULL;
+        nhmenus = new_menu;
+    }
+    else
+    {
+        while (menuptr->next_menu != NULL)
+        {
+            menuptr = menuptr->next_menu;
+        }
+        new_menu->prev_menu = menuptr;
+        menuptr->next_menu = new_menu;
+    }
+}
+
+
+/* Add a menu item to the given menu window */
+
+void curses_add_nhmenu_item(winid wid, const ANY_P *identifier,
+ CHAR_P accelerator, CHAR_P group_accel, int attr, const char *str,
+ BOOLEAN_P presel)
+{
+    char *new_str;
+    nhmenu_item *new_item, *current_items, *menu_item_ptr;
+    nhmenu *current_menu = get_menu(wid);
+    
+    if (str == NULL)
+    {
+        return;
+    }
+
+    new_str = curses_copy_of(str);
+    curses_rtrim((char *) new_str);
+    new_item = malloc(sizeof(nhmenu_item));
+    new_item->wid = wid;
+    new_item->identifier = *identifier;
+    new_item->accelerator = accelerator;
+    new_item->group_accel = group_accel;
+    new_item->attr = attr;
+    new_item->str = new_str;
+    new_item->presel = presel;
+    new_item->selected = FALSE;
+    new_item->page_num = 0;
+    new_item->line_num = 0;
+    new_item->num_lines = 0;
+    new_item->count = -1;
+    new_item->next_item = NULL;
+    
+    if (current_menu == NULL)
+    {
+        panic("curses_add_nhmenu_item: attempt to add item to nonexistant menu");
+    }
+
+    current_items = current_menu->entries;
+    menu_item_ptr = current_items;
+
+    if (current_items == NULL)
+    {
+        new_item->prev_item = NULL;
+        current_menu->entries = new_item;
+    }
+    else
+    {
+        while (menu_item_ptr->next_item != NULL)
+        {
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+        new_item->prev_item = menu_item_ptr;
+        menu_item_ptr->next_item = new_item;
+    }
+}
+
+
+/* No more entries are to be added to menu, so details of the menu can be
+ finalized in memory */
+
+void curses_finalize_nhmenu(winid wid, const char *prompt)
+{
+    int count = 0;
+    nhmenu *current_menu = get_menu(wid);
+    nhmenu_item *menu_item_ptr = current_menu->entries;
+
+    if (current_menu == NULL)
+    {
+        panic("curses_finalize_nhmenu: attempt to finalize nonexistant menu");
+    }
+
+    while (menu_item_ptr != NULL)
+    {
+        menu_item_ptr = menu_item_ptr->next_item;
+        count++;
+    }
+
+    current_menu->num_entries = count;
+
+    current_menu->prompt = curses_copy_of(prompt);
+}
+
+
+/* Display a nethack menu, and return a selection, if applicable */
+
+int curses_display_nhmenu(winid wid, int how, MENU_ITEM_P **_selected)
+{
+    nhmenu *current_menu = get_menu(wid);
+    nhmenu_item *menu_item_ptr;
+    int num_chosen, count;
+    WINDOW *win;
+    MENU_ITEM_P *selected = NULL;
+
+	*_selected = NULL;
+    
+    if (current_menu == NULL)
+    {
+        panic("curses_display_nhmenu: attempt to display nonexistant menu");
+    }
+    
+    menu_item_ptr = current_menu->entries;
+    
+    if (menu_item_ptr == NULL)
+    {
+        panic("curses_display_nhmenu: attempt to display empty menu");
+    }
+    
+    /* Reset items to unselected to clear out selections from previous
+    invocations of this menu, and preselect appropriate items */
+    while (menu_item_ptr != NULL)
+    {
+        menu_item_ptr->selected = menu_item_ptr->presel;
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+
+    menu_win_size(current_menu);
+    menu_determine_pages(current_menu);
+    
+    /* Display pre and post-game menus centered */
+    if (((moves <= 1) && !invent) || program_state.gameover)
+    {
+        win = curses_create_window(current_menu->width,
+         current_menu->height, CENTER);
+    }
+    else    /* Display during-game menus on the right out of the way */
+    {
+        win = curses_create_window(current_menu->width,
+         current_menu->height, RIGHT);
+    }
+    
+    num_chosen = menu_get_selections(win, current_menu, how);
+    curses_destroy_win(win);
+    
+    if (num_chosen > 0)
+    {
+        selected = (MENU_ITEM_P*) malloc(num_chosen *
+         sizeof(MENU_ITEM_P));
+        count = 0;
+        
+        menu_item_ptr = current_menu->entries;
+
+        while (menu_item_ptr != NULL)
+        {
+            if (menu_item_ptr->selected)
+            {
+                if (count == num_chosen)
+                {
+                    panic("curses_display_nhmenu: Selected items "
+                     "exceeds expected number");
+                }
+                selected[count].item = menu_item_ptr->identifier;
+                selected[count].count = menu_item_ptr->count;
+                count++; 
+            }
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+        
+        if (count != num_chosen)
+        {
+            panic("curses_display_nhmenu: Selected items less than "
+             "expected number");
+        }
+    }
+
+    *_selected = selected;
+    
+    return num_chosen;
+}
+
+
+boolean curses_menu_exists(winid wid)
+{
+    if (get_menu(wid) != NULL)
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+/* Delete the menu associated with the given NetHack winid from memory */
+
+void curses_del_menu(winid wid)
+{
+    nhmenu_item *tmp_menu_item;
+    nhmenu_item *menu_item_ptr;
+    nhmenu *tmpmenu;
+    nhmenu *current_menu = get_menu(wid);
+    
+    if (current_menu == NULL)
+    {
+       return;
+    }
+    
+    menu_item_ptr = current_menu->entries;
+    
+    /* First free entries associated with this menu from memory */
+    if (menu_item_ptr != NULL)
+    {
+        while (menu_item_ptr->next_item != NULL)
+        {
+            tmp_menu_item = menu_item_ptr->next_item;
+            free(menu_item_ptr);
+            menu_item_ptr = tmp_menu_item;
+        }
+        free(menu_item_ptr);    /* Last entry */
+        current_menu->entries = NULL;
+    }
+    
+    /* Now unlink the menu from the list and free it as well */
+    if (current_menu->prev_menu != NULL)
+    {
+        tmpmenu = current_menu->prev_menu;
+        tmpmenu->next_menu = current_menu->next_menu;
+    }
+    else
+    {
+        nhmenus = current_menu->next_menu;   /* New head mode or NULL */
+    }
+    if (current_menu->next_menu != NULL)
+    {
+        tmpmenu = current_menu->next_menu;
+        tmpmenu->prev_menu = current_menu->prev_menu;
+    }
+    
+    free(current_menu);
+    
+    curses_del_wid(wid);
+}
+
+
+/* return a pointer to the menu associated with the given NetHack winid */
+
+static nhmenu *get_menu(winid wid)
+{
+    nhmenu *menuptr = nhmenus;
+
+    while (menuptr != NULL)
+    {
+        if (menuptr->wid == wid)
+        {
+            return menuptr;
+        }
+        menuptr = menuptr->next_menu;
+    }
+    
+    return NULL;    /* Not found */
+}
+
+
+static char menu_get_accel(boolean first)
+{
+    char ret;
+    static char next_letter = 'a';
+    
+    if (first)
+    {
+        next_letter = 'a';
+    }
+    
+    ret = next_letter;
+    
+    if (((next_letter < 'z') && (next_letter >= 'a')) || ((next_letter < 'Z')
+     && (next_letter >= 'A')) || ((next_letter < '9') && (next_letter >= '0')))
+    {
+        next_letter++;
+    }
+    else if (next_letter == 'z')
+    {
+        next_letter = 'A';
+    }
+    else if (next_letter == 'Z')
+    {
+        next_letter = '0';
+    }
+    
+    return ret;
+}
+
+
+/* Determine if menu will require multiple pages to display */
+
+static boolean menu_is_multipage(nhmenu *menu, int width, int height)
+{
+    int num_lines;
+    int curline = 0;
+    nhmenu_item *menu_item_ptr = menu->entries;
+
+    if (strlen(menu->prompt) > 0)
+    {
+        curline += curses_num_lines(menu->prompt, width) + 1;
+    }
+    
+    if (menu->num_entries <= (height - curline))
+    {   
+        while (menu_item_ptr != NULL)
+        {
+            menu_item_ptr->line_num = curline;
+            if (menu_item_ptr->identifier.a_void == NULL)
+            {
+                num_lines = curses_num_lines(menu_item_ptr->str, width);
+            }
+            else
+            {
+                /* Add space for accelerator */
+                num_lines = curses_num_lines(menu_item_ptr->str, width - 4);
+            }
+            menu_item_ptr->num_lines = num_lines;
+            curline += num_lines;
+            menu_item_ptr = menu_item_ptr->next_item;
+            if ((curline > height) || ((curline > height -2) &&
+             (height == menu_max_height())))
+            {
+                break;
+            }
+        }
+        if (menu_item_ptr == NULL)
+        {
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+
+
+/* Determine which entries go on which page, and total number of pages */
+
+static void menu_determine_pages(nhmenu *menu)
+{
+    int tmpline, num_lines;
+    int curline = 0;
+    int page_num = 1;
+    nhmenu_item *menu_item_ptr = menu->entries;
+    int width = menu->width;
+    int height = menu->height;
+    int page_end = height;
+    
+    
+    if (strlen(menu->prompt) > 0)
+    {
+        curline += curses_num_lines(menu->prompt, width) + 1;
+    }
+        
+    tmpline = curline;
+    
+    if (menu_is_multipage(menu, width, height))
+    {
+        page_end -= 2;  /* Room to display current page number */
+    }
+
+    /* Determine what entries belong on which page */
+    menu_item_ptr = menu->entries;
+    
+    while (menu_item_ptr != NULL)
+    {
+        menu_item_ptr->page_num = page_num;
+        menu_item_ptr->line_num = curline;
+        if (menu_item_ptr->identifier.a_void == NULL)
+        {
+            num_lines = curses_num_lines(menu_item_ptr->str, width);
+        }
+        else
+        {
+            /* Add space for accelerator */
+            num_lines = curses_num_lines(menu_item_ptr->str, width - 4);
+        }
+        menu_item_ptr->num_lines = num_lines;
+        curline += num_lines;
+        if (curline > page_end)
+        {
+            page_num++;
+            curline = tmpline;
+            /* Move ptr back so entry will be reprocessed on new page */
+            menu_item_ptr = menu_item_ptr->prev_item;
+        }
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    menu->num_pages = page_num;
+}
+
+
+/* Determine dimensions of menu window based on term size and entries */
+
+static void menu_win_size(nhmenu *menu)
+{
+    int width, height, maxwidth, maxheight, curentrywidth, lastline;
+    int maxentrywidth = strlen(menu->prompt);
+    int maxheaderwidth = 0;
+    nhmenu_item *menu_item_ptr = menu->entries;
+    
+    maxwidth = 38;  /* Reasonable minimum usable width */
+    
+    if ((term_cols / 2) > maxwidth)
+    {
+        maxwidth = (term_cols / 2); /* Half the screen */
+    }
+    
+    maxheight = menu_max_height();
+    
+    /* First, determine the width of the longest menu entry */
+    while (menu_item_ptr != NULL)
+
+    {
+        if (menu_item_ptr->identifier.a_void == NULL)
+        {
+            curentrywidth=strlen(menu_item_ptr->str);
+
+            if (curentrywidth > maxheaderwidth)
+            {
+                maxheaderwidth = curentrywidth;
+            }
+        }
+        else
+        {
+            /* Add space for accelerator */
+            curentrywidth=strlen(menu_item_ptr->str) + 4;
+        }
+        if (curentrywidth > maxentrywidth)
+        {
+            maxentrywidth = curentrywidth;          
+        }
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    /* If the widest entry is smaller than maxwidth, reduce maxwidth accordingly */
+    if (maxentrywidth < maxwidth)
+    {
+        maxwidth = maxentrywidth;
+    }
+    
+    /* Try not to wrap headers/normal text lines if possible.  We can
+    go wider than half the screen for this purpose if need be */
+    
+    if ((maxheaderwidth > maxwidth) && (maxheaderwidth < (term_cols - 2)))
+    {
+        maxwidth = maxheaderwidth;
+    }
+    
+    width = maxwidth;
+    
+    /* Possibly reduce height if only 1 page */    
+    if (!menu_is_multipage(menu, maxwidth, maxheight))   
+    {
+        menu_item_ptr = menu->entries;
+        
+        while (menu_item_ptr->next_item != NULL)
+        {
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+        
+        lastline = (menu_item_ptr->line_num) + menu_item_ptr->num_lines;
+    
+        if (lastline < maxheight)
+        {
+            maxheight = lastline;
+        }
+    }
+    else    /* If multipage, make sure we have enough width for page footer */
+    {
+        if (width < 20)
+        {
+            width = 20;
+        }
+    }
+
+    height = maxheight;
+    menu->width = width;
+    menu->height = height;
+}
+
+
+/* Displays menu selections in the given window */
+
+static void menu_display_page(nhmenu *menu, WINDOW *win, int page_num)
+{
+    nhmenu_item *menu_item_ptr;
+    int count, curletter, entry_cols, start_col, num_lines, footer_x;
+    boolean first_accel = TRUE;
+#ifdef MENU_COLOR
+    int color = NO_COLOR;
+    int attr = A_NORMAL;
+    boolean menu_color = FALSE;
+#endif /* MENU_COLOR */
+    
+    /* Cycle through entries until we are on the correct page */
+
+    menu_item_ptr = menu->entries;
+    
+    while (menu_item_ptr != NULL)
+    {
+        if (menu_item_ptr->page_num == page_num)
+        {
+            break;
+        }
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    if (menu_item_ptr == NULL)  /* Page not found */
+    {
+        panic("menu_display_page: attempt to display nonexistant page");
+    }
+
+    werase(win);
+
+    if (strlen(menu->prompt) > 0)
+    {
+        num_lines = curses_num_lines(menu->prompt, menu->width);
+        
+        for (count = 0; count < num_lines; count++)
+        {
+            mvwprintw(win, count + 1, 1, "%s",
+             curses_break_str(menu->prompt, menu->width, count + 1));
+        }
+    }
+
+    /* Display items for current page */
+    
+    while (menu_item_ptr != NULL)
+    {
+        if (menu_item_ptr->page_num != page_num)
+        {
+            break;
+        }
+        if (menu_item_ptr->identifier.a_void != NULL)
+        {
+            if (menu_item_ptr->accelerator != 0)
+            {
+                curletter = menu_item_ptr->accelerator;
+            }
+            else
+            {
+                if (first_accel)
+                {
+                    curletter = menu_get_accel(TRUE);
+                    first_accel = FALSE;
+                    if (!menu->reuse_accels && (menu->num_pages > 1))
+                    {
+                        menu->reuse_accels = TRUE;
+                    }
+                }
+                else
+                {
+                    curletter = menu_get_accel(FALSE);
+                }
+                menu_item_ptr->accelerator = curletter;
+            }
+
+            if (menu_item_ptr->selected)
+            {
+                curses_toggle_color_attr(win, HIGHLIGHT_COLOR, A_REVERSE, ON);
+                mvwaddch(win, menu_item_ptr->line_num + 1, 1, '<');
+                mvwaddch(win, menu_item_ptr->line_num + 1, 2, curletter);
+                mvwaddch(win, menu_item_ptr->line_num + 1, 3, '>');
+                curses_toggle_color_attr(win, HIGHLIGHT_COLOR, A_REVERSE, OFF);
+            }
+            else
+            {
+                curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, ON);
+                mvwaddch(win, menu_item_ptr->line_num + 1, 2, curletter);
+                curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, OFF);
+                mvwprintw(win, menu_item_ptr->line_num + 1, 3, ") ");
+            }
+        }
+#ifdef MENU_COLOR
+		if (iflags.use_menu_color && (menu_color = get_menu_coloring
+		 ((char *)menu_item_ptr->str, &color, &attr)))
+		{
+		    if (color != NO_COLOR)
+		    {
+                curses_toggle_color_attr(win, color, NONE, ON);
+		    }
+    		if (attr != A_NORMAL)
+    		{
+    		    menu_item_ptr->attr = menu_item_ptr->attr|attr;
+    		}
+		}
+#endif /* MENU_COLOR */
+        curses_toggle_color_attr(win, NONE, menu_item_ptr->attr, ON);
+        entry_cols = menu->width;
+        start_col = 1;
+
+        if (menu_item_ptr->identifier.a_void != NULL)
+        {
+            entry_cols -= 4;
+            start_col += 4;
+        }        
+        
+        num_lines = curses_num_lines(menu_item_ptr->str, entry_cols);
+        
+        for (count = 0; count < num_lines; count++)
+        {
+            if (strlen(menu_item_ptr->str) > 0)
+            {
+                mvwprintw(win, menu_item_ptr->line_num + count + 1,
+                 start_col, "%s", curses_break_str(menu_item_ptr->str,
+                 entry_cols, count + 1));
+             }
+        }
+#ifdef MENU_COLOR
+	if (menu_color && (color != NO_COLOR))
+    {
+        curses_toggle_color_attr(win, color, NONE, OFF);
+    }
+#endif /* MENU_COLOR */
+        curses_toggle_color_attr(win, NONE, menu_item_ptr->attr, OFF);
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+
+    if (menu->num_pages > 1)
+    {
+        footer_x = menu->width - strlen("<- (Page X of Y) ->");
+        if (menu->num_pages > 9)    /* Unlikely */
+        {
+            footer_x -= 2;
+        }
+        mvwprintw(win, menu->height, footer_x + 3, "(Page %d of %d)",
+         page_num, menu->num_pages);
+        if (page_num != 1)
+        {
+            curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, ON);
+            mvwaddstr(win, menu->height, footer_x, "<=");
+            curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, OFF);
+        }
+        if (page_num != menu->num_pages)
+        {
+            curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, ON);
+            mvwaddstr(win, menu->height, menu->width - 2, "=>");        
+            curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, OFF);
+        }
+    }
+    curses_toggle_color_attr(win, DIALOG_BORDER_COLOR, NONE, ON);
+    box(win, 0, 0);
+    curses_toggle_color_attr(win, DIALOG_BORDER_COLOR, NONE, OFF);
+    wrefresh(win);
+}
+
+
+static int menu_get_selections(WINDOW *win, nhmenu *menu, int how)
+{
+    int curletter;
+    int count = -1;
+    int count_letter = '\0';
+    int curpage = 1;
+    int num_selected = 0;
+    boolean dismiss = FALSE;
+    char search_key[BUFSZ];
+    nhmenu_item *menu_item_ptr = menu->entries;
+
+    menu_display_page(menu, win, 1);
+
+    while (!dismiss)
+    {
+        curletter = getch();
+        
+        if (curletter == '\033')
+        {
+            curletter = curses_convert_keys(curletter);
+        }
+        
+        if (isdigit(curletter) && (how != PICK_NONE))
+        {
+            count = curses_get_count(curletter - '0');
+            touchwin(win);
+            refresh();
+            curletter = getch();
+            
+            if (count > 0)
+            {
+                count_letter = curletter;
+            }
+        }
+        
+
+        if ((how == PICK_NONE) && (menu->num_pages == 1))
+        {
+            if (how==PICK_NONE)
+            {    
+                if (curletter == KEY_ESC)
+                {
+                    num_selected = -1;
+                }
+                else
+                {
+                    num_selected = 0;
+
+                }
+                dismiss = TRUE;
+                break;
+            }                
+        }
+        
+        switch (curletter)
+        {
+            case KEY_ESC:
+            {
+                num_selected = -1;
+                dismiss = TRUE;
+                break;
+            }
+            case '\n':
+            case '\r':
+            {
+                dismiss = TRUE;
+                break;
+            }
+            case KEY_RIGHT:
+            case KEY_NPAGE:
+            case MENU_NEXT_PAGE:
+            case ' ':
+            {
+                if (curpage < menu->num_pages)
+                {
+                    curpage++;
+                    menu_display_page(menu, win, curpage);
+                }
+                else if (curletter == ' ')
+                {
+                    dismiss = TRUE;
+                    break;
+                }
+                break;
+            }
+            case KEY_LEFT:
+            case KEY_PPAGE:
+            case MENU_PREVIOUS_PAGE:
+            {
+                if (curpage > 1)
+                {
+                    curpage--;
+                    menu_display_page(menu, win, curpage);
+                }
+                break;
+            }
+            case KEY_END:
+            case MENU_LAST_PAGE:
+            {
+                if (curpage != menu->num_pages)
+                {
+                    curpage = menu->num_pages;
+                    menu_display_page(menu, win, curpage);
+                }
+                break;
+            }
+            case KEY_HOME:
+            case MENU_FIRST_PAGE:
+            {
+                if (curpage != 1)
+                {
+                    curpage = 1;
+                    menu_display_page(menu, win, curpage);
+                }
+                break;
+            }
+            case MENU_SEARCH:
+            {
+                curses_line_input_dialog("Search for:", search_key,
+                 BUFSZ);
+        		
+                refresh();
+                touchwin(win);
+                wrefresh(win);
+                
+        		if (strlen(search_key) == 0)
+        		{
+        		    break;
+        		}
+        		
+                menu_item_ptr = menu->entries;
+
+                while (menu_item_ptr != NULL)
+                {
+                    if ((menu_item_ptr->identifier.a_void != NULL) &&
+                     (strstri(menu_item_ptr->str, search_key)))
+                    {
+                        if (how == PICK_ONE)
+                        {
+                            menu_clear_selections(menu);
+                            menu_select_deselect(win, menu_item_ptr,
+                             SELECT);
+                            num_selected = 1;
+                            dismiss = TRUE;
+                            break;
+                        }
+                        else
+                        {
+                            menu_select_deselect(win, menu_item_ptr,
+                             INVERT);
+                        }
+                    }
+
+                    menu_item_ptr = menu_item_ptr->next_item;
+                }
+
+                menu_item_ptr = menu->entries;
+                break;
+            }
+            default:
+            {
+                if (how==PICK_NONE)
+                {    
+                    num_selected = 0;
+                    dismiss = TRUE;
+                    break;
+                }                
+            }
+        }
+        if (how == PICK_ANY)
+        {
+            switch (curletter)
+                {
+                case MENU_SELECT_PAGE:
+                {
+                    (void) menu_operation(win, menu, SELECT, curpage);
+                    break;
+                }
+                case MENU_SELECT_ALL:
+                {
+                    curpage = menu_operation(win, menu, SELECT, 0);
+                    break;
+                }
+                case MENU_UNSELECT_PAGE:
+                {
+                    (void) menu_operation(win, menu, DESELECT, curpage);
+                    break;
+                }
+                case MENU_UNSELECT_ALL:
+                {
+                    curpage = menu_operation(win, menu, DESELECT, 0);
+                    break;
+                }
+                case MENU_INVERT_PAGE:
+                {
+                    (void) menu_operation(win, menu, INVERT, curpage);
+                    break;
+                }
+                case MENU_INVERT_ALL:
+                {
+                    curpage = menu_operation(win, menu, INVERT, 0);
+                    break;
+                }
+            }
+        }
+        
+        menu_item_ptr = menu->entries;
+        
+        while (menu_item_ptr != NULL)
+        {
+            if (menu_item_ptr->identifier.a_void != NULL)
+            {
+                if (((curletter == menu_item_ptr->accelerator) &&
+                 ((curpage == menu_item_ptr->page_num) ||
+                 (!menu->reuse_accels))) || ((menu_item_ptr->group_accel)
+                 && (curletter == menu_item_ptr->group_accel)))
+                {
+                    if (curpage != menu_item_ptr->page_num)
+                    {
+                        curpage = menu_item_ptr->page_num;
+                        menu_display_page(menu, win, curpage);
+                    }
+
+                    if (how == PICK_ONE)
+                    {
+                        menu_clear_selections(menu);
+                        menu_select_deselect(win, menu_item_ptr, SELECT);
+                        num_selected = 1;
+                        dismiss = TRUE;
+                        break;
+                    }
+                    else
+                    {
+                        menu_select_deselect(win, menu_item_ptr, INVERT);
+                    }
+                }
+            }
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+    }
+    
+    if ((how == PICK_ANY) && (num_selected != -1))
+    {
+        num_selected = 0;
+        menu_item_ptr = menu->entries;
+        
+        while (menu_item_ptr != NULL)
+        {
+            if (menu_item_ptr->identifier.a_void != NULL)
+            {
+                if (menu_item_ptr->selected)
+                {
+                    num_selected++;
+                    
+                    if (menu_item_ptr->accelerator == count_letter)
+                    {
+                        menu_item_ptr->count = count;
+                        count = 0;
+                        count_letter = '\0';
+                    }
+                }
+            }
+            menu_item_ptr = menu_item_ptr->next_item;
+        }
+    }
+    
+    return num_selected;
+}
+
+
+/* Select, deselect, or toggle selected for the given menu entry */
+
+static void menu_select_deselect(WINDOW *win, nhmenu_item *item, menu_op operation)
+{
+    int curletter = item->accelerator;
+    
+    if ((operation == DESELECT) || (item->selected && (operation ==
+     INVERT)))
+    {
+        item->selected = FALSE;
+        mvwaddch(win, item->line_num + 1, 1, ' ');
+        curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, ON);
+        mvwaddch(win, item->line_num + 1, 2, curletter);
+        curses_toggle_color_attr(win, HIGHLIGHT_COLOR, NONE, OFF);
+        mvwaddch(win, item->line_num + 1, 3, ')');
+    }
+    else
+    {
+        item->selected = TRUE;
+        curses_toggle_color_attr(win, HIGHLIGHT_COLOR, A_REVERSE, ON);
+        mvwaddch(win, item->line_num + 1, 1, '<');
+        mvwaddch(win, item->line_num + 1, 2, curletter);
+        mvwaddch(win, item->line_num + 1, 3, '>');
+        curses_toggle_color_attr(win, HIGHLIGHT_COLOR, A_REVERSE, OFF);
+    }
+    
+    wrefresh(win);
+}
+
+
+/* Perform the selected operation (select, unselect, invert selection)
+on the given menu page.  If menu_page is 0, then perform opetation on
+all pages in menu.  Returns last page displayed.  */
+
+static int menu_operation(WINDOW *win, nhmenu *menu, menu_op
+ operation, int page_num)
+{
+    int first_page, last_page, current_page;
+    nhmenu_item *menu_item_ptr = menu->entries;    
+    
+    if (page_num == 0)  /* Operation to occur on all pages */
+    {
+        first_page = 1;
+        last_page = menu->num_pages;
+    }
+    else
+    {
+        first_page = page_num;
+        last_page = page_num;
+    }
+
+    /* Cycle through entries until we are on the correct page */
+
+    while (menu_item_ptr != NULL)
+    {
+        if (menu_item_ptr->page_num == first_page)
+        {
+            break;
+        }
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    current_page = first_page;
+    
+    if (page_num == 0)
+    {
+        menu_display_page(menu, win, current_page);
+    }
+    
+    if (menu_item_ptr == NULL)  /* Page not found */
+    {
+        panic("menu_display_page: attempt to display nonexistant page");
+    }
+    
+    while (menu_item_ptr != NULL)
+    {        
+        if (menu_item_ptr->page_num != current_page)
+        {
+            if (menu_item_ptr->page_num > last_page)
+            {
+                break;
+            }
+
+            current_page = menu_item_ptr->page_num;
+            menu_display_page(menu, win, current_page);
+        }
+        
+        if (menu_item_ptr->identifier.a_void != NULL)
+        {
+            menu_select_deselect(win, menu_item_ptr, operation);
+        }
+        
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+    
+    return current_page;
+}
+
+
+/* Set all menu items to unselected in menu */
+
+static void menu_clear_selections(nhmenu *menu)
+{
+    nhmenu_item *menu_item_ptr = menu->entries;    
+
+    while (menu_item_ptr != NULL)    
+    {
+        menu_item_ptr->selected = FALSE;
+        menu_item_ptr = menu_item_ptr->next_item;
+    }
+}
+
+
+/* This is to get the color of a menu item if the menucolor patch is
+ applied */
+
+#ifdef MENU_COLOR
+static boolean get_menu_coloring(char *str, int *color, int *attr)
+{
+    struct menucoloring *tmpmc;
+    if (iflags.use_menu_color)
+	for (tmpmc = menu_colorings; tmpmc; tmpmc = tmpmc->next)
+# ifdef MENU_COLOR_REGEX
+#  ifdef MENU_COLOR_REGEX_POSIX
+	    if (regexec(&tmpmc->match, str, 0, NULL, 0) == 0) {
+#  else
+
+	    if (re_search(&tmpmc->match, str, strlen(str), 0, 9999, 0) >= 0) {
+#  endif
+# else
+	    if (pmatch(tmpmc->match, str)) {
+# endif
+		*color = tmpmc->color;
+		*attr = curses_convert_attr(tmpmc->attr);
+		return TRUE;
+	    }
+    return FALSE;
+}
+#endif /* MENU_COLOR */
+
+
+/* Get the maximum height for a menu */
+
+static int menu_max_height(void)
+{
+    return term_rows - 2;
+}
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursdial.h nethack-3.4.3/win/curses/cursdial.h
--- nethack-orig/win/curses/cursdial.h	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursdial.h	2010-12-17 14:01:01.908525001 -0500
@@ -0,0 +1,35 @@
+#ifndef CURSDIAL_H
+#define CURSDIAL_H
+
+#ifdef MENU_COLOR
+# ifdef MENU_COLOR_REGEX
+#  include <regex.h>
+# endif
+#endif
+
+
+/* Global declarations */
+
+void curses_line_input_dialog(const char *prompt, char *answer, int buffer);
+
+int curses_character_input_dialog(const char *prompt, const char *choices, CHAR_P def);
+
+int curses_ext_cmd(void);
+
+void curses_create_nhmenu(winid wid);
+
+void curses_add_nhmenu_item(winid wid, const ANY_P *identifier,
+ CHAR_P accelerator, CHAR_P group_accel, int attr, const char *str,
+ BOOLEAN_P presel);
+
+void curses_finalize_nhmenu(winid wid, const char *prompt);
+
+int curses_display_nhmenu(winid wid, int how, MENU_ITEM_P **_selected);
+
+boolean curses_menu_exists(winid wid);
+
+void curses_del_menu(winid wid);
+
+
+
+#endif  /* CURSDIAL_H */
diff -burN '--exclude=.svn' nethack-orig/win/curses/curses-todo.txt nethack-3.4.3/win/curses/curses-todo.txt
--- nethack-orig/win/curses/curses-todo.txt	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/curses-todo.txt	2010-12-18 16:08:44.978308195 -0500
@@ -0,0 +1,92 @@
+Below are some ideas for future improvements. I am interested in
+hearing any additional suggestions.
+
+NetHack Interface
+=================
+
+(These are the functions in cursmain.c called by the core NetHack code)
+
+  * Implement curses_rip for optional fancier color tombstone, as well
+ as one that will display correctly on smaller terminals.
+
+  * I am confused as to how mark_synch and wait_synch should work.
+  Help, please?
+
+  * raw_print is supposed to be able to work before the windowing
+ system has been initialized, as well as after, so I am unsure if
+ curses functions should be used here. Maybe check to see if
+ initscr() has been called, and use curses functions if so, and call
+ initscr() from there is not? Right now it is just a call to puts()
+ with no support for bold text.
+
+Display
+=======
+
+  * Calls to getch() should probably be turned into wgetch() for the
+ appropriate window. This causes quirky cursor behavior under
+ PDCurses, however.
+
+  * Support option to set foreground and background colors for
+ individual windows
+
+Menus
+=====
+
+(cursdial.c)
+
+  * Menus probably should never overlap with the message window, since
+ the user sometimes needs to be able to see the messages while the
+ menu is active, e.g. when identifying multiple items one at a time.
+
+  * Perhaps allow for keyboard navigation of individual items, e.g.
+ using the up and down arrows to move among the selectable items,
+ and selecting individual items with the spacebar. Perhaps the tab
+ key could jump to the first selectable item after the next heading,
+ and shift-tab could jump to the first item of the previous heading.
+
+Status Window
+=============
+
+(cursstat.c)
+
+ * Possibly show thermometer bars for hit points and magical power
+with an expanded status display
+
+  * Maybe add some configuration options for what colors are used and
+ the like.
+
+Other Platforms
+===============
+
+PDCurses also works on DOS and OS/2. Porting the curses interface to
+these platforms should not be too difficult.
+
+Misc
+====
+
+  * Update documentation and in-game help to describe the newly-added
+ options: cursesgraphics, term_rows, term_cols, and windowborders.
+
+  * PDCurses has a function named "addrawch" to output the visual
+ representation of a control character to the screen without having
+ the control character affect the display otherwise. I would like to
+ find a way to accomplish the same thing via Ncurses to e.g. be able
+ to use a font like nh10 with the correct symbol mappings in an
+ xterm or the like. (maybe impossible on a real terminal?)
+
+  * Convert nh10.bdf text font into a format that PDCurses-SDL can use.
+
+  * Allow all transient windows to be moved with arrows, possibly with
+ modifier keys for multipage dialogs.
+
+  * Maybe add in a very small built-in editor for editing the config
+  file from withing the game.
+
+  * Implement perm_invent option to allow inventory window to always
+be visible on larger terminals 
+
+  * Add window_borders option to not draw window borders for the main
+windows on the outside edge of the terminal 
+
+Retrieved from "http://nethack-curses.wikia.com/wiki/Developers"
+
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursinit.c nethack-3.4.3/win/curses/cursinit.c
--- nethack-orig/win/curses/cursinit.c	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursinit.c	2010-12-17 14:01:01.898525001 -0500
@@ -0,0 +1,1197 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursinit.h"
+#include "patchlevel.h"
+
+#include <ctype.h>
+
+/* Initialization and startup functions for curses interface */
+
+/* Private declarations */
+
+#define NETHACK_CURSES      1
+#define SLASHEM_CURSES      2
+#define UNNETHACK_CURSES    3
+#define SPORKHACK_CURSES    4
+
+/* Banners used for an optional ASCII splash screen */
+
+#define NETHACK_SPLASH_A \
+" _   _        _    _    _               _    "
+
+#define NETHACK_SPLASH_B \
+"| \\ | |      | |  | |  | |             | |   "
+
+#define NETHACK_SPLASH_C \
+"|  \\| |  ___ | |_ | |__| |  __ _   ___ | | __"
+
+#define NETHACK_SPLASH_D \
+"| . ` | / _ \\| __||  __  | / _` | / __|| |/ /"
+
+#define NETHACK_SPLASH_E \
+"| |\\  ||  __/| |_ | |  | || (_| || (__ |   < "
+
+#define NETHACK_SPLASH_F \
+"|_| \\_| \\___| \\__||_|  |_| \\__,_| \\___||_|\\_\\"
+
+#define SLASHEM_SPLASH_A \
+" _____  _              _     _  ______  __  __ "
+
+#define SLASHEM_SPLASH_B \
+" / ____|| |            | |   ( )|  ____||  \\/  |"
+
+#define SLASHEM_SPLASH_C \
+"| (___  | |  __ _  ___ | |__  \\|| |__   | \\  / |"
+
+#define SLASHEM_SPLASH_D \
+" \\___ \\ | | / _` |/ __|| '_ \\   |  __|  | |\\/| |"
+
+#define SLASHEM_SPLASH_E \
+" ____) || || (_| |\\__ \\| | | |  | |____ | |  | |"
+
+#define SLASHEM_SPLASH_F \
+"|_____/ |_| \\__,_||___/|_| |_|  |______||_|  |_|"
+
+#define UNNETHACK_SPLASH_A \
+" _    _         _   _        _    _    _               _"
+
+#define UNNETHACK_SPLASH_B \
+"| |  | |       | \\ | |      | |  | |  | |             | |"
+
+#define UNNETHACK_SPLASH_C \
+"| |  | | _ __  |  \\| |  ___ | |_ | |__| |  __ _   ___ | | __"
+
+#define UNNETHACK_SPLASH_D \
+"| |  | || '_ \\ | . ` | / _ \\| __||  __  | / _` | / __|| |/ /"
+
+#define UNNETHACK_SPLASH_E \
+"| |__| || | | || |\\  ||  __/| |_ | |  | || (_| || (__ |   <"
+
+#define UNNETHACK_SPLASH_F \
+" \\____/ |_| |_||_| \\_| \\___| \\__||_|  |_| \\__,_| \\___||_|\\_\\"
+
+#define SPORKHACK_SPLASH_A \
+"  _____                      _     _    _               _    "
+#define SPORKHACK_SPLASH_B \
+" / ____|                    | |   | |  | |             | |   "
+#define SPORKHACK_SPLASH_C \
+"| (___   _ __    ___   _ __ | | __| |__| |  __ _   ___ | | __"
+#define SPORKHACK_SPLASH_D \
+" \\___ \\ | '_ \\  / _ \\ | '__|| |/ /|  __  | / _` | / __|| |/ /"
+#define SPORKHACK_SPLASH_E \
+" ____) || |_) || (_) || |   |   < | |  | || (_| || (__ |   < "
+#define SPORKHACK_SPLASH_F \
+"|_____/ | .__/  \\___/ |_|   |_|\\_\\|_|  |_| \\__,_| \\___||_|\\_\\"
+#define SPORKHACK_SPLASH_G \
+"        | |                                                  "
+#define SPORKHACK_SPLASH_H \
+"        |_|                                                  "
+
+
+/* Create the "main" nonvolitile windows used by nethack */
+
+void curses_create_main_windows()
+{
+    int message_x = 0;
+    int message_y = 0;
+    int status_x = 0;
+    int status_y = 0;
+    int map_x = 0;
+    int map_y = 0;
+    int message_height = 0;
+    int message_width = 0;
+    int status_height = 0;
+    int status_width = 0;
+    int map_height = 0;
+    int map_width = 0;
+    int min_message_height = 1;
+    int message_orientation = 0;
+    int status_orientation = 0;
+    int border_space = 0;
+    int hspace = term_cols - 80;
+    boolean borders = FALSE;
+
+    switch (iflags.wc2_windowborders)
+    {
+        case 1: /* On */
+        {
+            borders = TRUE;
+            break;
+        }
+        case 2: /* Off */
+        {
+            borders = FALSE;
+            break;
+        }
+        case 3: /* Auto */
+        {
+            if ((term_cols > 81) && (term_rows > 25))
+            {
+                borders = TRUE;
+            }
+            break;
+        }
+        default:
+        {
+            borders = FALSE;
+        }
+    }
+
+    
+    if (borders)
+    {
+        border_space = 2;
+        hspace -= border_space;
+    }
+    
+    if ((term_cols - border_space) < COLNO)
+    {
+        min_message_height++;
+    }
+    
+    /* Determine status window orientation */    
+    if (!iflags.wc_align_status || (iflags.wc_align_status == ALIGN_TOP)
+     || (iflags.wc_align_status == ALIGN_BOTTOM))
+    {
+        if (!iflags.wc_align_status)
+        {
+            iflags.wc_align_status = ALIGN_BOTTOM;
+        }
+        status_orientation = iflags.wc_align_status;
+    }
+    else    /* left or right alignment */
+    {
+        /* Max space for player name and title horizontally */
+        if ((hspace >= 26) && (term_rows >= 24))
+        {
+            status_orientation = iflags.wc_align_status;
+            hspace -= (26 + border_space);
+        }
+        else
+        {
+            status_orientation = ALIGN_BOTTOM;
+        }
+    }
+    
+    /* Determine message window orientation */    
+    if (!iflags.wc_align_message || (iflags.wc_align_message == ALIGN_TOP)
+     || (iflags.wc_align_message == ALIGN_BOTTOM))
+    {
+        if (!iflags.wc_align_message)
+        {
+            iflags.wc_align_message = ALIGN_TOP;
+        }
+        message_orientation = iflags.wc_align_message;
+    }
+    else    /* left or right alignment */
+    {
+        if ((hspace - border_space) >= 25)   /* Arbitrary */
+        {
+            message_orientation = iflags.wc_align_message;
+        }
+        else
+        {
+            message_orientation = ALIGN_TOP;
+        }
+    }
+    
+    /* Determine window placement and size - 16 possible combos
+       If anyone wants to try to generalize this, be my guest! */
+    if ((status_orientation == ALIGN_TOP) &&
+     (message_orientation == ALIGN_TOP))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_width = (term_cols - border_space);
+        status_height = 2;
+        message_x = 0;
+        message_y = status_y + (status_height + border_space);
+        message_width = (term_cols - border_space);
+        message_height = term_rows - (status_height + ROWNO + (border_space * 3));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_x = 0;
+        map_y = message_y + (message_height + border_space);
+        map_width = (term_cols - border_space);
+        map_height = term_rows - (status_height + message_height + (border_space * 3));
+    }
+    else if ((status_orientation == ALIGN_TOP) &&
+     (message_orientation == ALIGN_RIGHT))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = 2;
+        message_height = (term_rows - border_space);
+        message_width = term_cols - (COLNO + (border_space * 2));
+        status_width = term_cols - (message_width + (border_space * 2));
+        message_x = status_x + (status_width + border_space);
+        message_y = 0;
+        map_x = 0;
+        map_y = status_y + (status_height + border_space);
+        map_width = status_width;
+        map_height = term_rows - (status_height + (border_space * 2));
+    }
+    else if ((status_orientation == ALIGN_TOP) &&
+     (message_orientation == ALIGN_BOTTOM))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_width = (term_cols - border_space);
+        status_height = 2;
+        map_x = 0;
+        map_y = status_y + (status_height + border_space);
+        map_width = (term_cols - border_space);
+        message_height = term_rows - (status_height + ROWNO + (border_space * 3));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_height = term_rows - (status_height + message_height + (border_space * 3));
+        message_x = 0;
+        message_y = map_y + (map_height + border_space);
+        message_width = (term_cols - border_space);
+    }
+    else if ((status_orientation == ALIGN_TOP) &&
+     (message_orientation == ALIGN_LEFT))
+    {
+        message_x = 0;
+        message_y = 0;
+        message_height = (term_rows - border_space);
+        message_width = term_cols - (COLNO + (border_space * 2));
+        status_x = message_x + (message_width + border_space);
+        status_y = 0;
+        status_height = 2;
+        status_width = term_cols - (message_width + (border_space * 2));
+        map_x = status_x;
+        map_y = status_y + (status_height + border_space);
+        map_height = term_rows - (status_height + (border_space * 2));
+        map_width = status_width;
+    }
+    if ((status_orientation == ALIGN_RIGHT) &&
+     (message_orientation == ALIGN_TOP))
+    {
+        status_width = 26;
+        status_height = (term_rows - border_space);
+        status_x = term_cols - (status_width + border_space);
+        status_y = 0;
+        message_x = 0;
+        message_y = 0;
+        message_width = term_cols - (status_width + (border_space * 2));
+        message_height = term_rows - (ROWNO + (border_space * 2));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_x = 0;
+        map_y = message_y + (message_height + border_space);
+        map_width = term_cols - (status_width + (border_space * 2));
+        map_height = term_rows - (message_height + (border_space * 2));
+    }
+    else if ((status_orientation == ALIGN_RIGHT) &&
+     (message_orientation == ALIGN_RIGHT))
+    {
+        map_x = 0;
+        map_y = 0;
+        map_height = (term_rows - border_space);
+        status_width = 26;
+        message_width = term_cols - (COLNO + status_width + (border_space * 3));
+        map_width = term_cols - (status_width + message_width + (border_space * 3));
+        message_x = map_x + (map_width + border_space);
+        message_y = 0;
+        message_height = (term_rows - border_space);
+        status_x = message_x + (message_width + border_space);
+        status_y = 0;
+        status_height = (term_rows - border_space);
+    }
+    else if ((status_orientation == ALIGN_RIGHT) &&
+     (message_orientation == ALIGN_BOTTOM))
+    {
+        map_x = 0;
+        map_y = 0;
+        status_width = 26;
+        map_width = term_cols - (status_width + (border_space * 2));
+        message_height = term_rows - (ROWNO + (border_space * 2));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_height = term_rows - (message_height + (border_space * 2));
+        message_x = 0;
+        message_y = map_y + (map_height + border_space);
+        message_width = map_width;
+        status_x = map_x + (map_width + border_space);
+        status_y = 0;
+        status_height = (term_rows - border_space);
+    }
+    else if ((status_orientation == ALIGN_RIGHT) &&
+     (message_orientation == ALIGN_LEFT))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = (term_rows - border_space);
+        status_width = 26;
+        message_width = term_cols - (status_width + COLNO + (border_space * 3));
+        map_x = status_x + (status_width + border_space);
+        map_y = 0;
+        map_height = (term_rows - border_space);
+        map_width = term_cols - (status_width + message_width + (border_space * 3));
+        message_x = map_x + (map_width + border_space);
+        message_y = 0;
+        message_height = (term_rows - border_space);
+    }
+    if ((status_orientation == ALIGN_BOTTOM) &&
+     (message_orientation == ALIGN_TOP))
+    {
+        message_x = 0;
+        message_y = 0;
+        message_width = (term_cols - border_space);
+        status_height = 2;
+        message_height = term_rows - (status_height + ROWNO + (border_space * 3));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_x = 0;
+        map_y = message_y + (message_height + border_space);
+        map_width = (term_cols - border_space);
+        map_height = term_rows - (status_height + message_height + (border_space * 3));
+        status_x = 0;
+        status_y = map_y + (map_height + border_space);
+        status_width = (term_cols - border_space);
+    }
+    else if ((status_orientation == ALIGN_BOTTOM) &&
+     (message_orientation == ALIGN_RIGHT))
+    {
+        map_x = 0;
+        map_y = 0;
+        status_height = 2;
+        map_height = term_rows - (status_height + (border_space * 2));
+        message_width = term_cols - (COLNO + (border_space * 2));
+        map_width = term_cols - (message_width + (border_space * 2));
+        status_x = 0;
+        status_y = map_y + (map_height + border_space);
+        status_width = map_width;
+        message_x = map_x + (map_width + border_space);
+        message_y = 0;
+        message_height = (term_rows - border_space);
+    }
+    else if ((status_orientation == ALIGN_BOTTOM) &&
+     (message_orientation == ALIGN_BOTTOM))
+    {
+        map_x = 0;
+        map_y = 0;
+        message_x = 0;
+        status_x = 0;
+        message_width = (term_cols - border_space);
+        status_height = 2;
+        message_height = term_rows - (status_height + ROWNO + (border_space * 3));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_width = (term_cols - border_space);
+        map_height = term_rows - (status_height + message_height + (border_space * 3));
+        message_y = map_y + (map_height + border_space);
+        status_y = message_y + (message_height + border_space);
+        status_width = (term_cols - border_space);
+    }
+    else if ((status_orientation == ALIGN_BOTTOM) &&
+     (message_orientation == ALIGN_LEFT))
+    {
+        message_x = 0;
+        message_y = 0;
+        message_height = (term_rows - border_space);
+        message_width = term_cols - (COLNO + (border_space * 2));
+        status_height = 2;
+        map_x = message_x + (message_width + border_space);
+        map_y = 0;
+        map_height = term_rows - (status_height + (border_space * 2));
+        map_width = term_cols - (message_width + (border_space * 2));
+        status_x = map_x;
+        status_y = map_y + (map_height + border_space);
+        status_width = term_cols - (message_width + (border_space * 2));
+    }
+    if ((status_orientation == ALIGN_LEFT) &&
+     (message_orientation == ALIGN_TOP))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = (term_rows - border_space);
+        status_width = 26;
+        message_x = status_x + (status_width + border_space);
+        message_y = 0;
+        message_height = term_rows - (ROWNO + (border_space * 2));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        message_width = term_cols - (status_width + (border_space * 2));
+        map_x = message_x;
+        map_y = message_y + (message_height + border_space);
+        map_height = term_rows - (message_height + (border_space * 2));
+        map_width = term_cols - (status_width + (border_space * 2));
+    }
+    else if ((status_orientation == ALIGN_LEFT) &&
+     (message_orientation == ALIGN_RIGHT))
+    {
+        message_x = 0;
+        message_y = 0;
+        message_height = (term_rows - border_space);
+        status_width = 26;
+        message_width = term_cols - (status_width + COLNO + (border_space * 3));
+        map_x = message_x + (message_width + border_space);
+        map_y = 0;
+        map_height = (term_rows - border_space);
+        map_width = term_cols - (status_width + message_width + (border_space * 3));
+        status_x = map_x + (map_width + border_space);
+        status_y = 0;
+        status_height = (term_rows - border_space);
+    }
+    else if ((status_orientation == ALIGN_LEFT) &&
+     (message_orientation == ALIGN_BOTTOM))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = (term_rows - border_space);
+        status_width = 26;
+        map_x = status_x + (status_width + border_space);
+        map_y = 0;
+        message_height = term_rows - (ROWNO + (border_space * 2));
+        if (message_height < min_message_height)
+        {
+            message_height = min_message_height;
+        }
+        map_height = term_rows - (message_height + (border_space * 2));
+        map_width = term_cols - (status_width + (border_space * 2));
+        message_x = status_x + (status_width + border_space);
+        message_y = map_y + (map_height + border_space);
+        message_width = map_width;
+    }
+    else if ((status_orientation == ALIGN_LEFT) &&
+     (message_orientation == ALIGN_LEFT))
+    {
+        status_x = 0;
+        status_y = 0;
+        status_height = (term_rows - border_space);
+        status_width = 26;
+        message_x = status_x + (status_width + border_space);
+        message_y = 0;
+        message_height = status_height;
+        message_width = term_cols - (COLNO + status_width + (border_space * 3));
+        map_x = message_x + (message_width + border_space);
+        map_y = 0;
+        map_height = message_height;
+        map_width = term_cols - (status_width + message_width + (border_space * 3));
+    }
+    
+    if (map_width > COLNO)
+    {
+        map_width = COLNO;
+    }
+    
+    if (map_height > ROWNO)
+    {
+        map_height = ROWNO;
+    }
+    
+    if (curses_window_exists(STATUS_WIN))
+    {
+        curses_del_nhwin(STATUS_WIN);
+        curses_del_nhwin(MESSAGE_WIN);
+        curses_del_nhwin(MAP_WIN);
+        clear();
+    }
+
+    curses_add_nhwin(STATUS_WIN, status_height, status_width, status_y,
+     status_x, status_orientation, borders);
+
+    curses_add_nhwin(MESSAGE_WIN, message_height, message_width, message_y,
+     message_x, message_orientation, borders);
+
+    curses_add_nhwin(MAP_WIN, map_height, map_width, map_y, map_x, 0,
+     borders);
+
+    refresh();
+    
+    curses_refresh_nethack_windows();
+
+    if (iflags.window_inited)
+    {
+        curses_update_stats(TRUE);
+    }
+    else
+    {
+        iflags.window_inited = TRUE;
+    }
+}
+
+
+/* Initialize curses colors to colors used by NetHack */
+
+void curses_init_nhcolors()
+{
+#ifdef TEXTCOLOR
+    if (has_colors())
+    {
+        use_default_colors();
+        init_pair(1, COLOR_BLACK, -1);
+        init_pair(2, COLOR_RED, -1);
+        init_pair(3, COLOR_GREEN, -1);
+        init_pair(4, COLOR_YELLOW, -1);
+        init_pair(5, COLOR_BLUE, -1);
+        init_pair(6, COLOR_MAGENTA, -1);
+        init_pair(7, COLOR_CYAN, -1);
+        init_pair(8, -1, -1);
+
+        if (COLORS >= 16)
+        {
+            init_pair(9, COLOR_WHITE, -1);
+            init_pair(10, COLOR_RED + 8, -1);
+            init_pair(11, COLOR_GREEN + 8, -1);
+            init_pair(12, COLOR_YELLOW + 8, -1);
+            init_pair(13, COLOR_BLUE + 8, -1);
+            init_pair(14, COLOR_MAGENTA + 8, -1);
+            init_pair(15, COLOR_CYAN + 8, -1);
+            init_pair(16, COLOR_WHITE + 8, -1);
+        }
+
+        if (can_change_color())
+        {
+            init_color(COLOR_YELLOW, 500, 300, 0);
+            init_color(COLOR_WHITE, 600, 600, 600);
+            if (COLORS >= 16)
+            {
+                init_color(COLOR_RED + 8, 1000, 500, 0);
+                init_color(COLOR_GREEN + 8, 0, 1000, 0);
+                init_color(COLOR_YELLOW + 8, 1000, 1000, 0);
+                init_color(COLOR_BLUE + 8, 0, 0, 1000);
+                init_color(COLOR_MAGENTA + 8, 1000, 0, 1000);
+                init_color(COLOR_CYAN + 8, 0, 1000, 1000);
+                init_color(COLOR_WHITE + 8, 1000, 1000, 1000);
+#ifdef USE_DARKGRAY
+                if (COLORS > 16)
+                {
+                    init_color(CURSES_DARK_GRAY, 300, 300, 300);
+                }
+#endif
+            }
+            else
+            {
+                /* Set flag to use bold for bright colors */
+            }
+        }
+    }
+#endif
+}
+
+
+/* Allow player to pick character's role, race, gender, and alignment.
+Borrowed from the Gnome window port. */
+
+void curses_choose_character()
+{
+    int n, i, sel, count_off, pick4u;
+    int count = 0;
+    int cur_character = 0;
+    const char** choices;
+    int* pickmap;
+    char *prompt;
+    char pbuf[QBUFSZ];
+    char choice[QBUFSZ];
+    char tmpchoice[QBUFSZ];
+#ifdef TUTORIAL_MODE
+	winid win;
+	anything any;
+	menu_item *selected = 0;
+#endif
+
+	prompt = build_plselection_prompt(pbuf, QBUFSZ, flags.initrole,
+	 flags.initrace, flags.initgend, flags.initalign);
+
+    /* This part is irritating: we have to strip the choices off of
+    the string and put them in a separate string in order to use
+    curses_character_input_dialog for this prompt. */
+
+    while (cur_character != '[')
+    {
+        cur_character = prompt[count];
+        count++;
+    }
+    
+    count_off = count;
+    
+    while (cur_character != ']')
+    {
+        tmpchoice[count - count_off] = prompt[count];
+        count++;
+        cur_character = prompt[count];
+    }
+    
+    tmpchoice[count - count_off] = '\0';
+    lcase(tmpchoice);
+    
+    while (!isspace(prompt[count_off]))
+    {
+        count_off--;
+    }
+    
+    prompt[count_off] = '\0';
+    sprintf(choice, "%s%c", tmpchoice, '\033');
+    if(strchr(tmpchoice, 't'))  /* Tutorial mode */
+    {
+        mvaddstr(0, 1, "New? Press t to enter a tutorial.");
+    }
+    
+    /* Add capital letters as choices that aren't displayed */
+    
+    for (count = 0; tmpchoice[count]; count++)
+    {
+        tmpchoice[count] = toupper(tmpchoice[count]);
+    }
+    
+    sprintf(choice, "%s%s", choice, tmpchoice);
+
+    /* prevent an unnecessary prompt */
+    rigid_role_checks(); 
+    
+	if (!flags.randomall &&
+	    (flags.initrole == ROLE_NONE || flags.initrace == ROLE_NONE ||
+	     flags.initgend == ROLE_NONE || flags.initalign == ROLE_NONE))
+	{
+        pick4u = tolower(curses_character_input_dialog(prompt, choice,
+         'y'));
+    }
+    else
+    {
+        pick4u = 'y';
+    }
+    
+    if (pick4u == 'q')  /* Quit or cancelled */
+    {
+	    clearlocks();
+	    curses_bail(0);
+    }
+    
+    if (pick4u == 'y')
+    {
+        flags.randomall = TRUE;
+    }
+#ifdef TUTORIAL_MODE
+    else if (pick4u == 't') /* Tutorial mode in UnNetHack */
+    {
+	    clear();
+        mvaddstr(0, 1, "Choose a character");
+        refresh();
+	    win = curses_get_wid(NHW_MENU);
+        curses_create_nhmenu(win);
+	    any.a_int = 1;
+	    curses_add_menu(win, NO_GLYPH, &any, 'v', 0, ATR_NONE,
+		     "lawful female dwarf Valkyrie (uses melee and thrown weapons)",
+		     MENU_UNSELECTED);
+	    any.a_int = 2;
+	    curses_add_menu(win, NO_GLYPH, &any, 'w', 0, ATR_NONE,
+		     "chaotic male elf Wizard (relies mostly on spells)",
+		     MENU_UNSELECTED);
+	    any.a_int = 3;
+	    curses_add_menu(win, NO_GLYPH, &any, 'R', 0, ATR_NONE,
+		     "neutral female human Ranger (good with ranged combat)",
+		     MENU_UNSELECTED);
+	    any.a_int = 4;
+	    curses_add_menu(win, NO_GLYPH, &any, 'q', 0, ATR_NONE,
+		     "quit", MENU_UNSELECTED);
+	    curses_end_menu(win, "What character do you want to try?");
+	    n = curses_select_menu(win, PICK_ONE, &selected);
+	    destroy_nhwindow(win);
+	    if (n != 1 || selected[0].item.a_int == 4)
+	    {
+    	    clearlocks();
+    	    curses_bail(0);
+	    }
+	    switch (selected[0].item.a_int) {
+	    case 1:
+		flags.initrole = str2role("Valkyrie");
+		flags.initrace = str2race("dwarf");
+		flags.initgend = str2gend("female");
+		flags.initalign = str2align("lawful");
+		break;
+	    case 2:
+		flags.initrole = str2role("Wizard");
+		flags.initrace = str2race("elf");
+		flags.initgend = str2gend("male");
+		flags.initalign = str2align("chaotic");
+		break;
+	    case 3:
+		flags.initrole = str2role("Ranger");
+		flags.initrace = str2race("human");
+		flags.initgend = str2gend("female");
+		flags.initalign = str2align("neutral");
+		break;
+	    default: panic("Impossible menu selection"); break;
+	    }
+	    free((genericptr_t) selected);
+	    selected = 0;
+	    flags.tutorial = 1;
+	}
+#endif
+    
+    clear();
+    refresh();
+
+    if (!flags.randomall && flags.initrole < 0) {
+	/* select a role */
+	for (n = 0; roles[n].name.m; n++) continue;
+	choices = (const char **)alloc(sizeof(char *) * (n+1));
+	pickmap = (int*)alloc(sizeof(int) * (n+1));
+	for (;;) {
+	    for (n = 0, i = 0; roles[i].name.m; i++) {
+		if (ok_role(i, flags.initrace,
+			    flags.initgend, flags.initalign)) {
+		    if (flags.initgend >= 0 && flags.female && roles[i].name.f)
+			choices[n] = roles[i].name.f;
+		    else
+			choices[n] = roles[i].name.m;
+		    pickmap[n++] = i;
+		}
+	    }
+	    if (n > 0) break;
+	    else if (flags.initalign >= 0) flags.initalign = -1;    /* reset */
+	    else if (flags.initgend >= 0) flags.initgend = -1;
+	    else if (flags.initrace >= 0) flags.initrace = -1;
+	    else panic("no available ROLE+race+gender+alignment combinations");
+	}
+	choices[n] = (const char *) 0;
+	if (n > 1)
+        sel = curses_character_dialog(choices, "Choose one of the following roles:");
+	else sel = 0;
+	if (sel >= 0) sel = pickmap[sel];
+	else if (sel == ROLE_NONE) {		/* Quit */
+	    clearlocks();
+	    curses_bail(0);
+	}
+	free(choices);
+	free(pickmap);
+    } else if (flags.initrole < 0) sel = ROLE_RANDOM;
+    else sel = flags.initrole;
+  
+    if (sel == ROLE_RANDOM) {	/* Random role */
+	sel = pick_role(flags.initrace, flags.initgend,
+			  flags.initalign, PICK_RANDOM);
+	if (sel < 0) sel = randrole();
+    }
+
+    flags.initrole = sel;
+
+    /* Select a race, if necessary */
+    /* force compatibility with role, try for compatibility with
+     * pre-selected gender/alignment */
+    if (flags.initrace < 0 || !validrace(flags.initrole, flags.initrace)) {
+	if (flags.initrace == ROLE_RANDOM || flags.randomall) {
+	    flags.initrace = pick_race(flags.initrole, flags.initgend,
+				       flags.initalign, PICK_RANDOM);
+	    if (flags.initrace < 0) flags.initrace = randrace(flags.initrole);
+	} else {
+	    /* Count the number of valid races */
+	    n = 0;	/* number valid */
+	    for (i = 0; races[i].noun; i++) {
+		if (ok_race(flags.initrole, i, flags.initgend, flags.initalign))
+		    n++;
+	    }
+	    if (n == 0) {
+		for (i = 0; races[i].noun; i++) {
+		    if (validrace(flags.initrole, i)) n++;
+		}
+	    }
+
+	    choices = (const char **)alloc(sizeof(char *) * (n+1));
+	    pickmap = (int*)alloc(sizeof(int) * (n + 1));
+	    for (n = 0, i = 0; races[i].noun; i++) {
+		if (ok_race(flags.initrole, i, flags.initgend,
+			    flags.initalign)) {
+		    choices[n] = races[i].noun;
+		    pickmap[n++] = i;
+		}
+	    }
+	    choices[n] = (const char *) 0;
+	    /* Permit the user to pick, if there is more than one */
+	    if (n > 1)
+		sel = curses_character_dialog(choices, "Choose one of the following races:");
+	    else sel = 0;
+	    if (sel >= 0) sel = pickmap[sel];
+	    else if (sel == ROLE_NONE) { /* Quit */
+		clearlocks();
+		curses_bail(0);
+	    }
+	    flags.initrace = sel;
+	    free(choices);
+	    free(pickmap);
+	}
+	if (flags.initrace == ROLE_RANDOM) {	/* Random role */
+	    sel = pick_race(flags.initrole, flags.initgend,
+			    flags.initalign, PICK_RANDOM);
+	    if (sel < 0) sel = randrace(flags.initrole);
+	    flags.initrace = sel;
+	}
+    }
+
+    /* Select a gender, if necessary */
+    /* force compatibility with role/race, try for compatibility with
+     * pre-selected alignment */
+    if (flags.initgend < 0 ||
+	!validgend(flags.initrole, flags.initrace, flags.initgend)) {
+	if (flags.initgend == ROLE_RANDOM || flags.randomall) {
+	    flags.initgend = pick_gend(flags.initrole, flags.initrace,
+				       flags.initalign, PICK_RANDOM);
+	    if (flags.initgend < 0)
+		flags.initgend = randgend(flags.initrole, flags.initrace);
+	} else {
+	    /* Count the number of valid genders */
+	    n = 0;	/* number valid */
+	    for (i = 0; i < ROLE_GENDERS; i++) {
+		if (ok_gend(flags.initrole, flags.initrace, i, flags.initalign))
+		    n++;
+	    }
+	    if (n == 0) {
+		for (i = 0; i < ROLE_GENDERS; i++) {
+		    if (validgend(flags.initrole, flags.initrace, i)) n++;
+		}
+	    }
+
+	    choices = (const char **)alloc(sizeof(char *) * (n+1));
+	    pickmap = (int*)alloc(sizeof(int) * (n + 1));
+	    for (n = 0, i = 0; i < ROLE_GENDERS; i++) {
+		if (ok_gend(flags.initrole, flags.initrace, i,
+				flags.initalign)) {
+		    choices[n] = genders[i].adj;
+		    pickmap[n++] = i;
+		}
+	    }
+	    choices[n] = (const char *) 0;
+	    /* Permit the user to pick, if there is more than one */
+	    if (n > 1)
+		sel = curses_character_dialog(choices, "Choose one of the following genders:");
+	    else sel = 0;
+	    if (sel >= 0) sel = pickmap[sel];
+	    else if (sel == ROLE_NONE) { /* Quit */
+		clearlocks();
+		curses_bail(0);
+	    }
+	    flags.initgend = sel;
+	    free(choices);
+	    free(pickmap);
+	}
+	if (flags.initgend == ROLE_RANDOM) {	/* Random gender */
+	    sel = pick_gend(flags.initrole, flags.initrace,
+			    flags.initalign, PICK_RANDOM);
+	    if (sel < 0) sel = randgend(flags.initrole, flags.initrace);
+	    flags.initgend = sel;
+	}
+    }
+
+    /* Select an alignment, if necessary */
+    /* force compatibility with role/race/gender */
+    if (flags.initalign < 0 ||
+	!validalign(flags.initrole, flags.initrace, flags.initalign)) {
+	if (flags.initalign == ROLE_RANDOM || flags.randomall) {
+	    flags.initalign = pick_align(flags.initrole, flags.initrace,
+					 flags.initgend, PICK_RANDOM);
+	    if (flags.initalign < 0)
+		flags.initalign = randalign(flags.initrole, flags.initrace);
+	} else {
+	    /* Count the number of valid alignments */
+	    n = 0;	/* number valid */
+	    for (i = 0; i < ROLE_ALIGNS; i++) {
+		if (ok_align(flags.initrole, flags.initrace, flags.initgend, i))
+		    n++;
+	    }
+	    if (n == 0) {
+		for (i = 0; i < ROLE_ALIGNS; i++)
+		    if (validalign(flags.initrole, flags.initrace, i)) n++;
+	    }
+
+	    choices = (const char **)alloc(sizeof(char *) * (n+1));
+	    pickmap = (int*)alloc(sizeof(int) * (n + 1));
+	    for (n = 0, i = 0; i < ROLE_ALIGNS; i++) {
+		if (ok_align(flags.initrole,
+			     flags.initrace, flags.initgend, i)) {
+		    choices[n] = aligns[i].adj;
+		    pickmap[n++] = i;
+		}
+	    }
+	    choices[n] = (const char *) 0;
+	    /* Permit the user to pick, if there is more than one */
+	    if (n > 1)
+		sel = curses_character_dialog(choices, "Choose one of the following alignments:");
+	    else sel = 0;
+	    if (sel >= 0) sel = pickmap[sel];
+	    else if (sel == ROLE_NONE) { /* Quit */
+		clearlocks();
+		curses_bail(0);
+	    }
+	    flags.initalign = sel;
+	    free(choices);
+	    free(pickmap);
+	}
+	if (flags.initalign == ROLE_RANDOM) {
+	    sel = pick_align(flags.initrole, flags.initrace,
+			     flags.initgend, PICK_RANDOM);
+	    if (sel < 0) sel = randalign(flags.initrole, flags.initrace);
+	    flags.initalign = sel;
+	}
+    }
+}
+
+
+/* Prompt user for character race, role, alignment, or gender */
+
+int curses_character_dialog(const char** choices, const char *prompt)
+{
+    int count, count2, ret, curletter;
+    char used_letters[52];
+    anything identifier;
+    menu_item *selected = NULL;
+    winid wid = curses_get_wid(NHW_MENU);
+
+    identifier.a_void = 0;
+    curses_start_menu(wid);
+
+    for (count=0; choices[count]; count++)
+    {
+        curletter=tolower(choices[count][0]);
+        for (count2=0; count2<count; count2++)
+        {
+            if (curletter==used_letters[count2])
+            {
+                curletter=toupper(curletter);
+            }
+        }
+
+        identifier.a_int = (count + 1); /* Must be non-zero */
+        curses_add_menu(wid, NO_GLYPH, &identifier, curletter, 0,
+         A_NORMAL, choices[count], FALSE);
+        used_letters[count] = curletter;
+    }
+
+    /* Random Selection */
+    identifier.a_int = ROLE_RANDOM;
+    curses_add_menu(wid, NO_GLYPH, &identifier, '*', 0, A_NORMAL, "Random",
+     FALSE);    
+    
+    /* Quit prompt */
+    identifier.a_int = ROLE_NONE;
+    curses_add_menu(wid, NO_GLYPH, &identifier, 'q', 0, A_NORMAL, "Quit",
+     FALSE);    
+    curses_end_menu(wid, prompt);
+    ret = curses_select_menu(wid, PICK_ONE, &selected);
+    if (ret == 1)
+    {
+        ret = (selected->item.a_int);
+    }
+    else    /* Cancelled selection */
+    {
+        ret = ROLE_NONE;
+    }
+    
+    if (ret > 0)
+    {
+        ret--;
+    }
+    
+    free(selected);
+    return ret;
+}
+
+
+/* Initialize and display options appropriately */
+
+void curses_init_options()
+{
+    set_wc_option_mod_status(WC_ALIGN_MESSAGE|WC_ALIGN_STATUS|WC_COLOR|
+     WC_HILITE_PET|WC_POPUP_DIALOG, SET_IN_GAME);
+
+    set_wc2_option_mod_status(WC2_GUICOLOR, SET_IN_GAME);
+
+    /* Remove a few options that are irrelevant to this windowport */
+    set_option_mod_status("DECgraphics", SET_IN_FILE);
+    set_option_mod_status("perm_invent", SET_IN_FILE);
+    set_option_mod_status("eight_bit_tty", SET_IN_FILE);
+
+    /* Make sure that DECgraphics is not set to true via the config
+    file, as this will cause display issues.  We can't disable it in
+    options.c in case the game is compiled with both tty and curses.*/
+    if (iflags.DECgraphics)
+    {
+        switch_graphics(CURS_GRAPHICS);
+    }
+	
+#ifdef PDCURSES
+    /* PDCurses for SDL, win32 and OS/2 has the ability to set the
+     terminal size programatically.  If the user does not specify a
+     size in the config file, we will set it to a nice big 110x32 to
+     take advantage of some of the nice features of this windowport. */
+    if (iflags.wc2_term_cols == 0)
+    {
+        iflags.wc2_term_cols = 110;
+    }
+    
+    if (iflags.wc2_term_rows == 0)
+    {
+        iflags.wc2_term_rows = 32;
+    }
+    
+    resize_term(iflags.wc2_term_rows, iflags.wc2_term_cols);
+    getmaxyx(base_term, term_rows, term_cols);
+    
+    /* This is needed for an odd bug with PDCurses-SDL */
+    switch_graphics(ASCII_GRAPHICS);
+    if (iflags.IBMgraphics)
+    {
+        switch_graphics(IBM_GRAPHICS);
+    }
+    else if (iflags.cursesgraphics)
+    {
+        switch_graphics(CURS_GRAPHICS);
+    }
+    else
+    {
+        switch_graphics(ASCII_GRAPHICS);
+    }
+#endif  /* PDCURSES */
+    if (!iflags.wc2_windowborders)
+    {
+        iflags.wc2_windowborders = 3; /* Set to auto if not specified */
+    }
+    
+    if (!iflags.wc2_petattr)
+    {
+        iflags.wc2_petattr = A_REVERSE;
+    }
+    else    /* Pet attribute specified, so hilite_pet should be true */
+    {
+        iflags.hilite_pet = TRUE;
+    }
+
+#ifdef NCURSES_MOUSE_VERSION
+    if (iflags.wc_mouse_support)
+    {
+    	mousemask(BUTTON1_CLICKED, NULL);
+    }
+#endif
+}
+
+
+/* Display an ASCII splash screen if the splash_screen option is set */
+
+void curses_display_splash_window()
+{
+    int x_start = 1;
+    int y_start = 6;
+    int which_variant = NETHACK_CURSES;  /* Default to NetHack */
+
+    if ((term_cols < 70) || (term_rows < 20))
+    {
+        iflags.wc_splash_screen = FALSE;    /* No room for s.s. */
+    }
+    
+#ifdef DEF_GAME_NAME
+    if (strcmp(DEF_GAME_NAME, "SlashEM") == 0)
+    {
+        which_variant = SLASHEM_CURSES;
+    }
+#endif
+
+#ifdef GAME_SHORT_NAME
+    if (strcmp(GAME_SHORT_NAME, "UNH") == 0)
+    {
+        which_variant = UNNETHACK_CURSES;
+    }
+#endif
+
+    if (strncmp("SporkHack", COPYRIGHT_BANNER_A, 9) == 0)
+    {
+        which_variant = SPORKHACK_CURSES;
+    }
+
+    curses_toggle_color_attr(stdscr, CLR_WHITE, A_NORMAL, ON);
+
+    if (iflags.wc_splash_screen)
+    {
+        switch (which_variant)
+        {
+            case NETHACK_CURSES:
+            {
+                mvaddstr(y_start, x_start, NETHACK_SPLASH_A);
+                mvaddstr(y_start + 1, x_start, NETHACK_SPLASH_B);
+                mvaddstr(y_start + 2, x_start, NETHACK_SPLASH_C);
+                mvaddstr(y_start + 3, x_start, NETHACK_SPLASH_D);
+                mvaddstr(y_start + 4, x_start, NETHACK_SPLASH_E);
+                mvaddstr(y_start + 5, x_start, NETHACK_SPLASH_F);
+                y_start += 7;
+                break;
+            }
+            case SLASHEM_CURSES:
+            {
+                mvaddstr(y_start, x_start, SLASHEM_SPLASH_A);
+                mvaddstr(y_start + 1, x_start, SLASHEM_SPLASH_B);
+                mvaddstr(y_start + 2, x_start, SLASHEM_SPLASH_C);
+                mvaddstr(y_start + 3, x_start, SLASHEM_SPLASH_D);
+                mvaddstr(y_start + 4, x_start, SLASHEM_SPLASH_E);
+                mvaddstr(y_start + 5, x_start, SLASHEM_SPLASH_F);
+                y_start += 7;
+                break;
+            }
+            case UNNETHACK_CURSES:
+            {
+                mvaddstr(y_start, x_start, UNNETHACK_SPLASH_A);
+                mvaddstr(y_start + 1, x_start, UNNETHACK_SPLASH_B);
+                mvaddstr(y_start + 2, x_start, UNNETHACK_SPLASH_C);
+                mvaddstr(y_start + 3, x_start, UNNETHACK_SPLASH_D);
+                mvaddstr(y_start + 4, x_start, UNNETHACK_SPLASH_E);
+                mvaddstr(y_start + 5, x_start, UNNETHACK_SPLASH_F);
+                y_start += 7;
+                break;
+            }
+            case SPORKHACK_CURSES:
+                mvaddstr(y_start, x_start, SPORKHACK_SPLASH_A);
+                mvaddstr(y_start + 1, x_start, SPORKHACK_SPLASH_B);
+                mvaddstr(y_start + 2, x_start, SPORKHACK_SPLASH_C);
+                mvaddstr(y_start + 3, x_start, SPORKHACK_SPLASH_D);
+                mvaddstr(y_start + 4, x_start, SPORKHACK_SPLASH_E);
+                mvaddstr(y_start + 5, x_start, SPORKHACK_SPLASH_F);
+                mvaddstr(y_start + 6, x_start, SPORKHACK_SPLASH_G);
+                mvaddstr(y_start + 7, x_start, SPORKHACK_SPLASH_H);
+                y_start += 9;
+                break;
+            default:
+            {
+                impossible("which_variant number %d out of range",
+                 which_variant);
+            }
+        }
+    }
+
+    curses_toggle_color_attr(stdscr, CLR_WHITE, A_NORMAL, OFF);
+
+#ifdef COPYRIGHT_BANNER_A
+    mvaddstr(y_start, x_start, COPYRIGHT_BANNER_A);
+    y_start++;
+#endif
+
+#ifdef COPYRIGHT_BANNER_B
+    mvaddstr(y_start, x_start, COPYRIGHT_BANNER_B);
+    y_start++;
+#endif
+
+#ifdef COPYRIGHT_BANNER_C
+    mvaddstr(y_start, x_start, COPYRIGHT_BANNER_C);
+    y_start++;
+#endif
+
+#ifdef COPYRIGHT_BANNER_D   /* Just in case */
+    mvaddstr(y_start, x_start, COPYRIGHT_BANNER_D);
+    y_start++;
+#endif
+    refresh();
+}
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursinit.h nethack-3.4.3/win/curses/cursinit.h
--- nethack-orig/win/curses/cursinit.h	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursinit.h	2010-12-17 14:01:01.898525001 -0500
@@ -0,0 +1,19 @@
+#ifndef CURSINIT_H
+#define CURSINIT_H
+
+/* Global declarations */
+
+void curses_create_main_windows(void);
+
+void curses_init_nhcolors(void);
+
+void curses_choose_character(void);
+
+int curses_character_dialog(const char** choices, const char *prompt);
+
+void curses_init_options(void);
+
+void curses_display_splash_window(void);
+
+
+#endif  /* CURSINIT_H */
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursmain.c nethack-3.4.3/win/curses/cursmain.c
--- nethack-orig/win/curses/cursmain.c	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursmain.c	2010-12-17 14:01:01.898525001 -0500
@@ -0,0 +1,719 @@
+#include "curses.h"
+#include "hack.h"
+#include "patchlevel.h"
+#include "color.h"
+#include "wincurs.h"
+
+/* Public functions for curses NetHack interface */
+
+/* Interface definition, for windows.c */
+struct window_procs curses_procs = {
+    "curses",
+    WC_ALIGN_MESSAGE|WC_ALIGN_STATUS|WC_COLOR|WC_HILITE_PET|
+    WC_POPUP_DIALOG|WC_SPLASH_SCREEN,
+    WC2_TERM_COLS|WC2_TERM_ROWS|WC2_WINDOWBORDERS|WC2_PETATTR|
+     WC2_GUICOLOR,
+    curses_init_nhwindows,
+    curses_player_selection,
+    curses_askname,
+    curses_get_nh_event,
+    curses_exit_nhwindows,
+    curses_suspend_nhwindows,
+    curses_resume_nhwindows,
+    curses_create_nhwindow,
+    curses_clear_nhwindow,
+    curses_display_nhwindow,
+    curses_destroy_nhwindow,
+    curses_curs,
+    curses_putstr,
+    curses_display_file,
+    curses_start_menu,
+    curses_add_menu,
+    curses_end_menu,
+    curses_select_menu,
+    genl_message_menu,
+    curses_update_inventory,
+    curses_mark_synch,
+    curses_wait_synch,
+#ifdef CLIPPING
+    curses_cliparound,
+#endif
+#ifdef POSITIONBAR
+    donull,
+#endif
+    curses_print_glyph,
+    curses_raw_print,
+    curses_raw_print_bold,
+    curses_nhgetch,
+    curses_nh_poskey,
+    curses_nhbell,
+    curses_doprev_message,
+    curses_yn_function,
+    curses_getlin,
+    curses_get_ext_cmd,
+    curses_number_pad,
+    curses_delay_output,
+#ifdef CHANGE_COLOR	/* only a Mac option currently */
+    donull,
+    donull,
+#endif
+    curses_start_screen,
+    curses_end_screen,
+    genl_outrip,
+    curses_preference_update,
+};
+
+/*  
+init_nhwindows(int* argcp, char** argv)
+                -- Initialize the windows used by NetHack.  This can also
+                   create the standard windows listed at the top, but does
+                   not display them.
+                -- Any commandline arguments relevant to the windowport
+                   should be interpreted, and *argcp and *argv should
+                   be changed to remove those arguments.
+                -- When the message window is created, the variable
+                   iflags.window_inited needs to be set to TRUE.  Otherwise
+                   all plines() will be done via raw_print().
+                ** Why not have init_nhwindows() create all of the "standard"
+                ** windows?  Or at least all but WIN_INFO?      -dean
+*/
+void curses_init_nhwindows(int* argcp, char** argv)
+{
+#ifdef PDCURSES
+    char window_title[BUFSZ];
+#endif
+
+#ifdef XCURSES
+    base_term = Xinitscr(*argcp, argv);
+#else
+    base_term = initscr();
+#endif
+#ifdef TEXTCOLOR
+    if (has_colors())
+    {
+        start_color();
+        curses_init_nhcolors();
+    }
+    else
+    {
+        iflags.use_color = FALSE;
+        set_option_mod_status("color", SET_IN_FILE);
+        iflags.wc2_guicolor = FALSE;
+        set_wc2_option_mod_status(WC2_GUICOLOR, SET_IN_FILE);    
+    }
+#else
+    iflags.use_color = FALSE;
+    set_option_mod_status("color", SET_IN_FILE);    
+    iflags.wc2_guicolor = FALSE;
+    set_wc2_option_mod_status(WC2_GUICOLOR, SET_IN_FILE);    
+#endif
+    noecho();
+    raw();
+    meta(stdscr, TRUE);
+    curs_set(0);
+    keypad(stdscr, TRUE);
+#ifdef NCURSES_VERSION
+# ifdef __APPLE__
+ ESCDELAY = 25;
+# else
+    set_escdelay(25);
+# endif /* __APPLE__ */
+#endif  /* NCURSES_VERSION */
+#ifdef PDCURSES
+# ifdef DEF_GAME_NAME
+#  ifdef VERSION_STRING
+    sprintf(window_title, "%s %s", DEF_GAME_NAME, VERSION_STRING);
+#  else
+    sprintf(window_title, "%s", DEF_GAME_NAME);
+#  endif /* VERSION_STRING */
+# else
+#  ifdef VERSION_STRING
+    sprintf(window_title, "%s %s", "NetHack", VERSION_STRING);
+#  else
+    sprintf(window_title, "%s", "NetHack");
+#  endif /* VERSION_STRING */
+# endif /* DEF_GAME_NAME */
+    PDC_set_title(window_title);
+    PDC_set_blink(TRUE);    /* Only if the user asks for it! */
+    timeout(1);
+    (void)getch();
+    timeout(-1);
+#endif  /* PDCURSES */
+    getmaxyx(base_term, term_rows, term_cols);
+    counting = FALSE;
+    curses_init_options();
+    if ((term_rows < 15) || (term_cols < 40))
+    {
+        panic("Terminal too small.  Must be minumum 40 width and 15 height");
+    }
+
+    curses_create_main_windows();
+    curses_init_mesg_history();
+    curses_display_splash_window();
+}
+
+
+/* Do a window-port specific player type selection. If player_selection()
+   offers a Quit option, it is its responsibility to clean up and terminate
+   the process. You need to fill in pl_character[0].
+*/
+void curses_player_selection()
+{
+    curses_choose_character();
+}
+
+
+/* Ask the user for a player name. */
+void curses_askname()
+{
+    curses_line_input_dialog("Who are you?", plname, PL_NSIZ);
+}
+
+
+/* Does window event processing (e.g. exposure events).
+   A noop for the tty and X window-ports.
+*/
+void curses_get_nh_event()
+{
+#ifdef PDCURSES
+    if (is_termresized())
+    {
+        resize_term(0, 0);
+        getmaxyx(base_term, term_rows, term_cols);
+        curses_create_main_windows();
+        curses_last_messages();
+        doredraw();
+    }
+#endif
+#ifdef NCURSES_VERSION  /* Is there a better way to detect ncurses? */
+    if (is_term_resized(term_rows, term_cols))
+    {
+        if (!isendwin())
+        {
+            endwin();
+        }
+        
+        refresh();
+        getmaxyx(base_term, term_rows, term_cols);
+        curses_create_main_windows();
+        curses_last_messages();
+        doredraw();
+    }
+#endif
+}
+
+/* Exits the window system.  This should dismiss all windows,
+   except the "window" used for raw_print().  str is printed if possible.
+*/
+void curses_exit_nhwindows(const char *str)
+{
+    endwin();
+    iflags.window_inited = 0;
+    if (str != NULL)
+    {
+        raw_print(str);
+    }
+}
+
+/* Prepare the window to be suspended. */
+void curses_suspend_nhwindows(const char *str)
+{
+}
+
+
+/* Restore the windows after being suspended. */
+void curses_resume_nhwindows()
+{
+    curses_refresh_nethack_windows();
+}
+
+/*  Create a window of type "type" which can be 
+        NHW_MESSAGE     (top line)
+        NHW_STATUS      (bottom lines)
+        NHW_MAP         (main dungeon)
+        NHW_MENU        (inventory or other "corner" windows)
+        NHW_TEXT        (help/text, full screen paged window)
+*/
+winid curses_create_nhwindow(int type)
+{
+    winid wid = curses_get_wid(type);
+
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        curses_start_menu(wid);
+        curses_add_wid(wid);
+    }
+    
+    return wid;
+}
+
+
+/* Clear the given window, when asked to. */
+void curses_clear_nhwindow(winid wid)
+{
+    if (wid != NHW_MESSAGE)
+    {
+        curses_clear_nhwin(wid);
+    }
+}
+
+/* -- Display the window on the screen.  If there is data
+                   pending for output in that window, it should be sent.
+                   If blocking is TRUE, display_nhwindow() will not
+                   return until the data has been displayed on the screen,
+                   and acknowledged by the user where appropriate.
+                -- All calls are blocking in the tty window-port.
+                -- Calling display_nhwindow(WIN_MESSAGE,???) will do a
+                   --more--, if necessary, in the tty window-port.
+*/
+void curses_display_nhwindow(winid wid, BOOLEAN_P block)
+{
+    menu_item *selected = NULL;
+    
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        curses_end_menu(wid, "");
+        curses_select_menu(wid, PICK_NONE, &selected);
+        return;
+    }
+    
+    if ((wid == MAP_WIN) && (curses_window_exists(MAP_WIN)) && block)
+    {
+        (void) curses_more();
+    }
+}
+
+
+/* Destroy will dismiss the window if the window has not 
+ * already been dismissed.
+*/
+void curses_destroy_nhwindow(winid wid)
+{
+    curses_del_nhwin(wid);
+}
+
+/* Next output to window will start at (x,y), also moves
+ displayable cursor to (x,y).  For backward compatibility,
+ 1 <= x < cols, 0 <= y < rows, where cols and rows are
+ the size of window.
+*/
+void curses_curs(winid wid, int x, int y)
+{
+    curses_move_cursor(wid, x, y);
+}
+
+/*
+putstr(window, attr, str)
+                -- Print str on the window with the given attribute.  Only
+                   printable ASCII characters (040-0126) must be supported.
+                   Multiple putstr()s are output on separate lines.
+Attributes
+                   can be one of
+                        ATR_NONE (or 0)
+                        ATR_ULINE
+                        ATR_BOLD
+                        ATR_BLINK
+                        ATR_INVERSE
+                   If a window-port does not support all of these, it may map
+                   unsupported attributes to a supported one (e.g. map them
+                   all to ATR_INVERSE).  putstr() may compress spaces out of
+                   str, break str, or truncate str, if necessary for the
+                   display.  Where putstr() breaks a line, it has to clear
+                   to end-of-line.
+                -- putstr should be implemented such that if two putstr()s
+                   are done consecutively the user will see the first and
+                   then the second.  In the tty port, pline() achieves this
+                   by calling more() or displaying both on the same line.
+*/
+void curses_putstr(winid wid, int attr, const char *text)
+{
+    int curses_attr = curses_convert_attr(attr);
+    
+    /* We need to convert NetHack attributes to curses attributes */
+    curses_puts(wid, curses_attr, text);
+}
+
+/* Display the file named str.  Complain about missing files
+                   iff complain is TRUE.
+*/
+void curses_display_file(const char *filename,BOOLEAN_P must_exist)
+{
+    curses_view_file(filename, must_exist);
+}
+
+/* Start using window as a menu.  You must call start_menu()
+   before add_menu().  After calling start_menu() you may not
+   putstr() to the window.  Only windows of type NHW_MENU may
+   be used for menus.
+*/
+void curses_start_menu(winid wid)
+{
+    curses_create_nhmenu(wid);
+}
+
+/*
+add_menu(winid wid, int glyph, const anything identifier,
+                                char accelerator, char groupacc,
+                                int attr, char *str, boolean preselected)
+                -- Add a text line str to the given menu window.  If identifier
+                   is 0, then the line cannot be selected (e.g. a title).
+                   Otherwise, identifier is the value returned if the line is
+                   selected.  Accelerator is a keyboard key that can be used
+                   to select the line.  If the accelerator of a selectable
+                   item is 0, the window system is free to select its own
+                   accelerator.  It is up to the window-port to make the
+                   accelerator visible to the user (e.g. put "a - " in front
+                   of str).  The value attr is the same as in putstr().
+                   Glyph is an optional glyph to accompany the line.  If
+                   window port cannot or does not want to display it, this
+                   is OK.  If there is no glyph applicable, then this
+                   value will be NO_GLYPH.
+                -- All accelerators should be in the range [A-Za-z].
+                -- It is expected that callers do not mix accelerator
+                   choices.  Either all selectable items have an accelerator
+                   or let the window system pick them.  Don't do both.
+                -- Groupacc is a group accelerator.  It may be any character
+                   outside of the standard accelerator (see above) or a
+                   number.  If 0, the item is unaffected by any group
+                   accelerator.  If this accelerator conflicts with
+                   the menu command (or their user defined alises), it loses.
+                   The menu commands and aliases take care not to interfere
+                   with the default object class symbols.
+                -- If you want this choice to be preselected when the
+                   menu is displayed, set preselected to TRUE.
+*/
+void curses_add_menu(winid wid, int glyph, const ANY_P * identifier,
+		CHAR_P accelerator, CHAR_P group_accel, int attr, 
+		const char *str, BOOLEAN_P presel)
+{
+    int curses_attr = curses_convert_attr(attr);
+
+    curses_add_nhmenu_item(wid, identifier, accelerator, group_accel,
+     curses_attr, str, presel);
+}
+
+/*
+end_menu(window, prompt)
+                -- Stop adding entries to the menu and flushes the window
+                   to the screen (brings to front?).  Prompt is a prompt
+                   to give the user.  If prompt is NULL, no prompt will
+                   be printed.
+                ** This probably shouldn't flush the window any more (if
+                ** it ever did).  That should be select_menu's job.  -dean
+*/
+void curses_end_menu(winid wid, const char *prompt)
+{
+    curses_finalize_nhmenu(wid, prompt);
+}
+
+/*
+int select_menu(winid window, int how, menu_item **selected)
+                -- Return the number of items selected; 0 if none were chosen,
+                   -1 when explicitly cancelled.  If items were selected, then
+                   selected is filled in with an allocated array of menu_item
+                   structures, one for each selected line.  The caller must
+                   free this array when done with it.  The "count" field
+                   of selected is a user supplied count.  If the user did
+                   not supply a count, then the count field is filled with
+                   -1 (meaning all).  A count of zero is equivalent to not
+                   being selected and should not be in the list.  If no items
+                   were selected, then selected is NULL'ed out.  How is the
+                   mode of the menu.  Three valid values are PICK_NONE,
+                   PICK_ONE, and PICK_N, meaning: nothing is selectable,
+                   only one thing is selectable, and any number valid items
+                   may selected.  If how is PICK_NONE, this function should
+                   never return anything but 0 or -1.
+                -- You may call select_menu() on a window multiple times --
+                   the menu is saved until start_menu() or destroy_nhwindow()
+                   is called on the window.
+                -- Note that NHW_MENU windows need not have select_menu()
+                   called for them. There is no way of knowing whether
+                   select_menu() will be called for the window at
+                   create_nhwindow() time.
+*/
+int curses_select_menu(winid wid, int how, MENU_ITEM_P **selected)
+{
+    return curses_display_nhmenu(wid, how, selected);
+}
+
+/*
+    -- Indicate to the window port that the inventory has been changed.
+    -- Merely calls display_inventory() for window-ports that leave the 
+	window up, otherwise empty.
+*/
+void curses_update_inventory()
+{
+}
+
+/*
+mark_synch()    -- Don't go beyond this point in I/O on any channel until
+                   all channels are caught up to here.  Can be an empty call
+                   for the moment
+*/
+void curses_mark_synch()
+{
+}
+
+/*
+wait_synch()    -- Wait until all pending output is complete (*flush*() for
+                   streams goes here).
+                -- May also deal with exposure events etc. so that the
+                   display is OK when return from wait_synch().
+*/
+void curses_wait_synch()
+{
+}
+
+/*
+cliparound(x, y)-- Make sure that the user is more-or-less centered on the
+                   screen if the playing area is larger than the screen.
+                -- This function is only defined if CLIPPING is defined.
+*/
+void curses_cliparound(int x, int y)
+{
+    int sx, sy, ex, ey;
+    boolean redraw = curses_map_borders(&sx, &sy, &ex, &ey, x, y);
+    
+    if (redraw)
+    {
+        curses_draw_map(sx, sy, ex, ey);
+    }
+}
+
+/*
+print_glyph(window, x, y, glyph)
+                -- Print the glyph at (x,y) on the given window.  Glyphs are
+                   integers at the interface, mapped to whatever the window-
+                   port wants (symbol, font, color, attributes, ...there's
+                   a 1-1 map between glyphs and distinct things on the map).
+*/
+void curses_print_glyph(winid wid, XCHAR_P x, XCHAR_P y, int glyph)
+{
+    int ch, color;
+    unsigned int special;
+    int attr = -1;
+
+    /* map glyph to character and color */
+    mapglyph(glyph, &ch, &color, &special, x, y);
+    if ((special & MG_PET) && iflags.hilite_pet)
+    {
+        attr = iflags.wc2_petattr;
+    }
+    if ((special & MG_DETECT) && iflags.use_inverse)
+	{
+	    attr = A_REVERSE;
+	}
+	if (iflags.cursesgraphics)
+	{
+	    ch = curses_convert_glyph(ch, glyph);
+	}
+    curses_putch(wid, x, y, ch, color, attr);
+}
+
+/*
+raw_print(str)  -- Print directly to a screen, or otherwise guarantee that
+                   the user sees str.  raw_print() appends a newline to str.
+                   It need not recognize ASCII control characters.  This is
+                   used during startup (before windowing system initialization
+                   -- maybe this means only error startup messages are raw),
+                   for error messages, and maybe other "msg" uses.  E.g.
+                   updating status for micros (i.e, "saving").
+*/
+void curses_raw_print(const char *str)
+{
+    puts(str);
+}
+
+/*
+raw_print_bold(str)
+            -- Like raw_print(), but prints in bold/standout (if possible).
+*/
+void curses_raw_print_bold(const char *str)
+{
+    curses_raw_print(str);
+}
+
+/*
+int nhgetch()   -- Returns a single character input from the user.
+                -- In the tty window-port, nhgetch() assumes that tgetch()
+                   will be the routine the OS provides to read a character.
+                   Returned character _must_ be non-zero.
+*/
+int curses_nhgetch()
+{    
+    int ch;
+    
+    curses_prehousekeeping();
+    ch = curses_read_char();
+    curses_posthousekeeping();
+    
+    return ch;
+}
+
+/*
+int nh_poskey(int *x, int *y, int *mod)
+                -- Returns a single character input from the user or a
+                   a positioning event (perhaps from a mouse).  If the
+                   return value is non-zero, a character was typed, else,
+                   a position in the MAP window is returned in x, y and mod.
+                   mod may be one of
+
+                        CLICK_1         -- mouse click type 1 
+                        CLICK_2         -- mouse click type 2 
+
+                   The different click types can map to whatever the
+                   hardware supports.  If no mouse is supported, this
+                   routine always returns a non-zero character.
+*/
+int curses_nh_poskey(int *x, int *y, int *mod)
+{
+    int key = curses_nhgetch();
+    
+#ifdef NCURSES_MOUSE_VERSION
+    /* Mouse event if mouse_support is true */
+    if (key == KEY_MOUSE)
+    {
+        key = curses_get_mouse(x, y, mod);
+    }
+#endif
+
+    return key;
+}
+
+/*
+nhbell()        -- Beep at user.  [This will exist at least until sounds are
+                   redone, since sounds aren't attributable to windows anyway.]
+*/
+void curses_nhbell()
+{
+    beep();
+}
+
+/*
+doprev_message()
+                -- Display previous messages.  Used by the ^P command.
+                -- On the tty-port this scrolls WIN_MESSAGE back one line.
+*/
+int curses_doprev_message()
+{
+    curses_prev_mesg();
+    return 0;
+}
+
+/*
+char yn_function(const char *ques, const char *choices, char default)
+                -- Print a prompt made up of ques, choices and default.
+                   Read a single character response that is contained in
+                   choices or default.  If choices is NULL, all possible
+                   inputs are accepted and returned.  This overrides
+                   everything else.  The choices are expected to be in
+                   lower case.  Entering ESC always maps to 'q', or 'n',
+                   in that order, if present in choices, otherwise it maps
+                   to default.  Entering any other quit character (SPACE,
+                   RETURN, NEWLINE) maps to default.
+                -- If the choices string contains ESC, then anything after
+                   it is an acceptable response, but the ESC and whatever
+                   follows is not included in the prompt.
+                -- If the choices string contains a '#' then accept a count.
+                   Place this value in the global "yn_number" and return '#'.
+                -- This uses the top line in the tty window-port, other
+                   ports might use a popup.
+*/
+char curses_yn_function(const char *question, const char *choices, CHAR_P def)
+{
+    return (char)curses_character_input_dialog(question, choices, def);
+}
+
+/*
+getlin(const char *ques, char *input)
+	    -- Prints ques as a prompt and reads a single line of text,
+	       up to a newline.  The string entered is returned without the
+	       newline.  ESC is used to cancel, in which case the string
+	       "\033\000" is returned.
+	    -- getlin() must call flush_screen(1) before doing anything.
+	    -- This uses the top line in the tty window-port, other
+	       ports might use a popup.
+*/
+void curses_getlin(const char *question, char *input)
+{
+    curses_line_input_dialog(question, input, BUFSZ);
+}
+
+/*
+int get_ext_cmd(void)
+	    -- Get an extended command in a window-port specific way.
+	       An index into extcmdlist[] is returned on a successful
+	       selection, -1 otherwise.
+*/
+int curses_get_ext_cmd()
+{
+    return curses_ext_cmd();
+}
+
+
+/*
+number_pad(state)
+	    -- Initialize the number pad to the given state.
+*/
+void curses_number_pad(int state)
+{
+}
+
+/*
+delay_output()  -- Causes a visible delay of 50ms in the output.
+	       Conceptually, this is similar to wait_synch() followed
+	       by a nap(50ms), but allows asynchronous operation.
+*/
+void curses_delay_output()
+{
+    napms(50);
+}
+
+/*
+start_screen()  -- Only used on Unix tty ports, but must be declared for
+	       completeness.  Sets up the tty to work in full-screen
+	       graphics mode.  Look at win/tty/termcap.c for an
+	       example.  If your window-port does not need this function
+	       just declare an empty function.
+*/
+void curses_start_screen()
+{
+}
+
+/*
+end_screen()    -- Only used on Unix tty ports, but must be declared for
+	       completeness.  The complement of start_screen().
+*/
+void curses_end_screen()
+{
+}
+
+/*
+outrip(winid, int)
+	    -- The tombstone code.  If you want the traditional code use
+	       genl_outrip for the value and check the #if in rip.c.
+*/
+void curses_outrip(winid wid, int how)
+{
+}
+
+/*
+preference_update(preference)
+		-- The player has just changed one of the wincap preference
+		   settings, and the NetHack core is notifying your window
+		   port of that change.  If your window-port is capable of
+		   dynamically adjusting to the change then it should do so.
+		   Your window-port will only be notified of a particular
+		   change if it indicated that it wants to be by setting the 
+		   corresponding bit in the wincap mask.
+*/
+void curses_preference_update(const char *pref)
+{
+    if ((strcmp(pref, "align_status") == 0) ||
+     (strcmp(pref, "align_message") == 0))
+    {
+        curses_create_main_windows();
+        curses_last_messages();
+        doredraw();
+    }
+}
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursmesg.c nethack-3.4.3/win/curses/cursmesg.c
--- nethack-orig/win/curses/cursmesg.c	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursmesg.c	2010-12-17 14:01:01.908525001 -0500
@@ -0,0 +1,485 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursmesg.h"
+
+/* Message window routines for curses interface */
+
+/* Private declatations */
+
+typedef struct nhpm
+{
+    char *str;  /* Message text */
+    long turn;  /* Turn number for message */
+    struct nhpm *prev_mesg;    /* Pointer to previous message */
+    struct nhpm *next_mesg;    /* Pointer to next message */
+} nhprev_mesg;
+
+static void scroll_window(winid wid);
+
+static void mesg_add_line(char *mline);
+
+static nhprev_mesg *get_msg_line(boolean reverse, int mindex);
+
+static int turn_lines = 1;
+static int mx = 0;
+static int my = 0;  /* message window text location */
+static nhprev_mesg *first_mesg = NULL;
+static nhprev_mesg *last_mesg = NULL;
+static int max_messages;
+static int num_messages = 0;
+
+
+
+/* Write a string to the message window.  Attributes set by calling function. */
+
+void curses_message_win_puts(const char *message, boolean recursed)
+{
+    int height, width, linespace;
+    char *tmpstr;
+    WINDOW *win = curses_get_nhwin(MESSAGE_WIN);
+    boolean border = curses_window_has_border(MESSAGE_WIN);
+    int message_length = strlen(message);
+    int border_space = 0;
+    static long suppress_turn = -1;
+
+    if (strncmp("Count:", message, 6) == 0)
+    {
+        curses_count_window(message);
+        return;
+    }
+    
+    if (suppress_turn == moves)
+    {
+        return;
+    }
+    
+    curses_get_window_size(MESSAGE_WIN, &height, &width);
+    if (border)
+    {
+        border_space = 1;
+        if (mx < 1)
+        {
+            mx = 1;
+        }
+        if (my < 1)
+        {
+            my = 1;
+        }
+    }
+    
+    linespace = ((width + border_space) - 3) - mx;
+    
+    if (strcmp(message, "#") == 0)  /* Extended command or Count: */
+    {
+        if ((strcmp(toplines, "#") != 0) && (my >= (height - 1 +
+         border_space)) && (height != 1)) /* Bottom of message window */
+        {
+            scroll_window(MESSAGE_WIN);
+            mx = width;
+            my--;
+            strcpy(toplines, message);
+        }
+        
+        return;
+    }
+
+    if (!recursed)
+    {
+        strcpy(toplines, message);
+        mesg_add_line((char *) message);
+    }
+    
+    if (linespace < message_length)
+    {
+        if (my >= (height - 1 + border_space)) /* bottom of message win */
+        {
+            if ((turn_lines > height) || (height == 1))
+            {
+                /* Pause until key is hit - Esc suppresses any further
+                messages that turn */
+                if (curses_more() == '\033')
+                {
+                    suppress_turn = moves;
+                    return;
+                }
+            }
+            else
+            {
+                scroll_window(MESSAGE_WIN);
+                turn_lines++;
+            }
+        }
+        else
+        {
+            if (mx != border_space)
+            {
+                my++;
+                mx = border_space;
+            }
+        }
+    }
+
+    if (height > 1)
+    {
+        curses_toggle_color_attr(win, NONE, A_BOLD, ON);
+    }
+    
+    if ((mx == border_space) && ((message_length + 2) > width))
+    {
+        tmpstr = curses_break_str(message, (width - 2), 1);
+        mvwprintw(win, my, mx, tmpstr);
+        mx += strlen(tmpstr);
+        if (strlen(tmpstr) < (width - 2))
+        {
+            mx++;
+        }
+        free(tmpstr);
+        if (height > 1)
+        {
+            curses_toggle_color_attr(win, NONE, A_BOLD, OFF);
+        }
+        wrefresh(win);
+        curses_message_win_puts(curses_str_remainder(message, (width - 2), 1),
+         TRUE);
+    }
+    else
+    {
+        mvwprintw(win, my, mx, message);
+        curses_toggle_color_attr(win, NONE, A_BOLD, OFF);
+        mx += message_length + 1;
+    }
+    wrefresh(win);
+}
+
+
+int curses_more()
+{
+    int height, width, ret;
+    WINDOW *win = curses_get_nhwin(MESSAGE_WIN);
+    
+    curses_get_window_size(MESSAGE_WIN, &height, &width);
+    curses_toggle_color_attr(win, MORECOLOR, NONE, ON);
+    mvwprintw(win, my, mx, ">>");
+    curses_toggle_color_attr(win, MORECOLOR, NONE, OFF);
+    wrefresh(win);
+    ret = wgetch(win);
+    if (height == 1)
+    {
+        curses_clear_unhighlight_message_window();
+    }
+    else
+    {
+        mvwprintw(win, my, mx, "  ");
+        scroll_window(MESSAGE_WIN);
+        turn_lines = 1;
+    }
+    
+    return ret;
+}
+
+
+/* Clear the message window if one line; otherwise unhighlight old messages */
+
+void curses_clear_unhighlight_message_window()
+{
+    int mh, mw, count;
+    boolean border = curses_window_has_border(MESSAGE_WIN);
+    WINDOW *win = curses_get_nhwin(MESSAGE_WIN);
+
+    turn_lines = 1;
+    
+    curses_get_window_size(MESSAGE_WIN, &mh, &mw); 
+    
+    mx = 0;
+    
+    if (border)
+    {
+        mx++;
+    }
+       
+    if (mh == 1)
+    {
+        curses_clear_nhwin(MESSAGE_WIN);
+    }
+    else
+    {
+        mx += mw;    /* Force new line on new turn */
+        
+        if (border)
+        {
+
+            for (count = 0; count < mh; count++)
+            {
+                mvwchgat(win, count+1, 1, mw, COLOR_PAIR(8), A_NORMAL, NULL);
+            }
+        }
+        else
+        {
+            for (count = 0; count < mh; count++)
+            {
+                mvwchgat(win, count, 0, mw, COLOR_PAIR(8), A_NORMAL, NULL);
+            }
+        }
+
+        wrefresh(win);
+    }
+}
+
+
+/* Reset message window cursor to starting position, and display most
+recent messages. */
+
+void curses_last_messages()
+{
+    boolean border = curses_window_has_border(MESSAGE_WIN);
+
+    if (border)
+    {
+        mx = 1;
+        my = 1;
+    }
+    else
+    {
+        mx = 0;
+        my = 0;
+    }
+    
+    pline("%s", toplines);
+}
+
+
+/* Initialize list for message history */
+
+void curses_init_mesg_history()
+{
+    max_messages = iflags.msg_history;
+    
+    if (max_messages < 1)
+    {
+        max_messages = 1;
+    }
+
+    if (max_messages > MESG_HISTORY_MAX)
+    {
+        max_messages = MESG_HISTORY_MAX;
+    }
+}
+
+
+/* Display previous message window messages in reverse chron order */
+
+void curses_prev_mesg()
+{
+    int count;
+    winid wid;
+    long turn = 0;
+    anything *identifier;
+    nhprev_mesg *mesg;
+    menu_item *selected = NULL;
+
+    wid = curses_get_wid(NHW_MENU);
+    curses_create_nhmenu(wid);
+    identifier = malloc(sizeof(anything));
+    identifier->a_void = NULL;
+    
+    for (count = 0; count < num_messages; count++)
+    {
+        mesg = get_msg_line(TRUE, count);
+        if ((turn != mesg->turn) && (count != 0))
+        {
+            curses_add_menu(wid, NO_GLYPH, identifier, 0, 0, A_NORMAL,
+             "---", FALSE);
+        }
+        curses_add_menu(wid, NO_GLYPH, identifier, 0, 0, A_NORMAL,
+         mesg->str, FALSE);
+        turn = mesg->turn;
+    }
+    
+    curses_end_menu(wid, "");
+    curses_select_menu(wid, PICK_NONE, &selected);
+}
+
+
+/* Shows Count: in a separate window, or at the bottom of the message
+window, depending on the user's settings */
+
+void curses_count_window(const char *count_text)
+{
+    int startx, starty, winx, winy;
+    int messageh, messagew;
+    static WINDOW *countwin = NULL;
+
+    if ((count_text == NULL) && (countwin != NULL))
+    {
+        delwin(countwin);
+        countwin = NULL;
+        counting = FALSE;
+        return;
+    }
+    
+    counting = TRUE;
+
+    if (iflags.wc_popup_dialog) /* Display count in popup window */
+    {
+        startx = 1;
+        starty = 1;
+        
+        if (countwin == NULL)
+        {
+            countwin = curses_create_window(25, 1, UP);
+        }
+    
+    }
+    else /* Display count at bottom of message window */
+    {
+        curses_get_window_xy(MESSAGE_WIN, &winx, &winy);
+        curses_get_window_size(MESSAGE_WIN, &messageh, &messagew);
+        
+        if (curses_window_has_border(MESSAGE_WIN))
+        {
+            winx++;
+            winy++;
+        }
+        
+        winy += messageh - 1;
+        
+        if (countwin == NULL)
+        {
+            pline("#");
+#ifndef PDCURSES
+            countwin = newwin(1, 25, winy, winx);
+#endif  /* !PDCURSES */
+        }
+#ifdef PDCURSES
+        else
+        {
+            curses_destroy_win(countwin);
+        }
+        
+        countwin = newwin(1, 25, winy, winx);
+#endif  /* PDCURSES */
+        startx = 0;
+        starty = 0;
+    }
+    
+    mvwprintw(countwin, starty, startx, "%s", count_text);
+    wrefresh(countwin);
+}
+
+
+/* Scroll lines upward in given window, or clear window if only one line. */
+
+static void scroll_window(winid wid)
+{
+    int wh, ww, s_top, s_bottom;
+    boolean border = curses_window_has_border(wid);
+    WINDOW *win = curses_get_nhwin(wid);
+    
+    curses_get_window_size(wid, &wh, &ww);
+    if (wh == 1)
+    {
+        curses_clear_nhwin(wid);
+        return;
+    }
+    if (border)
+    {
+        s_top = 1;
+        s_bottom = wh;
+    }
+    else
+    {
+        s_top = 0;
+        s_bottom = wh - 1;
+    }
+    scrollok(win, TRUE);
+    wsetscrreg(win, s_top, s_bottom);
+    scroll(win);
+    scrollok(win, FALSE);
+    if (wid == MESSAGE_WIN)
+    {
+        if (border)
+            mx = 1;
+        else
+            mx = 0;
+    }
+    if (border)
+    {
+        box(win, 0, 0);
+    }
+    wrefresh(win);
+}
+
+
+/* Add given line to message history */
+
+static void mesg_add_line(char *mline)
+{
+    nhprev_mesg *tmp_mesg = NULL;
+    nhprev_mesg *current_mesg = malloc(sizeof(nhprev_mesg));
+
+    current_mesg->str = curses_copy_of(mline);
+    current_mesg->turn = moves;
+    current_mesg->next_mesg = NULL;
+
+    if (num_messages == 0)
+    {
+        first_mesg = current_mesg;
+    }
+    
+    if (last_mesg != NULL)
+    {
+        last_mesg->next_mesg = current_mesg;
+    }
+    current_mesg->prev_mesg = last_mesg;
+    last_mesg = current_mesg;
+
+
+    if (num_messages < max_messages)
+    {
+        num_messages++;
+    }
+    else
+    {
+        tmp_mesg = first_mesg->next_mesg;
+        free(first_mesg);
+        first_mesg = tmp_mesg;
+    }
+}
+
+
+/* Returns specified line from message history, or NULL if out of bounds */
+
+static nhprev_mesg *get_msg_line(boolean reverse, int mindex)
+{
+    int count;
+    nhprev_mesg *current_mesg;
+
+    if (reverse)
+    {
+        current_mesg = last_mesg;
+        for (count = 0; count < mindex; count++)
+        {
+            if (current_mesg == NULL)
+            {
+                return NULL;
+            }
+            current_mesg = current_mesg->prev_mesg;
+        }
+        return current_mesg;
+    }
+    else
+    {
+        current_mesg = first_mesg;
+        for (count = 0; count < mindex; count++)
+        {
+            if (current_mesg == NULL)
+            {
+                return NULL;
+            }
+            current_mesg = current_mesg->next_mesg;
+        }
+        return current_mesg;
+    }
+}
+
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursmesg.h nethack-3.4.3/win/curses/cursmesg.h
--- nethack-orig/win/curses/cursmesg.h	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursmesg.h	2010-12-17 14:01:01.908525001 -0500
@@ -0,0 +1,21 @@
+#ifndef CURSMESG_H
+#define CURSMESG_H
+
+
+/* Global declarations */
+
+void curses_message_win_puts(const char *message, boolean recursed);
+
+int curses_more(void);
+
+void curses_clear_unhighlight_message_window(void);
+
+void curses_last_messages(void);
+
+void curses_init_mesg_history(void);
+
+void curses_prev_mesg(void);
+
+void curses_count_window(const char *count_text);
+
+#endif  /* CURSMESG_H */
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursmisc.c nethack-3.4.3/win/curses/cursmisc.c
--- nethack-orig/win/curses/cursmisc.c	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursmisc.c	2010-12-17 14:01:01.908525001 -0500
@@ -0,0 +1,1003 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursmisc.h"
+#include "func_tab.h"
+#include "dlb.h"
+
+#include <ctype.h>
+
+/* Misc. curses interface functions */
+
+/* Private declarations */
+
+static int curs_x = -1;
+static int curs_y = -1;
+
+static int parse_escape_sequence(void);
+
+/* Macros for Control and Alt keys */
+
+#ifndef M
+# ifndef NHSTDC
+#  define M(c)		(0x80 | (c))
+# else
+#  define M(c)		((c) - 128)
+# endif /* NHSTDC */
+#endif
+#ifndef C
+#define C(c)		(0x1f & (c))
+#endif
+
+
+/* Read a character of input from the user */
+
+int curses_read_char()
+{
+    int ch, tmpch;
+    
+    ch = getch();
+    tmpch = ch;
+    ch = curses_convert_keys(ch);
+
+    if (ch == 0)
+    {
+        ch = '\033'; /* map NUL to ESC since nethack doesn't expect NUL */
+    }
+
+#if defined(ALT_0) && defined(ALT_9)    /* PDCurses, maybe others */    
+    if ((ch >= ALT_0) && (ch <= ALT_9))
+    {
+        tmpch = (ch - ALT_0) + '0';
+        ch = M(tmpch);
+    }
+#endif
+
+#if defined(ALT_A) && defined(ALT_Z)    /* PDCurses, maybe others */    
+    if ((ch >= ALT_A) && (ch <= ALT_Z))
+    {
+        tmpch = (ch - ALT_A) + 'a';
+        ch = M(tmpch);
+    }
+#endif
+
+#ifdef KEY_RESIZE
+    /* Handle resize events via get_nh_event, not this code */
+    if (ch == KEY_RESIZE)
+    {
+        ch = '\033'; /* NetHack doesn't know what to do with KEY_RESIZE */
+    }
+#endif
+
+    if (counting && !isdigit(ch)) /* Dismiss count window if necissary */
+    {
+        curses_count_window(NULL);
+        curses_refresh_nethack_windows();
+    }
+
+    return ch;
+}
+
+/* Turn on or off the specified color and / or attribute */
+
+void curses_toggle_color_attr(WINDOW *win, int color, int attr, int onoff)
+{
+#ifdef TEXTCOLOR
+    int curses_color;
+
+    /* Map color disabled */
+    if ((!iflags.wc_color) && (win == mapwin))
+    {
+        return;
+    }
+    
+    /* GUI color disabled */
+    if ((!iflags.wc2_guicolor) && (win != mapwin))
+    {
+        return;
+    }
+    
+    if (color == 0) /* make black fg visible */
+    {
+#ifdef USE_DARKGRAY
+        if (can_change_color() && (COLORS > 16))
+        {
+            color = CURSES_DARK_GRAY - 1;
+        }
+        else    /* Use bold for a bright black */
+        {
+            wattron(win, A_BOLD);
+        }
+#else        
+        color = CLR_BLUE;
+#endif  /* USE_DARKGRAY */
+    }
+    curses_color = color + 1;
+    if (COLORS < 16)
+    {
+        if (curses_color > 8)
+            curses_color -= 8;
+    }
+    if (onoff == ON)    /* Turn on color/attributes */
+    {
+        if (color != NONE)
+        {
+            if ((color > 7) && (COLORS < 16))
+            {
+                wattron(win, A_BOLD);
+            }
+            wattron(win, COLOR_PAIR(curses_color));
+        }
+        
+        if (attr != NONE)
+        {
+            wattron(win, attr);
+        }
+    }
+    else                /* Turn off color/attributes */
+    {
+        if (color != NONE)
+        {
+            if ((color > 7) && (COLORS < 16))
+            {
+                wattroff(win, A_BOLD);
+            }
+#ifdef USE_DARKGRAY
+            if ((color == 0) && (!can_change_color() ||
+             (COLORS <= 16)))
+            {
+                wattroff(win, A_BOLD);
+            }
+#else
+            if (iflags.use_inverse)
+            {
+                wattroff(win, A_REVERSE);
+            }
+#endif  /* DARKGRAY */
+            wattroff(win, COLOR_PAIR(curses_color));
+        }
+        
+        if (attr != NONE)
+        {
+            wattroff(win, attr);
+        }
+    }
+#endif  /* TEXTCOLOR */
+}
+
+
+/* clean up and quit - taken from tty port */
+
+void curses_bail(const char *mesg)
+{
+    clearlocks();
+    curses_exit_nhwindows(mesg);
+    terminate(EXIT_SUCCESS);
+}
+
+
+/* Return a winid for a new window of the given type */
+
+winid curses_get_wid(int type)
+{
+	winid ret;
+    static winid menu_wid = 20; /* Always even */
+    static winid text_wid = 21; /* Always odd */
+
+	switch (type)
+	{
+		case NHW_MESSAGE:
+		{
+			return MESSAGE_WIN;
+			break;
+		}
+		case NHW_MAP:
+		{
+			return MAP_WIN;
+			break;
+		}
+		case NHW_STATUS:
+		{
+			return STATUS_WIN;
+			break;
+		}
+		case NHW_MENU:
+		{
+			ret = menu_wid;
+			break;
+		}
+		case NHW_TEXT:
+		{
+			ret = text_wid;
+			break;
+		}
+		default:
+		{
+			panic("curses_get_wid: unsupported window type");
+			ret = -1;   /* Not reached */
+		}
+	}
+
+	while (curses_window_exists(ret))
+	{
+	    ret += 2;
+	    if ((ret + 2) > 10000)    /* Avoid "wid2k" problem */
+	    {
+	        ret -= 9900;
+	    }
+	}
+	
+	if (type == NHW_MENU)
+	{
+	    menu_wid += 2;
+	}
+	else
+	{
+	    text_wid += 2;
+	}
+
+	return ret;
+}
+
+
+/*
+ * Allocate a copy of the given string.  If null, return a string of
+ * zero length.
+ *
+ * This is taken from copy_of() in tty/wintty.c.
+ */
+
+char *curses_copy_of(const char *s)
+{
+    if (!s) s = "";
+    return strcpy((char *) alloc((unsigned) (strlen(s) + 1)), s);
+}
+
+
+/* Determine the number of lines needed for a string for a dialog window
+of the given width */
+
+int curses_num_lines(const char *str, int width)
+{
+    int last_space, count;
+    int curline = 1;
+    char substr[BUFSZ];
+    char tmpstr[BUFSZ];
+    
+    strcpy(substr, str);
+    
+    while (strlen(substr) > width)
+    {
+        last_space = 0;
+        
+        for (count = 0; count <= width; count++)
+        {
+            if (substr[count] == ' ')
+            last_space = count;
+
+        }
+        if (last_space == 0)    /* No spaces found */
+        {
+            last_space = count - 1;
+        }
+        for (count = (last_space + 1); count < strlen(substr); count++)
+        {
+            tmpstr[count - (last_space + 1)] = substr[count];
+        }
+        tmpstr[count - (last_space + 1)] = '\0';
+        strcpy(substr, tmpstr);
+        curline++;
+    }
+    
+    return curline;
+}
+
+
+/* Break string into smaller lines to fit into a dialog window of the
+given width */
+
+char *curses_break_str(const char *str, int width, int line_num)
+{
+    int last_space, count;
+    char *retstr;
+    int curline = 0;
+    int strsize = strlen(str);
+    char substr[strsize];
+    char curstr[strsize];
+    char tmpstr[strsize];
+    
+    strcpy(substr, str);
+    
+    while (curline < line_num)
+    {
+        if (strlen(substr) == 0 )
+        {
+            break;
+        }
+        curline++;
+        last_space = 0;       
+        for (count = 0; count <= width; count++)
+        {
+            if (substr[count] == ' ')
+            {
+                last_space = count;
+            }
+            else if (substr[count] == '\0')           
+            {
+                last_space = count;
+                break;
+            }
+        }
+        if (last_space == 0)    /* No spaces found */
+        {
+            last_space = count - 1;
+        }
+        for (count = 0; count < last_space; count++)
+        {
+            curstr[count] = substr[count];
+        }
+        curstr[count] = '\0';
+        if (substr[count] == '\0')
+        {
+            break;
+        }
+        for (count = (last_space + 1); count < strlen(substr); count++)
+        {
+            tmpstr[count - (last_space + 1)] = substr[count];
+        }
+        tmpstr[count - (last_space + 1)] = '\0';
+        strcpy(substr, tmpstr);
+    }
+    
+    if (curline < line_num)
+    {
+        return NULL;
+    }
+    
+    retstr = curses_copy_of(curstr);
+    
+    return retstr;
+}
+
+
+/* Return the remaining portion of a string after hacking-off line_num lines */
+
+char *curses_str_remainder(const char *str, int width, int line_num)
+{
+    int last_space, count;
+    char *retstr;
+    int curline = 0;
+    int strsize = strlen(str);
+    char substr[strsize];
+    char curstr[strsize];
+    char tmpstr[strsize];
+    
+    strcpy(substr, str);
+    
+    while (curline < line_num)
+    {
+        if (strlen(substr) == 0 )
+        {
+            break;
+        }
+        curline++;
+        last_space = 0;       
+        for (count = 0; count <= width; count++)
+        {
+            if (substr[count] == ' ')
+            {
+                last_space = count;
+            }
+            else if (substr[count] == '\0')           
+            {
+                last_space = count;
+                break;
+            }
+        }
+        if (last_space == 0)    /* No spaces found */
+        {
+            last_space = count - 1;
+        }
+        for (count = 0; count < last_space; count++)
+        {
+            curstr[count] = substr[count];
+        }
+        curstr[count] = '\0';
+        if (substr[count] == '\0')
+        {
+            break;
+        }
+        for (count = (last_space + 1); count < strlen(substr); count++)
+        {
+            tmpstr[count - (last_space + 1)] = substr[count];
+        }
+        tmpstr[count - (last_space + 1)] = '\0';
+        strcpy(substr, tmpstr);
+    }
+    
+    if (curline < line_num)
+    {
+        return NULL;
+    }
+    
+    retstr = curses_copy_of(substr);
+    
+    return retstr;
+}
+
+
+/* Determine if the given NetHack winid is a menu window */
+
+boolean curses_is_menu(winid wid)
+{
+    if ((wid > 19) && !(wid % 2))   /* Even number */
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+
+/* Determine if the given NetHack winid is a text window */
+
+boolean curses_is_text(winid wid)
+{
+    if ((wid > 19) && (wid % 2))   /* Odd number */
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+
+/* Replace certain characters with portable drawing characters if
+cursesgraphics option is enabled */
+
+int curses_convert_glyph(int ch, int glyph)
+{
+    int symbol;
+    
+#ifdef REINCARNATION
+    if (Is_rogue_level(&u.uz))
+    {
+        return ch;
+    }
+#endif
+    
+    /* Save some processing time by returning if the glyph represents
+    an object that we don't have custom characters for */
+    if (!glyph_is_cmap(glyph))
+    {
+        return ch;
+    }
+    
+    symbol = glyph_to_cmap(glyph);
+    
+    /* If user selected a custom character for this object, don't
+    override this. */
+    if (((glyph_is_cmap(glyph)) && (ch != showsyms[symbol])))
+    {
+        return ch;
+    }
+
+    switch (symbol)
+    {
+        case S_vwall:
+            return ACS_VLINE;
+        case S_hwall:
+            return ACS_HLINE;
+        case S_tlcorn:
+            return ACS_ULCORNER;
+        case S_trcorn:
+            return ACS_URCORNER;
+        case S_blcorn:
+            return ACS_LLCORNER;
+        case S_brcorn:
+            return ACS_LRCORNER;
+        case S_crwall:
+            return ACS_PLUS;
+        case S_tuwall:
+            return ACS_BTEE;
+        case S_tdwall:
+            return ACS_TTEE;
+        case S_tlwall:
+            return ACS_RTEE;
+        case S_trwall:
+            return ACS_LTEE;
+        case S_tree:
+            return ACS_PLMINUS;
+        case S_corr:
+            return ACS_CKBOARD;
+        case S_litcorr:
+            return ACS_CKBOARD;
+    }
+
+	return ch;
+}
+
+
+/* Move text cursor to specified coordinates in the given NetHack window */
+
+void curses_move_cursor(winid wid, int x, int y)
+{
+    int sx, sy, ex, ey;
+    int xadj = 0;
+    int yadj = 0;
+
+#ifndef PDCURSES
+    WINDOW *win = curses_get_nhwin(MAP_WIN);
+#endif
+
+    if (wid != MAP_WIN)
+    {
+        return;
+    }
+
+#ifdef PDCURSES
+    /* PDCurses seems to not handle wmove correctly, so we use move and
+    physical screen coordinates instead */
+    curses_get_window_xy(wid, &xadj, &yadj);
+#endif    
+    curs_x = x + xadj;
+    curs_y = y + yadj;
+    curses_map_borders(&sx, &sy, &ex, &ey, x, y);
+    
+    if (curses_window_has_border(wid))
+    {
+        curs_x++;
+        curs_y++;
+    }
+        
+    if ((x >= sx) && (x <= ex) &&
+     (y >= sy) && (y <= ey))
+    {
+        curs_x -= sx;
+        curs_y -= sy;
+#ifdef PDCURSES
+        move(curs_y, curs_x);
+#else
+        wmove(win, curs_y, curs_x);
+#endif
+    }
+}
+
+
+/* Perform actions that should be done every turn before nhgetch() */
+
+void curses_prehousekeeping()
+{
+#ifndef PDCURSES
+    WINDOW *win = curses_get_nhwin(MAP_WIN);
+#endif  /* PDCURSES */
+
+    if ((curs_x > -1) && (curs_y > -1))
+    {
+        curs_set(1);
+#ifdef PDCURSES
+        /* PDCurses seems to not handle wmove correctly, so we use move
+        and physical screen coordinates instead */
+        move(curs_y, curs_x);
+#else
+        wmove(win, curs_y, curs_x);
+#endif  /* PDCURSES */
+        curses_refresh_nhwin(MAP_WIN);
+    }
+}
+
+
+/* Perform actions that should be done every turn after nhgetch() */
+
+void curses_posthousekeeping()
+{
+    curs_set(0);
+    curses_decrement_highlight();
+    curses_clear_unhighlight_message_window();
+}
+
+
+void curses_view_file(const char *filename, boolean must_exist)
+{
+    winid wid;
+    anything *identifier;
+    char buf[BUFSZ];
+    menu_item *selected = NULL;
+    dlb *fp = dlb_fopen(filename, "r");
+    
+    if ((fp == NULL) && (must_exist))
+    {
+        pline("Cannot open %s for reading!", filename);
+    }
+
+    if (fp == NULL)
+    {
+        return;
+    }
+    
+    wid = curses_get_wid(NHW_MENU);
+    curses_create_nhmenu(wid);
+    identifier = malloc(sizeof(anything));
+    identifier->a_void = NULL;
+    
+    while (dlb_fgets(buf, BUFSZ, fp) != NULL)
+    {
+        curses_add_menu(wid, NO_GLYPH, identifier, 0, 0, A_NORMAL, buf,
+         FALSE);
+    }
+    
+    dlb_fclose(fp);
+    curses_end_menu(wid, "");
+    curses_select_menu(wid, PICK_NONE, &selected);
+}
+
+
+void curses_rtrim(char *str)
+{
+    char *s;
+
+    for(s = str; *s != '\0'; ++s);
+    for(--s;isspace(*s) && s > str; --s);
+    if(s == str) *s = '\0';
+    else *(++s) = '\0';
+}
+
+
+/* Read numbers until non-digit is encountered, and return number
+in int form. */
+
+int curses_get_count(int first_digit)
+{
+    long current_count = first_digit;
+    int current_char;
+    
+    current_char = curses_read_char();
+    
+    while (isdigit(current_char))
+    {
+        current_count = (current_count * 10) + (current_char - '0');
+        if (current_count > LARGEST_INT)
+        {
+            current_count = LARGEST_INT;
+        }
+        
+        pline("Count: %ld", current_count);
+        current_char = curses_read_char();
+    }
+    
+    ungetch(current_char);
+    
+    if (current_char == '\033')    /* Cancelled with escape */
+    {
+        current_count = -1;
+    }
+    
+    return current_count;
+}
+
+
+/* Convert the given NetHack text attributes into the format curses
+understands, and return that format mask. */
+
+int curses_convert_attr(int attr)
+{
+    int curses_attr;
+    
+    switch (attr)
+    {
+        case ATR_NONE:
+        {
+            curses_attr = A_NORMAL;
+            break;
+        }
+        case ATR_ULINE:
+        {
+            curses_attr = A_UNDERLINE;
+            break;
+        }
+        case ATR_BOLD:
+        {
+            curses_attr = A_BOLD;
+            break;
+        }
+        case ATR_BLINK:
+        {
+            curses_attr = A_BLINK;
+            break;
+        }
+        case ATR_INVERSE:
+        {
+            curses_attr = A_REVERSE;
+            break;
+        }
+        default:
+        {
+            curses_attr = A_NORMAL;
+        }
+    }
+        
+    return curses_attr;
+}
+
+
+/* Map letter attributes from a string to bitmask.  Return mask on
+success, or 0 if not found */
+
+int curses_read_attrs(char *attrs)
+{
+    int retattr = 0;
+
+    if (strchr(attrs, 'b') || strchr(attrs, 'B'))
+    {
+	    retattr = retattr|A_BOLD;
+    }
+    if (strchr(attrs, 'i') || strchr(attrs, 'I'))
+    {
+	    retattr = retattr|A_REVERSE;
+    }
+    if (strchr(attrs, 'u') || strchr(attrs, 'U'))
+    {
+	    retattr = retattr|A_UNDERLINE;
+    }
+    if (strchr(attrs, 'k') || strchr(attrs, 'K'))
+    {
+	    retattr = retattr|A_BLINK;
+    }
+#ifdef A_ITALIC
+    if (strchr(attrs, 't') || strchr(attrs, 'T'))
+    {
+	    retattr = retattr|A_ITALIC;
+    }
+#endif
+#ifdef A_RIGHTLINE
+    if (strchr(attrs, 'r') || strchr(attrs, 'R'))
+    {
+	    retattr = retattr|A_RIGHTLINE;
+    }
+
+#endif
+#ifdef A_LEFTLINE
+    if (strchr(attrs, 'l') || strchr(attrs, 'L'))
+    {
+	    retattr = retattr|A_LEFTLINE;
+    }
+#endif
+
+    return retattr;
+}
+
+
+/* Convert special keys into values that NetHack can understand.
+Currently this is limited to arrow keys, but this may be expanded. */
+
+int curses_convert_keys(int key)
+{
+    int ret = key;
+    
+    if (ret == '\033')
+    {
+        ret = parse_escape_sequence();
+    }
+
+    /* Handle arrow keys */
+    switch (key)
+    {
+        case KEY_LEFT:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '4';
+            }
+            else
+            {
+                ret = 'h';
+            }
+            break;
+        }
+        case KEY_RIGHT:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '6';
+            }
+            else
+            {
+                ret = 'l';
+            }
+            break;
+        }
+        case KEY_UP:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '8';
+            }
+            else
+            {
+                ret = 'k';
+            }
+            break;
+        }
+        case KEY_DOWN:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '2';
+            }
+            else
+            {
+                ret = 'j';
+            }
+            break;
+        }
+#ifdef KEY_A1
+        case KEY_A1:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '7';
+            }
+            else
+            {
+                ret = 'y';
+            }
+            break;
+        }
+#endif  /* KEY_A1 */
+#ifdef KEY_A3
+        case KEY_A3:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '9';
+            }
+            else
+            {
+                ret = 'u';
+            }
+            break;
+        }
+#endif  /* KEY_A3 */
+#ifdef KEY_C1
+        case KEY_C1:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '1';
+            }
+            else
+            {
+                ret = 'b';
+            }
+            break;
+        }
+#endif  /* KEY_C1 */
+#ifdef KEY_C3
+        case KEY_C3:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '3';
+            }
+            else
+            {
+                ret = 'n';
+            }
+            break;
+        }
+#endif  /* KEY_C3 */
+#ifdef KEY_B2
+        case KEY_B2:
+        {
+            if (iflags.num_pad)
+            {
+                ret = '5';
+            }
+            else
+            {
+                ret = 'g';
+            }
+            break;
+        }
+#endif  /* KEY_B2 */
+    }
+
+    return ret;
+}
+
+
+/* Process mouse events.  Mouse movement is processed until no further
+mouse movement events are available.  Returns 0 for a mouse click
+event, or the first non-mouse key event in the case of mouse
+movement. */
+
+int curses_get_mouse(int *mousex, int *mousey, int *mod)
+{
+    int key = '\033';
+#ifdef NCURSES_MOUSE_VERSION
+	MEVENT event;
+
+    if (getmouse(&event) == OK)
+    {   /* When the user clicks left mouse button */
+        if(event.bstate & BUTTON1_CLICKED)
+        {
+            /* See if coords are in map window & convert coords */
+            if (wmouse_trafo(mapwin, &event.y, &event.x, TRUE))
+            {
+                key = 0;    /* Flag mouse click */
+                *mousex = event.x;
+                *mousey = event.y;
+                
+                if (curses_window_has_border(MAP_WIN))
+                {
+                    (*mousex)--;
+                    (*mousey)--;
+                }
+                
+                *mod = CLICK_1;
+            }
+        }
+    }
+#endif  /* NCURSES_MOUSE_VERSION */
+
+    return key;
+}
+
+
+static int parse_escape_sequence(void)
+{
+#ifndef PDCURSES
+    int ret;
+
+    timeout(10);
+
+    ret = getch();
+
+    if (ret != ERR) /* Likely an escape sequence */
+    {
+        if (((ret >= 'a') && (ret <= 'z')) ||
+         ((ret >= '0') && (ret <= '9')))
+        {
+            ret |= 0x80; /* Meta key support for most terminals */
+        }
+        else if (ret == 'O') /* Numeric keypad */
+        {
+            ret = getch();
+            if ((ret != ERR) && (ret >= 112) && (ret <= 121))
+            {
+                ret = ret - 112 + '0';  /* Convert to number */
+            }
+            else
+            {
+                ret = '\033';    /* Escape */
+            }
+        }
+    }
+    else
+    {
+        ret = '\033';    /* Just an escape character */
+    }
+
+    timeout(-1);
+
+    return ret;
+#else
+    return '\033';
+#endif  /* !PDCURSES */
+}
+
+
+/* This is a kludge for the statuscolors patch which calls tty-specific
+functions, which causes a compiler error if TTY_GRAPHICS is not
+defined.  Adding stub functions to avoid this. */
+
+#if defined(STATUS_COLORS) && !defined(TTY_GRAPHICS)
+extern void term_start_color(int color) {}
+extern void term_start_attr(int attr) {}
+extern void term_end_color() {}
+extern void term_end_attr(int attr) {}
+#endif  /* STATUS_COLORS && !TTY_GRAPGICS */
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursmisc.h nethack-3.4.3/win/curses/cursmisc.h
--- nethack-orig/win/curses/cursmisc.h	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursmisc.h	2010-12-17 14:01:01.908525001 -0500
@@ -0,0 +1,48 @@
+#ifndef CURSMISC_H
+#define CURSMISC_H
+
+/* Global declarations */
+
+int curses_read_char(void);
+
+void curses_toggle_color_attr(WINDOW *win, int color, int attr, int onoff);
+
+void curses_bail(const char *mesg);
+
+winid curses_get_wid(int type);
+
+char *curses_copy_of(const char *s);
+
+int curses_num_lines(const char *str, int width);
+
+char *curses_break_str(const char *str, int width, int line_num);
+
+char *curses_str_remainder(const char *str, int width, int line_num);
+
+boolean curses_is_menu(winid wid);
+
+boolean curses_is_text(winid wid);
+
+int curses_convert_glyph(int ch, int glyph);
+
+void curses_move_cursor(winid wid, int x, int y);
+
+void curses_prehousekeeping(void);
+
+void curses_posthousekeeping(void);
+
+void curses_view_file(const char *filename, boolean must_exist);
+
+void curses_rtrim(char *str);
+
+int curses_get_count(int first_digit);
+
+int curses_convert_attr(int attr);
+
+int curses_read_attrs(char *attrs);
+
+int curses_convert_keys(int key);
+
+int curses_get_mouse(int *mousex, int *mousey, int *mod);
+
+#endif  /* CURSMISC_H */
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursstat.c nethack-3.4.3/win/curses/cursstat.c
--- nethack-orig/win/curses/cursstat.c	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursstat.c	2010-12-17 14:01:01.908525001 -0500
@@ -0,0 +1,2727 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "cursstat.h"
+
+/* Status window functions for curses interface */
+
+/* Private declarations */
+
+typedef struct nhs
+{
+    long value;
+    char *txt;
+    aligntyp alignment;
+    boolean display;
+    int highlight_turns;
+    int highlight_color;
+    int stat_color;
+    int stat_attr;
+    int x;
+    int y;
+    char *label;
+    const char *id;
+} nhstat;
+
+#ifdef STATUS_COLORS
+extern const struct text_color_option *text_colors;
+extern const struct percent_color_option *hp_colors;
+extern const struct percent_color_option *pw_colors;
+
+extern struct color_option text_color_of(const char *text,
+ const struct text_color_option *color_options);
+
+struct color_option percentage_color_of(int value, int max,
+ const struct percent_color_option *color_options);
+
+static boolean stat_colored(const char *id);
+#endif
+
+static void init_stats(void);
+
+static void set_labels(int label_width);
+
+static void set_stat_color(nhstat *stat);
+
+static void color_stat(nhstat stat, int onoff);
+
+static nhstat prevname;
+static nhstat prevdepth;
+static nhstat prevstr;
+static nhstat prevint;
+static nhstat prevwis;
+static nhstat prevdex;
+static nhstat prevcon;
+static nhstat prevcha;
+static nhstat prevalign;  
+static nhstat prevau;
+static nhstat prevhp;
+static nhstat prevmhp;
+static nhstat prevlevel;
+static nhstat prevpow;
+static nhstat prevmpow;
+static nhstat prevac;
+static nhstat prevexp;
+static nhstat prevtime;
+#ifdef SCORE_ON_BOTL
+static nhstat prevscore;
+#endif
+static nhstat prevhunger;
+static nhstat prevconf;
+static nhstat prevblind;
+static nhstat prevstun;
+static nhstat prevhallu;
+static nhstat prevsick;
+static nhstat prevslime;
+static nhstat prevencumb;
+
+#define COMPACT_LABELS  1
+#define NORMAL_LABELS   2
+#define WIDE_LABELS     3
+
+extern const char *hu_stat[]; /* from eat.c */
+extern const char *enc_stat[]; /* from botl.c */
+
+/* Update the status win - this is called when NetHack would normally
+write to the status window, so we know somwthing has changed.  We
+override the write and update what needs to be updated ourselves. */
+
+void curses_update_stats(boolean redraw)
+{
+    char buf[BUFSZ];
+    int count, enc, orient, sx_start, hp, hpmax, labels, swidth,
+     sheight, sx_end, sy_end;
+    WINDOW *win = curses_get_nhwin(STATUS_WIN);
+    static int prev_labels = -1;
+    static boolean first = TRUE;
+    static boolean horiz;
+    int sx = 0;
+    int sy = 0;
+    boolean border = curses_window_has_border(STATUS_WIN);
+    
+    curses_get_window_size(STATUS_WIN, &sheight, &swidth);
+
+    if (border)
+    {
+        sx++;
+        sy++;
+        swidth--;
+        sheight--;
+    }
+    
+    sx_end = swidth - 1;
+    sy_end = sheight - 1;    
+    sx_start = sx;
+        
+    if (first)
+    {
+        init_stats();
+        first = FALSE;
+        redraw = TRUE;
+    }
+
+    if (redraw)
+    {
+        orient = curses_get_window_orientation(STATUS_WIN);
+
+        if ((orient == ALIGN_RIGHT) || (orient == ALIGN_LEFT))
+        {
+            horiz = FALSE;
+        }
+        else
+        {
+            horiz = TRUE;
+        }
+    }
+    
+    if (horiz)
+    {
+        if (term_cols >= 80)
+        {
+            labels = NORMAL_LABELS;
+        }
+        else
+        {
+            labels = COMPACT_LABELS;
+        }
+    }
+    else
+    {
+        labels = WIDE_LABELS;
+    }
+    
+    if (labels != prev_labels)
+    {
+        set_labels(labels);
+        prev_labels = labels;
+    }
+
+    curses_clear_nhwin(STATUS_WIN);
+    
+    /* Line 1 */
+    
+    /* Player name and title */
+    strcpy(buf, plname);
+    if ('a' <= buf[0] && buf[0] <= 'z') buf[0] += 'A'-'a';
+    strcat(buf, " the ");
+    if (u.mtimedone) {
+        char mname[BUFSZ];
+        int k = 0;
+        strcpy(mname, mons[u.umonnum].mname);
+        while(mname[k] != 0) {
+            if ((k == 0 || (k > 0 && mname[k-1] == ' '))
+             && 'a' <= mname[k] && mname[k] <= 'z')
+            {
+                mname[k] += 'A' - 'a';
+            }
+            k++;
+        }
+        strcat(buf, mname);
+    } else {
+        strcat(buf, rank_of(u.ulevel, pl_character[0], flags.female));
+    }
+    
+    if (strcmp(buf, prevname.txt) != 0) /* Title changed */
+    {
+        prevname.highlight_turns = 5;
+        prevname.highlight_color = HIGHLIGHT_COLOR;
+        free(prevname.txt);
+        prevname.txt = curses_copy_of(buf);
+        if ((labels == COMPACT_LABELS) && (u.ulevel > 1))
+        {
+            curses_puts(MESSAGE_WIN, A_NORMAL, "You are now known as");
+            curses_puts(MESSAGE_WIN, A_NORMAL, prevname.txt);
+        }
+    }
+    
+    if (prevname.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevname.label);
+        sx += strlen(prevname.label);
+    }
+    
+    if (labels != COMPACT_LABELS)
+    {
+        color_stat(prevname, ON);
+        mvwaddstr(win, sy, sx, prevname.txt);
+        color_stat(prevname, OFF);
+    }
+
+    if (horiz)
+    {
+        if (labels != COMPACT_LABELS)
+        {
+            sx += strlen(prevname.txt) + 1;
+        }
+        
+        
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+    
+    /* Add dungeon name and level if status window is vertical */
+    if (!horiz)
+    {
+        sprintf(buf, "%s", dungeons[u.uz.dnum].dname);
+        mvwaddstr(win, sy, sx, buf);
+        sy += 2;
+    }
+
+    /* Strength */
+    if (ACURR(A_STR) != prevstr.value)  /* Strength changed */
+    {
+        
+        if (ACURR(A_STR) > prevstr.value)
+        {
+            prevstr.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevstr.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevstr.value = ACURR(A_STR);
+        if (ACURR(A_STR) > 118)
+        {
+            sprintf(buf, "%d", ACURR(A_STR) - 100);
+        }
+        else if (ACURR(A_STR)==118)
+        {
+            sprintf(buf, "18/**");
+        }
+        else if(ACURR(A_STR) > 18)
+        {
+            sprintf(buf, "18/%02d", ACURR(A_STR) - 18);
+        }
+        else
+        {
+            sprintf(buf, "%d", ACURR(A_STR));
+        }
+        free(prevstr.txt);
+        prevstr.txt = curses_copy_of(buf);
+        prevstr.highlight_turns = 5;
+    }
+
+    if (prevstr.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevstr.label);
+        sx += strlen(prevstr.label);
+    }
+    
+    color_stat(prevstr, ON);
+    mvwaddstr(win, sy, sx, prevstr.txt);
+    color_stat(prevstr, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevstr.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Intelligence */
+    if (ACURR(A_INT) != prevint.value)  /* Intelligence changed */
+    {
+        
+        if (ACURR(A_INT) > prevint.value)
+        {
+            prevint.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevint.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevint.value = ACURR(A_INT);
+        sprintf(buf, "%d", ACURR(A_INT)); 
+        free(prevint.txt);
+        prevint.txt = curses_copy_of(buf);
+        prevint.highlight_turns = 5;
+    }
+
+    if (prevint.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevint.label);
+        sx += strlen(prevint.label);
+    }
+    
+    color_stat(prevint, ON);
+    mvwaddstr(win, sy, sx, prevint.txt);
+    color_stat(prevint, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevint.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Wisdom */
+    if (ACURR(A_WIS) != prevwis.value)  /* Wisdom changed */
+    {
+        
+        if (ACURR(A_WIS) > prevwis.value)
+        {
+            prevwis.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevwis.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevwis.value = ACURR(A_WIS);
+        sprintf(buf, "%d", ACURR(A_WIS)); 
+        free(prevwis.txt);
+        prevwis.txt = curses_copy_of(buf);
+        prevwis.highlight_turns = 5;
+    }
+
+    if (prevwis.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevwis.label);
+        sx += strlen(prevwis.label);
+    }
+    
+    color_stat(prevwis, ON);
+    mvwaddstr(win, sy, sx, prevwis.txt);
+    color_stat(prevwis, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevwis.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Dexterity */
+    if (ACURR(A_DEX) != prevdex.value)  /* Dexterity changed */
+    {
+        
+        if (ACURR(A_DEX) > prevdex.value)
+        {
+            prevdex.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevdex.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevdex.value = ACURR(A_DEX);
+        sprintf(buf, "%d", ACURR(A_DEX));
+        free(prevdex.txt);
+        prevdex.txt = curses_copy_of(buf);
+        prevdex.highlight_turns = 5;
+    }
+
+    if (prevdex.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevdex.label);
+        sx += strlen(prevdex.label);
+    }
+    
+    color_stat(prevdex, ON);
+    mvwaddstr(win, sy, sx, prevdex.txt);
+    color_stat(prevdex, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevdex.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Constitution */
+    if (ACURR(A_CON) != prevcon.value)  /* Constitution changed */
+    {
+        
+        if (ACURR(A_CON) > prevcon.value)
+        {
+            prevcon.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevcon.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevcon.value = ACURR(A_CON);
+        sprintf(buf, "%d", ACURR(A_CON));
+        free(prevcon.txt);
+        prevcon.txt = curses_copy_of(buf);
+        prevcon.highlight_turns = 5;
+    }
+
+    if (prevcon.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevcon.label);
+        sx += strlen(prevcon.label);
+    }
+    
+    color_stat(prevcon, ON);
+    mvwaddstr(win, sy, sx, prevcon.txt);
+    color_stat(prevcon, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevcon.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Charisma */
+    if (ACURR(A_CHA) != prevcha.value)  /* Charisma changed */
+    {
+        if (ACURR(A_CHA) > prevcha.value)
+        {
+            prevcha.highlight_color = STAT_UP_COLOR;
+        }
+        else
+        {
+            prevcha.highlight_color = STAT_DOWN_COLOR;
+        }
+        prevcha.value = ACURR(A_CHA);
+        sprintf(buf, "%d", ACURR(A_CHA));
+        free(prevcha.txt);
+        prevcha.txt = curses_copy_of(buf);
+        prevcha.highlight_turns = 5;
+    }
+
+    if (prevcha.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevcha.label);
+        sx += strlen(prevcha.label);
+    }
+    
+    color_stat(prevcha, ON);
+    mvwaddstr(win, sy, sx, prevcha.txt);
+    color_stat(prevcha, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevcha.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy ++;
+    }
+    
+    /* Alignment */
+    if (prevalign.alignment != u.ualign.type)   /* Alignment changed */
+    {
+        prevalign.highlight_color = HIGHLIGHT_COLOR;
+        prevalign.highlight_turns = 10; /* This is a major change! */
+        prevalign.alignment = u.ualign.type;
+        free(prevalign.txt);
+        switch (u.ualign.type)
+        {
+            case A_LAWFUL:
+            {
+                prevalign.txt = curses_copy_of("Lawful");
+                break;
+            }
+            case A_NEUTRAL:
+            {
+                prevalign.txt = curses_copy_of("Neutral");
+                break;
+            }
+            case A_CHAOTIC:
+            {
+                prevalign.txt = curses_copy_of("Chaotic");
+                break;
+            }
+        }
+    }
+
+    if (prevalign.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevalign.label);
+        sx += strlen(prevalign.label);
+    }
+    
+    color_stat(prevalign, ON);
+    mvwaddstr(win, sy, sx, prevalign.txt);
+    color_stat(prevalign, OFF);
+
+    /* Line 2 */
+    
+    sx = sx_start;
+    sy++;
+    
+    /* Dungeon Level */
+    if (depth(&u.uz) != prevdepth.value)    /* Dungeon level changed */
+    {
+        prevdepth.highlight_color = HIGHLIGHT_COLOR;
+        prevdepth.highlight_turns = 5;
+        prevdepth.value = depth(&u.uz);
+        free(prevdepth.txt);
+        if (In_endgame(&u.uz))
+        {
+            strcpy(buf, (Is_astralevel(&u.uz) ? "Astral Plane":"End Game"));
+        }
+        else
+        {
+            sprintf(buf, "%d", depth(&u.uz));
+        }
+        prevdepth.txt = curses_copy_of(buf);
+    }
+    
+    if (prevdepth.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevdepth.label);
+        sx += strlen(prevdepth.label);
+    }
+    
+    color_stat(prevdepth, ON);
+    mvwaddstr(win, sy, sx, prevdepth.txt);
+    color_stat(prevdepth, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevdepth.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+    
+    /* Gold */
+#ifndef GOLDOBJ
+    if (prevau.value != u.ugold)    /* Gold changed */
+    {
+        if (u.ugold > prevau.value)
+        {
+#else
+    if (prevau.value != money_cnt(invent))  /* Gold changed */
+    {
+        if (money_cnt(invent) > prevau.value)
+        {
+#endif
+            prevau.highlight_color = HI_GOLD;
+        }
+        else
+        {
+            prevau.highlight_color = STAT_DOWN_COLOR;
+        }
+#ifndef GOLDOBJ
+        prevau.value = u.ugold;
+        sprintf(buf,"%ld", u.ugold);
+#else
+        prevau.value = money_cnt(invent);
+        sprintf(buf,"%ld", money_cnt(invent));
+#endif
+        free(prevau.txt);
+        prevau.txt = curses_copy_of(buf);
+        prevau.highlight_turns = 5;
+    }
+    
+    if (prevau.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevau.label);
+        sx += strlen(prevau.label);
+    }
+    
+    color_stat(prevau, ON);
+    mvwaddstr(win, sy, sx, prevau.txt);
+    color_stat(prevau, OFF);
+
+    if (horiz)
+    {
+        sx += strlen(prevau.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+
+    /* Hit Points */
+	    
+    if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+    {
+	    hp = u.mh;
+	    hpmax = u.mhmax;
+	}
+	else    /* Not polymorphed */
+	{
+	    hp = u.uhp;
+	    hpmax = u.uhpmax;
+	}
+    
+	if (hp != prevhp.value)
+	{
+	    if (hp > prevhp.value)
+	    {
+	        prevhp.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+            prevhp.highlight_color = STAT_DOWN_COLOR;
+	    }
+        prevhp.value = hp;
+        if (prevhp.value < 0)
+        {
+            prevhp.value = 0;
+        }
+        sprintf(buf, "%ld", prevhp.value);
+        free(prevhp.txt);
+        prevhp.txt = curses_copy_of(buf);
+        prevhp.highlight_turns = 3;
+	}
+
+    if (prevhp.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevhp.label);
+        sx += strlen(prevhp.label);
+    }
+
+    color_stat(prevhp, ON);
+    mvwaddstr(win, sy, sx, prevhp.txt);
+    color_stat(prevhp, OFF);
+
+    sx += strlen(prevhp.txt);
+
+    /* Max Hit Points */
+
+	if (hpmax != prevmhp.value)  /* Not polymorphed */
+	{
+	    if (hpmax > prevmhp.value)
+	    {
+	        prevmhp.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+            prevmhp.highlight_color = STAT_DOWN_COLOR;
+	    }
+        prevmhp.value = hpmax;
+        sprintf(buf, "%d", hpmax);
+        free(prevmhp.txt);
+        prevmhp.txt = curses_copy_of(buf);
+        prevmhp.highlight_turns = 3;
+	}
+
+    if (prevmhp.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevmhp.label);
+        sx += strlen(prevmhp.label);
+    }
+
+    color_stat(prevmhp, ON);
+    mvwaddstr(win, sy, sx, prevmhp.txt);
+    color_stat(prevmhp, OFF);
+
+    if (horiz)
+    {
+        color_stat(prevmhp, ON);
+        sx += strlen(prevmhp.txt) + 1;
+        color_stat(prevmhp, OFF);
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Power */
+    if (u.uen != prevpow.value)
+	{
+	    if (u.uen > prevpow.value)
+	    {
+	        prevpow.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+            prevpow.highlight_color = STAT_DOWN_COLOR;
+	    }
+        prevpow.value = u.uen;
+        sprintf(buf, "%d", u.uen);
+        free(prevpow.txt);
+        prevpow.txt = curses_copy_of(buf);
+        prevpow.highlight_turns = 3;
+	}
+
+    if (prevpow.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevpow.label);
+        sx += strlen(prevpow.label);
+    }
+
+    color_stat(prevpow, ON);
+    mvwaddstr(win, sy, sx, prevpow.txt);
+    color_stat(prevpow, OFF);
+    
+    sx += strlen(prevpow.txt);
+
+    /* Max Power */
+    if (u.uenmax != prevmpow.value)
+	{
+	    if (u.uenmax > prevmpow.value)
+	    {
+	        prevmpow.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+            prevmpow.highlight_color = STAT_DOWN_COLOR;
+	    }
+        prevmpow.value = u.uenmax;
+        sprintf(buf, "%d", u.uenmax);
+        free(prevmpow.txt);
+        prevmpow.txt = curses_copy_of(buf);
+        prevmpow.highlight_turns = 3;
+	}
+
+    if (prevmpow.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevmpow.label);
+        sx += strlen(prevmpow.label);
+    }
+
+    color_stat(prevmpow, ON);
+    mvwaddstr(win, sy, sx, prevmpow.txt);
+    color_stat(prevmpow, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevmpow.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+
+    /* Armor Class */
+    if (u.uac != prevac.value)
+	{
+	    if (u.uac > prevac.value)   /* Lower is better for AC */
+	    {
+	        prevac.highlight_color = STAT_DOWN_COLOR;
+	    }
+	    else
+	    {
+            prevac.highlight_color = STAT_UP_COLOR;
+	    }
+        prevac.value = u.uac;
+        sprintf(buf, "%d", u.uac);
+        free(prevac.txt);
+        prevac.txt = curses_copy_of(buf);
+        prevac.highlight_turns = 5;
+	}
+
+    if (prevac.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevac.label);
+        sx += strlen(prevac.label);
+    }
+
+    color_stat(prevac, ON);
+    mvwaddstr(win, sy, sx, prevac.txt);
+    color_stat(prevac, OFF);
+    
+    if (horiz)
+    {
+        sx += strlen(prevac.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Experience */
+#ifdef EXP_ON_BOTL
+    if (prevexp.display != flags.showexp)   /* Setting has changed */
+    {
+        prevexp.display = flags.showexp;
+        free(prevlevel.label);
+        if (prevexp.display)
+        {
+            prevlevel.label = curses_copy_of("/");
+        }
+        else
+        {
+            if (horiz)
+            {
+                if (labels == COMPACT_LABELS)
+                {
+                    prevlevel.label = curses_copy_of("Lv:");
+                }
+                else
+                {
+                    prevlevel.label = curses_copy_of("Lvl:");
+                }
+            }
+            else
+            {
+                prevlevel.label = curses_copy_of("Level:         ");
+            }
+        }
+    }
+
+    if (prevexp.display && !u.mtimedone)
+    {
+        if (u.uexp != prevexp.value)
+	    {
+	        if (u.uexp > prevexp.value)
+	        {
+	            prevexp.highlight_color = STAT_UP_COLOR;
+	        }
+	        else
+	        {
+                prevexp.highlight_color = STAT_DOWN_COLOR;
+	        }
+            sprintf(buf, "%ld", u.uexp);
+            free(prevexp.txt);
+            prevexp.txt = curses_copy_of(buf);
+            prevexp.highlight_turns = 3;
+	    }
+
+        if (prevexp.label != NULL)
+        {
+            mvwaddstr(win, sy, sx, prevexp.label);
+            sx += strlen(prevexp.label);
+        }
+
+        color_stat(prevexp, ON);
+        mvwaddstr(win, sy, sx, prevexp.txt);
+        color_stat(prevexp, OFF);
+
+        sx += strlen(prevexp.txt);
+    }
+    
+    prevexp.value = u.uexp; /* Track it even when it's not displayed */
+#endif  /* EXP_ON_BOTL */
+
+    /* Level */
+    if (u.mtimedone)    /* Currently polymorphed - show monster HD */
+    {
+        if ((strncmp(prevlevel.label, "HP:", 3) != 0) ||
+         (strncmp(prevlevel.label, "Hit Points:", 11) != 0))
+        {
+            free(prevlevel.label);
+            if (horiz)
+            {
+            prevlevel.label = curses_copy_of("HD:");
+        }
+            else
+            {
+                prevlevel.label = curses_copy_of("Hit Dice:      ");
+            }
+        }
+        if (mons[u.umonnum].mlevel != prevlevel.value)
+        {
+            if (mons[u.umonnum].mlevel > prevlevel.value)
+            {
+                prevlevel.highlight_color = STAT_UP_COLOR;
+            }
+            else
+            {
+                prevlevel.highlight_color = STAT_DOWN_COLOR;
+            }
+            prevlevel.highlight_turns = 5;
+        }
+        prevlevel.value = mons[u.umonnum].mlevel;
+        sprintf(buf, "%d", mons[u.umonnum].mlevel);
+        free(prevlevel.txt);
+        prevlevel.txt = curses_copy_of(buf);
+    }
+    else    /* Not polymorphed */
+    {
+        if ((strncmp(prevlevel.label, "HD:", 3) != 0) ||
+         (strncmp(prevlevel.label, "Hit Dice:", 9) != 0))
+        {
+            free(prevlevel.label);
+            if (prevexp.display)
+            {
+                prevlevel.label = curses_copy_of("/");
+            }
+            else
+            {
+                if (horiz)
+                {
+                    if (labels == COMPACT_LABELS)
+                    {
+                        prevlevel.label = curses_copy_of("Lv:");
+                    }
+                    else
+                    {
+                        prevlevel.label = curses_copy_of("Lvl:");
+                    }
+                }
+                else
+                {
+                    prevlevel.label = curses_copy_of("Level:         ");
+                }
+            }
+        }
+        if (u.ulevel > prevlevel.value)
+        {
+            prevlevel.highlight_color = STAT_UP_COLOR;
+            prevlevel.highlight_turns = 5;
+        }
+        else if (u.ulevel < prevlevel.value)
+        {
+            prevlevel.highlight_color = STAT_DOWN_COLOR;
+            prevlevel.highlight_turns = 5;
+        }
+        prevlevel.value = u.ulevel;
+        sprintf(buf, "%d", u.ulevel);
+        free(prevlevel.txt);
+        prevlevel.txt = curses_copy_of(buf);
+    }
+
+    if (prevlevel.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevlevel.label);
+        sx += strlen(prevlevel.label);
+    }
+
+    color_stat(prevlevel, ON);
+    mvwaddstr(win, sy, sx, prevlevel.txt);
+    color_stat(prevlevel, OFF);
+
+    if (horiz)
+    {
+        sx += strlen(prevlevel.txt) + 1;
+    }
+    else
+    {
+        sx = sx_start;
+        sy++;
+    }
+
+    /* Time */
+    if (prevtime.display != flags.time)   /* Setting has changed */
+    {
+        prevtime.display = flags.time;
+    }
+    if (prevtime.display)
+    {
+        if (moves != prevtime.value)
+	    {
+            sprintf(buf, "%ld", moves);
+            free(prevtime.txt);
+            prevtime.txt = curses_copy_of(buf);
+	    }
+
+        if (prevtime.label != NULL)
+        {
+            mvwaddstr(win, sy, sx, prevtime.label);
+            sx += strlen(prevtime.label);
+        }
+
+        color_stat(prevtime, ON);
+        mvwaddstr(win, sy, sx, prevtime.txt);
+        color_stat(prevtime, OFF);
+
+        if (horiz)
+        {
+            sx += strlen(prevtime.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+    
+    /* Score */
+#ifdef SCORE_ON_BOTL
+    if (prevscore.display != flags.showscore)   /* Setting has changed */
+    {
+        prevscore.display = flags.showscore;
+    }
+    if (prevscore.display)
+    {
+        if (botl_score() != prevscore.value)
+	    {
+	        if (botl_score() > prevscore.value)
+	        {
+	            prevscore.highlight_color = STAT_UP_COLOR;
+	        }
+	        else    /* Not sure this is possible */
+	        {
+                prevscore.highlight_color = STAT_DOWN_COLOR;
+	        }
+            sprintf(buf, "%ld", botl_score());
+            free(prevscore.txt);
+            prevscore.txt = curses_copy_of(buf);
+            prevscore.highlight_turns = 3;
+	    }
+
+        if (prevscore.label != NULL)
+        {
+            mvwaddstr(win, sy, sx, prevscore.label);
+            sx += strlen(prevscore.label);
+        }
+
+        color_stat(prevscore, ON);
+        mvwaddstr(win, sy, sx, prevscore.txt);
+        color_stat(prevscore, OFF);
+
+        if (horiz)
+        {
+            sx += strlen(prevscore.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+    
+    prevscore.value = botl_score(); /* Track it even when it's not displayed */
+#endif  /* SCORE_ON_BOTL */
+
+    /* Hunger */
+    if (u.uhs != prevhunger.value)
+	{
+	    if ((u.uhs > prevhunger.value) || (u.uhs > 3))
+	    {
+	        prevhunger.highlight_color = STAT_DOWN_COLOR;
+	    }
+	    else
+	    {
+            prevhunger.highlight_color = STAT_UP_COLOR;
+	    }
+        prevhunger.value = u.uhs;
+        for (count = 0; count < strlen(hu_stat[u.uhs]); count++)
+        {
+            if ((hu_stat[u.uhs][count]) == ' ')
+            {
+                break;
+            }
+            buf[count] = hu_stat[u.uhs][count];
+        }
+
+        buf[count] = '\0';
+        free(prevhunger.txt);
+        prevhunger.txt = curses_copy_of(buf);
+        prevhunger.highlight_turns = 5;
+	}
+
+    if (prevhunger.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevhunger.label);
+        sx += strlen(prevhunger.label);
+    }
+
+    color_stat(prevhunger, ON);
+    mvwaddstr(win, sy, sx, prevhunger.txt);
+    color_stat(prevhunger, OFF);
+    
+    if (strlen(prevhunger.txt) > 0)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevhunger.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Confusion */
+    if (Confusion != prevconf.value)
+	{
+	    prevconf.highlight_color = STAT_DOWN_COLOR;
+        if (prevconf.txt != NULL)
+        {
+            free(prevconf.txt);
+        }
+        if (Confusion)
+        {
+            prevconf.txt = curses_copy_of("Conf");
+        }
+        else
+        {
+            prevconf.txt = NULL;
+        }
+        if (prevconf.value == 0)
+        {
+            prevconf.highlight_turns = 5;
+	    }
+        prevconf.value = Confusion;
+	}
+
+    if (prevconf.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevconf.label);
+        sx += strlen(prevconf.label);
+    }
+
+    if (prevconf.txt != NULL)
+    {
+        color_stat(prevconf, ON);
+        mvwaddstr(win, sy, sx, prevconf.txt);
+        color_stat(prevconf, OFF);
+    }
+
+    if (prevconf.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevconf.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Blindness */
+    if (Blind != prevblind.value)
+	{
+	    prevblind.highlight_color = STAT_DOWN_COLOR;
+        if (prevblind.txt != NULL)
+        {
+            free(prevblind.txt);
+        }
+        if (Blind)
+        {
+            prevblind.txt = curses_copy_of("Blind");
+        }
+        else
+        {
+            prevblind.txt = NULL;
+        }
+        if (prevblind.value == 0)
+        {
+            prevblind.highlight_turns = 5;
+	    }
+        prevblind.value = Blind;
+	}
+
+    if (prevblind.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevblind.label);
+        sx += strlen(prevblind.label);
+    }
+
+    if (prevblind.txt != NULL)
+    {
+        color_stat(prevblind, ON);
+        mvwaddstr(win, sy, sx, prevblind.txt);
+        color_stat(prevblind, OFF);
+    }
+
+    if (prevblind.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevblind.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Stun */
+    if (Stunned != prevstun.value)
+	{
+	    prevstun.highlight_color = STAT_DOWN_COLOR;
+        if (prevstun.txt != NULL)
+        {
+            free(prevstun.txt);
+        }
+        if (Stunned)
+        {
+            prevstun.txt = curses_copy_of("Stun");
+        }
+        else
+        {
+            prevstun.txt = NULL;
+        }
+        if (prevstun.value == 0)
+        {
+            prevstun.highlight_turns = 5;
+	    }
+        prevstun.value = Stunned;
+	}
+
+    if (prevstun.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevstun.label);
+        sx += strlen(prevstun.label);
+    }
+
+    if (prevstun.txt != NULL)
+    {
+        color_stat(prevstun, ON);
+        mvwaddstr(win, sy, sx, prevstun.txt);
+        color_stat(prevstun, OFF);
+    }
+
+    if (prevstun.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevstun.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Hallucination */
+    if (Hallucination != prevhallu.value)
+	{
+	    prevhallu.highlight_color = STAT_DOWN_COLOR;
+        if (prevhallu.txt != NULL)
+        {
+            free(prevhallu.txt);
+        }
+        if (Hallucination)
+        {
+            prevhallu.txt = curses_copy_of("Hallu");
+        }
+        else
+        {
+            prevhallu.txt = NULL;
+        }
+        if (prevhallu.value == 0)
+        {
+            prevhallu.highlight_turns = 5;
+	    }
+        prevhallu.value = Hallucination;
+	}
+
+    if (prevhallu.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevhallu.label);
+        sx += strlen(prevhallu.label);
+    }
+
+    if (prevhallu.txt != NULL)
+    {
+        color_stat(prevhallu, ON);
+        mvwaddstr(win, sy, sx, prevhallu.txt);
+        color_stat(prevhallu, OFF);
+    }
+
+    if (prevhallu.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevhallu.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Sick */
+    if (Sick != prevsick.value)
+	{
+	    prevsick.highlight_color = STAT_DOWN_COLOR;
+        if (prevsick.txt != NULL)
+        {
+            free(prevsick.txt);
+        }
+        if (Sick)
+        {
+            if (u.usick_type & SICK_VOMITABLE)
+            {
+                prevsick.txt = curses_copy_of("FoodPois");
+            }
+            else      
+            {
+                prevsick.txt = curses_copy_of("Ill");
+            }
+        }
+        else
+        {
+            prevsick.txt = NULL;
+        }
+        if (prevsick.value == 0)
+        {
+            prevsick.highlight_turns = 5;
+	    }
+        prevsick.value = Sick;
+	}
+
+    if (prevsick.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevsick.label);
+        sx += strlen(prevsick.label);
+    }
+
+    if (prevsick.txt != NULL)
+    {
+        color_stat(prevsick, ON);
+        mvwaddstr(win, sy, sx, prevsick.txt);
+        color_stat(prevsick, OFF);
+    }
+
+    if (prevsick.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevsick.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Slime */
+    if (Slimed != prevslime.value)
+	{
+	    prevslime.highlight_color = STAT_DOWN_COLOR;
+        if (prevslime.txt != NULL)
+        {
+            free(prevslime.txt);
+        }
+        if (Slimed)
+        {
+            prevslime.txt = curses_copy_of("Slime");
+        }
+        else
+        {
+            prevslime.txt = NULL;
+        }
+        if (prevslime.value == 0)
+        {
+            prevslime.highlight_turns = 5;
+	    }
+        prevslime.value = Slimed;
+	}
+
+    if (prevslime.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevslime.label);
+        sx += strlen(prevslime.label);
+    }
+
+    if (prevslime.txt != NULL)
+    {
+        color_stat(prevslime, ON);
+        mvwaddstr(win, sy, sx, prevslime.txt);
+        color_stat(prevslime, OFF);
+    }
+
+    if (prevslime.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevslime.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    /* Encumberance */
+    enc = near_capacity();
+    
+    if (enc != prevencumb.value)
+	{
+	    if (enc < prevencumb.value)
+	    {
+	        prevencumb.highlight_color = STAT_UP_COLOR;
+	    }
+	    else
+	    {
+	        prevencumb.highlight_color = STAT_DOWN_COLOR;
+        }
+        if (prevencumb.txt != NULL)
+        {
+            free(prevencumb.txt);
+        }
+        if (enc > UNENCUMBERED)
+        {
+            sprintf(buf, "%s", enc_stat[enc]);
+            prevencumb.txt = curses_copy_of(buf);
+            prevencumb.highlight_turns = 5;
+        }
+        else
+        {
+            prevencumb.txt = NULL;
+        }
+        prevencumb.value = enc;
+	}
+
+    if (prevencumb.label != NULL)
+    {
+        mvwaddstr(win, sy, sx, prevencumb.label);
+        sx += strlen(prevencumb.label);
+    }
+
+    if (prevencumb.txt != NULL)
+    {
+        color_stat(prevencumb, ON);
+        mvwaddstr(win, sy, sx, prevencumb.txt);
+        color_stat(prevencumb, OFF);
+    }
+
+    if (prevencumb.txt != NULL)
+    {
+        if (horiz)
+        {
+            sx += strlen(prevencumb.txt) + 1;
+        }
+        else
+        {
+            sx = sx_start;
+            sy++;
+        }
+    }
+
+    wrefresh(win);
+}
+
+
+/* Decrement the highlight_turns for all stats.  Call curses_update_stats
+if needed to unhighlight a stat */
+
+void curses_decrement_highlight()
+{
+    boolean unhighlight = FALSE;
+    
+    if (prevname.highlight_turns > 0)
+    {
+        prevname.highlight_turns--;
+        if (prevname.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevdepth.highlight_turns > 0)
+    {
+        prevdepth.highlight_turns--;
+        if (prevdepth.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevstr.highlight_turns > 0)
+    {
+        prevstr.highlight_turns--;
+        if (prevstr.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevint.highlight_turns > 0)
+    {
+        prevint.highlight_turns--;
+        if (prevint.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevwis.highlight_turns > 0)
+    {
+        prevwis.highlight_turns--;
+        if (prevwis.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevdex.highlight_turns > 0)
+    {
+        prevdex.highlight_turns--;
+        if (prevdex.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevcon.highlight_turns > 0)
+    {
+        prevcon.highlight_turns--;
+        if (prevcon.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevcha.highlight_turns > 0)
+    {
+        prevcha.highlight_turns--;
+        if (prevcha.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevalign.highlight_turns > 0)
+    {
+        prevalign.highlight_turns--;
+        if (prevalign.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevau.highlight_turns > 0)
+    {
+        prevau.highlight_turns--;
+        if (prevau.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevhp.highlight_turns > 0)
+    {
+        prevhp.highlight_turns--;
+        if (prevhp.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevmhp.highlight_turns > 0)
+    {
+        prevmhp.highlight_turns--;
+        if (prevmhp.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevlevel.highlight_turns > 0)
+    {
+        prevlevel.highlight_turns--;
+        if (prevlevel.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevpow.highlight_turns > 0)
+    {
+        prevpow.highlight_turns--;
+        if (prevpow.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevmpow.highlight_turns > 0)
+    {
+        prevmpow.highlight_turns--;
+        if (prevmpow.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevac.highlight_turns > 0)
+    {
+        prevac.highlight_turns--;
+        if (prevac.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+#ifdef EXP_ON_BOTL
+    if (prevexp.highlight_turns > 0)
+    {
+        prevexp.highlight_turns--;
+        if (prevexp.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+#endif
+    if (prevtime.highlight_turns > 0)
+    {
+        prevtime.highlight_turns--;
+        if (prevtime.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+#ifdef SCORE_ON_BOTL
+    if (prevscore.highlight_turns > 0)
+    {
+        prevscore.highlight_turns--;
+        if (prevscore.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+#endif
+    if (prevhunger.highlight_turns > 0)
+    {
+        prevhunger.highlight_turns--;
+        if (prevhunger.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevconf.highlight_turns > 0)
+    {
+        prevconf.highlight_turns--;
+        if (prevconf.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevblind.highlight_turns > 0)
+    {
+        prevblind.highlight_turns--;
+        if (prevblind.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevstun.highlight_turns > 0)
+    {
+        prevstun.highlight_turns--;
+        if (prevstun.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevhallu.highlight_turns > 0)
+    {
+        prevhallu.highlight_turns--;
+        if (prevhallu.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevsick.highlight_turns > 0)
+    {
+        prevsick.highlight_turns--;
+        if (prevsick.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevslime.highlight_turns > 0)
+    {
+        prevslime.highlight_turns--;
+        if (prevslime.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    if (prevencumb.highlight_turns > 0)
+    {
+        prevencumb.highlight_turns--;
+        if (prevencumb.highlight_turns == 0)
+        {
+            unhighlight = TRUE;
+        }
+    }
+    
+    if (unhighlight)
+    {
+        curses_update_stats(FALSE);
+    }
+}
+
+
+/* Initialize the stats with beginning values. */
+
+static void init_stats()
+{
+    char buf[BUFSZ];
+    int count;
+
+    /* Player name and title */
+    strcpy(buf, plname);
+    if ('a' <= buf[0] && buf[0] <= 'z') buf[0] += 'A'-'a';
+    strcat(buf, " the ");
+    if (u.mtimedone) {
+        char mname[BUFSZ];
+        int k = 0;
+
+        strcpy(mname, mons[u.umonnum].mname);
+        while(mname[k] != 0) {
+            if ((k == 0 || (k > 0 && mname[k-1] == ' '))
+             && 'a' <= mname[k] && mname[k] <= 'z')
+            {
+                mname[k] += 'A' - 'a';
+            }
+            k++;
+        }
+        strcat(buf, mname);
+    } else {
+        strcat(buf, rank_of(u.ulevel, pl_character[0], flags.female));
+    }
+
+    prevname.txt = curses_copy_of(buf);
+    prevname.display = TRUE;
+    prevname.highlight_turns = 0;
+    prevname.label = NULL;
+    prevname.id = "name";
+    set_stat_color(&prevname);
+    
+    /* Strength */
+    if (ACURR(A_STR) > 118)
+    {
+        sprintf(buf, "%d", ACURR(A_STR) - 100);
+    }
+    else if (ACURR(A_STR)==118)
+    {
+        sprintf(buf, "18/**");
+    }
+    else if(ACURR(A_STR) > 18)
+    {
+        sprintf(buf, "18/%02d", ACURR(A_STR) - 18);
+    }
+    else
+    {
+        sprintf(buf, "%d", ACURR(A_STR));
+    }
+
+    prevstr.value = ACURR(A_STR);
+    prevstr.txt = curses_copy_of(buf);
+    prevstr.display = TRUE;
+    prevstr.highlight_turns = 0;
+    prevstr.label = NULL;
+    prevstr.id = "str";
+    set_stat_color(&prevstr);
+
+    /* Intelligence */
+    sprintf(buf, "%d", ACURR(A_INT));
+    prevint.value = ACURR(A_INT);
+    prevint.txt = curses_copy_of(buf);
+    prevint.display = TRUE;
+    prevint.highlight_turns = 0;
+    prevint.label = NULL;
+    prevint.id = "int";
+    set_stat_color(&prevint);
+
+    /* Wisdom */
+    sprintf(buf, "%d", ACURR(A_WIS));
+    prevwis.value = ACURR(A_WIS);
+    prevwis.txt = curses_copy_of(buf);
+    prevwis.display = TRUE;
+    prevwis.highlight_turns = 0;
+    prevwis.label = NULL;
+    prevwis.id = "wis";
+    set_stat_color(&prevwis);
+
+    /* Dexterity */
+    sprintf(buf, "%d", ACURR(A_DEX));
+    prevdex.value = ACURR(A_DEX);
+    prevdex.txt = curses_copy_of(buf);
+    prevdex.display = TRUE;
+    prevdex.highlight_turns = 0;
+    prevdex.label = NULL;
+    prevdex.id = "dex";
+    set_stat_color(&prevdex);
+
+    /* Constitution */
+    sprintf(buf, "%d", ACURR(A_CON));
+    prevcon.value = ACURR(A_CON);
+    prevcon.txt = curses_copy_of(buf);
+    prevcon.display = TRUE;
+    prevcon.highlight_turns = 0;
+    prevcon.label = NULL;
+    prevcon.id = "con";
+    set_stat_color(&prevcon);
+
+    /* Charisma */
+    sprintf(buf, "%d", ACURR(A_CHA));
+    prevcha.value = ACURR(A_CHA);
+    prevcha.txt = curses_copy_of(buf);
+    prevcha.display = TRUE;
+    prevcha.highlight_turns = 0;
+    prevcha.label = NULL;
+    prevcha.id = "cha";
+    set_stat_color(&prevcha);
+
+    /* Alignment */
+    switch (u.ualign.type)
+    {
+        case A_LAWFUL:
+        {
+            prevalign.txt = curses_copy_of("Lawful");
+            break;
+        }
+        case A_NEUTRAL:
+        {
+            prevalign.txt = curses_copy_of("Neutral");
+            break;
+        }
+        case A_CHAOTIC:
+        {
+            prevalign.txt = curses_copy_of("Chaotic");
+            break;
+        }
+    }
+    
+    prevalign.alignment = u.ualign.type;
+    prevalign.display = TRUE;
+    prevalign.highlight_turns = 0;
+    prevalign.label = NULL;
+    prevalign.id = "align";
+    set_stat_color(&prevalign);
+    
+    /* Dungeon level */
+    if (In_endgame(&u.uz))
+    {
+        strcpy(buf, (Is_astralevel(&u.uz) ? "Astral Plane":"End Game"));
+    }
+    else
+    {
+        sprintf(buf, "%d", depth(&u.uz));
+    }
+
+    prevdepth.value = depth(&u.uz);
+    prevdepth.txt = curses_copy_of(buf);
+    prevdepth.display = TRUE;
+    prevdepth.highlight_turns = 0;
+    prevdepth.label = NULL;
+    prevdepth.id = "dlvl";
+    set_stat_color(&prevdepth);
+    
+    /* Gold */
+#ifndef GOLDOBJ
+    sprintf(buf,"%ld", u.ugold);
+    prevau.value = u.ugold;
+#else
+    sprintf(buf,"%ld", money_cnt(invent));
+    prevau.value = money_cnt(invent);
+#endif
+    prevau.txt = curses_copy_of(buf);
+    prevau.display = TRUE;
+    prevau.highlight_turns = 0;
+    prevau.label = NULL;
+    prevau.id = "gold";
+    set_stat_color(&prevau);
+
+    /* Hit Points */
+    if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+    {
+        prevhp.value = u.mh;
+        sprintf(buf, "%d", u.mh);
+        prevhp.txt = curses_copy_of(buf);
+	}
+	else if (u.uhp != prevhp.value)  /* Not polymorphed */
+	{
+	    prevhp.value = u.uhp;
+        sprintf(buf, "%d", u.uhp);
+        prevhp.txt = curses_copy_of(buf);
+	}
+	prevhp.display = TRUE;
+	prevhp.highlight_turns = 0;
+    prevhp.label = NULL;
+    prevhp.id = "hp";
+    set_stat_color(&prevhp);
+
+    /* Max Hit Points */
+    if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+    {
+        prevmhp.value = u.mhmax;
+        sprintf(buf, "%d", u.mhmax);
+        prevmhp.txt = curses_copy_of(buf);
+	}
+	else    /* Not polymorphed */
+	{
+	    prevmhp.value = u.uhpmax;
+        sprintf(buf, "%d", u.uhpmax);
+        prevmhp.txt = curses_copy_of(buf);
+	}
+	prevmhp.display = TRUE;
+	prevmhp.highlight_turns = 0;
+    prevmhp.label = curses_copy_of("/");
+    prevmhp.id = "mhp";
+    set_stat_color(&prevmhp);
+
+    /* Power */
+    prevpow.value = u.uen;
+    sprintf(buf, "%d", u.uen);
+    prevpow.txt = curses_copy_of(buf);
+	prevpow.display = TRUE;
+	prevpow.highlight_turns = 0;
+    prevpow.label = NULL;
+    prevpow.id = "pw";
+    set_stat_color(&prevpow);
+
+    /* Max Power */
+    prevmpow.value = u.uenmax;
+    sprintf(buf, "%d", u.uenmax);
+    prevmpow.txt = curses_copy_of(buf);
+	prevmpow.display = TRUE;
+	prevmpow.highlight_turns = 0;
+    prevmpow.label = curses_copy_of("/");
+    prevmpow.id = "mpw";
+    set_stat_color(&prevmpow);
+
+    /* Armor Class */
+    prevac.value = u.uac;
+    sprintf(buf, "%d", u.uac);
+    prevac.txt = curses_copy_of(buf);
+	prevac.display = TRUE;
+	prevac.highlight_turns = 0;
+    prevac.label = NULL;
+    prevac.id = "ac";
+    set_stat_color(&prevac);
+
+    /* Experience */
+#ifdef EXP_ON_BOTL
+    prevexp.value = u.uexp;
+    sprintf(buf, "%ld", u.uexp);
+    prevexp.txt = curses_copy_of(buf);
+	prevexp.display = flags.showexp;
+	prevexp.highlight_turns = 0;
+    prevexp.label = NULL;
+    prevexp.id = "xp";
+    set_stat_color(&prevexp);
+#endif
+
+    /* Level */
+    prevlevel.label = NULL;
+    if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+    {
+        prevlevel.value = mons[u.umonnum].mlevel;
+        sprintf(buf, "%d", mons[u.umonnum].mlevel);
+        prevlevel.txt = curses_copy_of(buf);
+	}
+	else if (u.ulevel != prevlevel.value)  /* Not polymorphed */
+	{
+	    prevlevel.value = u.ulevel;
+        sprintf(buf, "%d", u.ulevel);
+        prevlevel.txt = curses_copy_of(buf);
+	}
+	prevlevel.display = TRUE;
+	prevlevel.highlight_turns = 0;
+    prevlevel.id = "lvl";
+    set_stat_color(&prevlevel);
+
+    /* Time */
+    prevtime.value = moves;
+    sprintf(buf, "%ld", moves);
+    prevtime.txt = curses_copy_of(buf);
+	prevtime.display = flags.time;
+	prevtime.highlight_turns = 0;
+    prevtime.label = NULL;
+    prevtime.id = "time";
+    set_stat_color(&prevtime);
+
+    /* Score */
+#ifdef SCORE_ON_BOTL
+    prevscore.value = botl_score();
+    sprintf(buf, "%ld", botl_score());
+    prevscore.txt = curses_copy_of(buf);
+	prevscore.display = flags.showscore;
+	prevscore.highlight_turns = 0;
+    prevscore.label = NULL;
+    prevscore.id = "score";
+    set_stat_color(&prevscore);
+#endif
+
+    /* Hunger */
+    prevhunger.value = u.uhs;
+    for (count = 0; count < strlen(hu_stat[u.uhs]); count++)
+    {
+        if ((hu_stat[u.uhs][count]) == ' ')
+        {
+            break;
+        }
+        buf[count] = hu_stat[u.uhs][count];
+    }
+
+    buf[count] = '\0';
+    prevhunger.txt = curses_copy_of(buf);
+    prevhunger.display = TRUE;
+    prevhunger.highlight_turns = 0;
+    prevhunger.label = NULL;
+    prevhunger.id = "hunger";
+    set_stat_color(&prevhunger);
+
+    /* Confusion */
+    prevconf.value = Confusion;
+    if (Confusion)
+    {
+        prevconf.txt = curses_copy_of("Conf");
+    }
+    else
+    {
+        prevconf.txt = NULL;
+    }
+    prevconf.display = TRUE;
+    prevconf.highlight_turns = 0;
+    prevconf.label = NULL;
+    prevconf.id = "conf";
+    set_stat_color(&prevconf);
+
+    /* Blindness */
+    prevblind.value = Blind;
+    if (Blind)
+    {
+        prevblind.txt = curses_copy_of("Blind");
+    }
+    else
+    {
+        prevblind.txt = NULL;
+    }
+    prevblind.display = TRUE;
+    prevblind.highlight_turns = 0;
+    prevblind.label = NULL;
+    prevblind.id = "blind";
+    set_stat_color(&prevblind);
+
+    /* Stun */
+    prevstun.value = Stunned;
+    if (Stunned)
+    {
+        prevstun.txt = curses_copy_of("Stun");
+    }
+    else
+    {
+        prevstun.txt = NULL;
+    }
+    prevstun.display = TRUE;
+    prevstun.highlight_turns = 0;
+    prevstun.label = NULL;
+    prevstun.id = "stun";
+    set_stat_color(&prevstun);
+
+    /* Hallucination */
+    prevhallu.value = Hallucination;
+    if (Hallucination)
+    {
+        prevhallu.txt = curses_copy_of("Hallu");
+    }
+    else
+    {
+        prevhallu.txt = NULL;
+    }
+    prevhallu.display = TRUE;
+    prevhallu.highlight_turns = 0;
+    prevhallu.label = NULL;
+    prevhallu.id = "hallu";
+    set_stat_color(&prevhallu);
+
+    /* Sick */
+    prevsick.value = Sick;
+    if (Sick)
+    {
+        if (u.usick_type & SICK_VOMITABLE)
+        {
+            prevsick.txt = curses_copy_of("FoodPois");
+        }
+        else     
+        {
+            prevsick.txt = curses_copy_of("Ill");
+        }
+    }
+    else
+    {
+        prevsick.txt = NULL;
+    }
+    prevsick.display = TRUE;
+    prevsick.highlight_turns = 0;
+    prevsick.label = NULL;
+    prevsick.id = "sick";
+    set_stat_color(&prevsick);
+
+    /* Slimed */
+    prevslime.value = Slimed;
+    if (Slimed)
+    {
+        prevslime.txt = curses_copy_of("Slime");
+    }
+    else
+    {
+        prevslime.txt = NULL;
+    }
+    prevslime.display = TRUE;
+    prevslime.highlight_turns = 0;
+    prevslime.label = NULL;
+    prevslime.id = "slime";
+    set_stat_color(&prevslime);
+
+    /* Encumberance */
+    prevencumb.value = near_capacity();
+    if (prevencumb.value > UNENCUMBERED)
+    {
+        sprintf(buf, "%s", enc_stat[prevencumb.value]);
+        prevencumb.txt = curses_copy_of(buf);
+    }
+    else
+    {
+        prevencumb.txt = NULL;
+    }
+    prevencumb.display = TRUE;
+    prevencumb.highlight_turns = 0;
+    prevencumb.label = NULL;
+    prevencumb.id = "encumberance";
+    set_stat_color(&prevencumb);
+}
+
+/* Set labels based on orientation of status window.  If horizontal,
+we want to compress this info; otherwise we know we have a width of at
+least 26 characters. */
+
+static void set_labels(int label_width)
+{
+    char buf[BUFSZ];
+
+    switch (label_width)
+    {
+        case COMPACT_LABELS:
+        {
+            /* Strength */
+            if (prevstr.label)
+            {
+                free (prevstr.label);
+            }
+            prevstr.label = curses_copy_of("S:");
+            /* Intelligence */
+            if (prevint.label)
+            {
+                free (prevint.label);
+            }
+            prevint.label = curses_copy_of("I:");
+
+            /* Wisdom */
+            if (prevwis.label)
+            {
+                free (prevwis.label);
+            }
+            prevwis.label = curses_copy_of("W:");
+            
+            /* Dexterity */
+            if (prevdex.label)
+            {
+                free (prevdex.label);
+            }
+            prevdex.label = curses_copy_of("D:");
+            
+            /* Constitution */
+            if (prevcon.label)
+            {
+                free (prevcon.label);
+            }
+            prevcon.label = curses_copy_of("C:");
+            
+            /* Charisma */
+            if (prevcha.label)
+            {
+                free (prevcha.label);
+            }
+            prevcha.label = curses_copy_of("Ch:");
+            
+            /* Alignment */
+            if (prevalign.label)
+            {
+                free (prevalign.label);
+            }
+            prevalign.label = NULL;
+            
+            /* Dungeon level */
+            if (prevdepth.label)
+            {
+                free (prevdepth.label);
+            }
+            prevdepth.label = curses_copy_of("Dl:");
+           
+            /* Gold */
+            if (prevau.label)
+            {
+                free (prevau.label);
+            }
+            sprintf(buf, "%c:", GOLD_SYM);
+            prevau.label = curses_copy_of(buf);
+            
+            /* Hit points */
+            if (prevhp.label)
+            {
+                free (prevhp.label);
+            }
+            prevhp.label = curses_copy_of("HP:");
+            
+            /* Power */
+            if (prevpow.label)
+            {
+                free (prevpow.label);
+            }
+            prevpow.label = curses_copy_of("Pw:");
+            
+            /* Armor Class */
+            if (prevac.label)
+            {
+                free (prevac.label);
+            }
+            prevac.label = curses_copy_of("AC:");
+            
+#ifdef EXP_ON_BOTL            
+            /* Experience */
+            if (prevexp.label)
+            {
+                free (prevexp.label);
+            }
+            prevexp.label = curses_copy_of("XP:");
+#endif            
+
+            /* Level */            
+            if (prevlevel.label)
+            {
+                free (prevlevel.label);
+                prevlevel.label = NULL;
+            }
+            if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+            {
+                prevlevel.label = curses_copy_of("HD:");
+        	}
+        	else    /* Not polymorphed */
+        	{
+                if (prevexp.display)
+                {
+                    prevlevel.label = curses_copy_of("/");
+                }
+                else
+                {    
+                    prevlevel.label = curses_copy_of("Lv:");
+                }
+            }
+            
+            /* Time */
+            if (prevtime.label)
+            {
+                free (prevtime.label);
+            }
+            prevtime.label = curses_copy_of("T:");
+            
+#ifdef SCORE_ON_BOTL
+            /* Score */
+            if (prevscore.label)
+            {
+                free (prevscore.label);
+            }
+            prevscore.label = curses_copy_of("S:");
+#endif
+            break;
+        }
+        case NORMAL_LABELS:
+        {
+            /* Strength */
+            if (prevstr.label)
+            {
+                free (prevstr.label);
+            }
+            prevstr.label = curses_copy_of("Str:");
+            /* Intelligence */
+            if (prevint.label)
+            {
+                free (prevint.label);
+            }
+            prevint.label = curses_copy_of("Int:");
+
+            /* Wisdom */
+            if (prevwis.label)
+            {
+                free (prevwis.label);
+            }
+            prevwis.label = curses_copy_of("Wis:");
+            
+            /* Dexterity */
+            if (prevdex.label)
+            {
+                free (prevdex.label);
+            }
+            prevdex.label = curses_copy_of("Dex:");
+            
+            /* Constitution */
+            if (prevcon.label)
+            {
+                free (prevcon.label);
+            }
+            prevcon.label = curses_copy_of("Con:");
+            
+            /* Charisma */
+            if (prevcha.label)
+            {
+                free (prevcha.label);
+            }
+            prevcha.label = curses_copy_of("Cha:");
+            
+            /* Alignment */
+            if (prevalign.label)
+            {
+                free (prevalign.label);
+            }
+            prevalign.label = NULL;
+            
+            /* Dungeon level */
+            if (prevdepth.label)
+            {
+                free (prevdepth.label);
+            }
+            prevdepth.label = curses_copy_of("Dlvl:");
+           
+            /* Gold */
+            if (prevau.label)
+            {
+                free (prevau.label);
+            }
+            sprintf(buf, "%c:", GOLD_SYM);
+            prevau.label = curses_copy_of(buf);
+            
+            /* Hit points */
+            if (prevhp.label)
+            {
+                free (prevhp.label);
+            }
+            prevhp.label = curses_copy_of("HP:");
+            
+            /* Power */
+            if (prevpow.label)
+            {
+                free (prevpow.label);
+            }
+            prevpow.label = curses_copy_of("Pw:");
+            
+            /* Armor Class */
+            if (prevac.label)
+            {
+                free (prevac.label);
+            }
+            prevac.label = curses_copy_of("AC:");
+            
+#ifdef EXP_ON_BOTL            
+            /* Experience */
+            if (prevexp.label)
+            {
+                free (prevexp.label);
+            }
+            prevexp.label = curses_copy_of("XP:");
+#endif            
+
+            /* Level */            
+            if (prevlevel.label)
+            {
+                free (prevlevel.label);
+                prevlevel.label = NULL;
+            }
+            if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+            {
+                prevlevel.label = curses_copy_of("HD:");
+        	}
+        	else    /* Not polymorphed */
+        	{
+                if (prevexp.display)
+                {
+                    prevlevel.label = curses_copy_of("/");
+                }
+                else
+                {    
+                    prevlevel.label = curses_copy_of("Lvl:");
+                }
+            }
+            
+            /* Time */
+            if (prevtime.label)
+            {
+                free (prevtime.label);
+            }
+            prevtime.label = curses_copy_of("T:");
+            
+#ifdef SCORE_ON_BOTL
+            /* Score */
+            if (prevscore.label)
+            {
+                free (prevscore.label);
+            }
+            prevscore.label = curses_copy_of("S:");
+#endif
+            break;
+        }
+        case WIDE_LABELS:
+        {
+            /* Strength */
+            if (prevstr.label)
+            {
+                free (prevstr.label);
+            }
+            prevstr.label = curses_copy_of("Strength:      ");
+            
+            /* Intelligence */
+            if (prevint.label)
+            {
+                free (prevint.label);
+            }
+            prevint.label = curses_copy_of("Intelligence:  ");
+            
+            /* Wisdom */
+            if (prevwis.label)
+            {
+                free (prevwis.label);
+            }
+            prevwis.label = curses_copy_of("Wisdom:        ");
+            
+            /* Dexterity */
+            if (prevdex.label)
+            {
+                free (prevdex.label);
+            }
+            prevdex.label = curses_copy_of("Dexterity:     ");
+            
+            /* Constitution */
+            if (prevcon.label)
+            {
+                free (prevcon.label);
+            }
+            prevcon.label = curses_copy_of("Constitution:  ");
+            
+            /* Charisma */
+            if (prevcha.label)
+            {
+                free (prevcha.label);
+            }
+            prevcha.label = curses_copy_of("Charisma:      ");
+            
+            /* Alignment */
+            if (prevalign.label)
+            {
+                free (prevalign.label);
+            }
+            prevalign.label = curses_copy_of("Alignment:     ");
+            
+            /* Dungeon level */
+            if (prevdepth.label)
+            {
+                free (prevdepth.label);
+            }
+            prevdepth.label = curses_copy_of("Dungeon Level: ");
+           
+            /* Gold */
+            if (prevau.label)
+            {
+                free (prevau.label);
+            }
+            prevau.label = curses_copy_of("Gold:          ");
+            
+            /* Hit points */
+            if (prevhp.label)
+            {
+                free (prevhp.label);
+            }
+            prevhp.label = curses_copy_of("Hit Points:    ");
+            
+            /* Power */
+            if (prevpow.label)
+            {
+                free (prevpow.label);
+            }
+            prevpow.label = curses_copy_of("Magic Power:   ");
+            
+            /* Armor Class */
+            if (prevac.label)
+            {
+                free (prevac.label);
+            }
+            prevac.label = curses_copy_of("Armor Class:   ");
+            
+#ifdef EXP_ON_BOTL            
+            /* Experience */
+            if (prevexp.label)
+            {
+                free (prevexp.label);
+            }
+            prevexp.label = curses_copy_of("Experience:    ");
+#endif            
+
+            /* Level */            
+            if (prevlevel.label)
+            {
+                free (prevlevel.label);
+            }
+            if (u.mtimedone)    /* Currently polymorphed - show monster HP */
+            {
+                prevlevel.label = curses_copy_of("Hit Dice:      ");
+        	}
+        	else    /* Not polymorphed */
+        	{
+                if (prevexp.display)
+                {
+                    prevlevel.label = curses_copy_of(" / ");
+                }
+                else
+                {    
+                    prevlevel.label = curses_copy_of("Level:         ");
+                }
+            }
+            
+            /* Time */
+            if (prevtime.label)
+            {
+                free (prevtime.label);
+            }
+            prevtime.label = curses_copy_of("Time:          ");
+            
+#ifdef SCORE_ON_BOTL
+            /* Score */
+            if (prevscore.label)
+            {
+                free (prevscore.label);
+            }
+            prevscore.label = curses_copy_of("Score:         ");
+#endif
+            break;
+        }
+        default:
+        {
+            panic( "set_labels(): Invalid label_width %d\n",
+             label_width );
+            break;
+        }
+    }
+}
+
+
+/* Get the default (non-highlighted) color for a stat.  For now, this
+is NO_COLOR unless the statuscolors patch is in use. */
+
+static void set_stat_color(nhstat *stat)
+{
+#ifdef STATUS_COLORS
+    struct color_option stat_color;
+    int count;
+    int attr = A_NORMAL;
+
+    if (iflags.use_status_colors && stat_colored(stat->id))
+    {
+        stat_color = text_color_of(stat->id, text_colors);
+
+        for (count = 0; (1 << count) <= stat_color.attr_bits; ++count)
+    	{
+    	    if (count != ATR_NONE && stat_color.attr_bits & (1 << count))
+    	    {
+    		    attr += curses_convert_attr(count);
+    		}
+        }
+
+        stat->stat_color = stat_color.color;
+        stat->stat_attr = attr;
+    }
+    else
+    {
+        stat->stat_color = NO_COLOR;
+        stat->stat_attr = A_NORMAL;
+    }
+#else
+    stat->stat_color = NO_COLOR;
+    stat->stat_attr = A_NORMAL;
+#endif  /* STATUS_COLORS */
+}
+
+
+/* Set the color to the base color for the given stat, or highlight a
+ changed stat. */
+
+static void color_stat(nhstat stat, int onoff)
+{
+    WINDOW *win = curses_get_nhwin(STATUS_WIN);
+#ifdef STATUS_COLORS
+    struct color_option stat_color;
+    int color, attr, hp, hpmax, count;
+    char buf[BUFSIZ];
+
+    stat_color.color = NO_COLOR;
+    stat_color.attr_bits = ATR_NONE;
+    
+    if (strcmp(stat.id, "hp") == 0)
+    {
+     	hp = Upolyd ? u.mh : u.uhp;
+     	hpmax = Upolyd ? u.mhmax : u.uhpmax;
+        stat_color = percentage_color_of(hp, hpmax, hp_colors);
+    }
+    
+    if (strcmp(stat.id, "pw") == 0)
+    {
+        stat_color = percentage_color_of(u.uen, u.uenmax, pw_colors);
+    }
+        
+    if (strcmp(stat.id, "hunger") == 0)
+    {
+        for (count = 0; count < strlen(hu_stat[u.uhs]); count++)
+        {
+            if ((hu_stat[u.uhs][count]) == ' ')
+            {
+                break;
+            }
+            buf[count] = hu_stat[u.uhs][count];
+        }
+
+        buf[count] = '\0';
+        stat_color = text_color_of(buf, text_colors);
+    }
+    
+    if (strcmp(stat.id, "encumberance") == 0)
+    {
+        stat_color = text_color_of(enc_stat[prevencumb.value],
+         text_colors);
+    }
+    
+    if (strcmp(stat.id, "sick") == 0)
+    {
+        if (u.usick_type & SICK_VOMITABLE)
+        {
+            stat_color = text_color_of("foodpois", text_colors);
+        }
+        else     
+        {
+            stat_color = text_color_of("ill", text_colors);
+        }
+    }
+
+    if (strcmp(stat.id, "align") == 0)
+    {
+        switch (u.ualign.type)
+        {
+            case A_LAWFUL:
+            {
+                stat_color = text_color_of("lawful", text_colors);
+                break;
+            }
+            case A_NEUTRAL:
+            {
+                stat_color = text_color_of("neutral", text_colors);
+                break;
+            }
+            case A_CHAOTIC:
+            {
+                stat_color = text_color_of("chaotic", text_colors);
+                break;
+            }
+        }
+    }
+
+    color = stat_color.color;
+    attr = A_NORMAL;
+
+    for (count = 0; (1 << count) <= stat_color.attr_bits; ++count)
+	{
+	    if (count != ATR_NONE && stat_color.attr_bits & (1 << count))
+	    {
+		    attr += curses_convert_attr(count);
+		}
+    }
+
+    stat.stat_color = color;
+    stat.stat_attr = attr;
+#endif  /* STATUS_COLORS */
+    
+    if ((stat.stat_color == NO_COLOR) && (stat.stat_attr == A_NORMAL))
+    {
+        if (stat.highlight_turns > 0)
+        {
+#ifdef STATUS_COLORS
+            if (iflags.use_status_colors)
+#endif
+            curses_toggle_color_attr(win, stat.highlight_color,
+             A_NORMAL, onoff);
+        }
+
+        return;
+    }
+
+#ifdef STATUS_COLORS
+    if (iflags.use_status_colors)
+#endif
+    curses_toggle_color_attr(win, stat.stat_color, stat.stat_attr,
+        onoff);
+}
+
+
+/* Determine if a stat is configured via statuscolors. */
+
+#ifdef STATUS_COLORS
+static boolean stat_colored(const char *id)
+{
+    struct text_color_option *cur_option = 
+     (struct text_color_option *)text_colors;
+    
+    while(cur_option != NULL)
+    {
+        if (strcmpi(cur_option->text, id) == 0)
+        {
+            return TRUE;
+        }
+        
+        cur_option = (struct text_color_option *)cur_option->next;
+    }
+    
+    return FALSE;
+}
+#endif  /* STATUS_COLORS */
+
diff -burN '--exclude=.svn' nethack-orig/win/curses/cursstat.h nethack-3.4.3/win/curses/cursstat.h
--- nethack-orig/win/curses/cursstat.h	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/cursstat.h	2010-12-17 14:01:01.908525001 -0500
@@ -0,0 +1,12 @@
+#ifndef CURSSTAT_H
+#define CURSSTAT_H
+
+
+/* Global declarations */
+
+void curses_update_stats(boolean redraw);
+
+void curses_decrement_highlight(void);
+
+
+#endif  /* CURSSTAT_H */
diff -burN '--exclude=.svn' nethack-orig/win/curses/curswins.c nethack-3.4.3/win/curses/curswins.c
--- nethack-orig/win/curses/curswins.c	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/curswins.c	2010-12-17 14:01:01.908525001 -0500
@@ -0,0 +1,815 @@
+#include "curses.h"
+#include "hack.h"
+#include "wincurs.h"
+#include "curswins.h"
+
+/* Window handling for curses interface */
+
+/* Private declarations */
+
+typedef struct nhw
+{
+    winid nhwin;  /* NetHack window id */
+    WINDOW *curwin; /* Curses window pointer */
+    int width;  /* Usable width not counting border */
+    int height; /* Usable height not counting border */
+    int x;  /* start of window on terminal (left) */
+    int y;  /* start of window on termial (top) */
+    int orientation;    /* Placement of window relative to map */
+    boolean border; /* Whether window has a visible border */
+} nethack_window;
+
+typedef struct nhwd
+{
+    winid nhwid;  /* NetHack window id */
+    struct nhwd *prev_wid;    /* Pointer to previous entry */
+    struct nhwd *next_wid;    /* Pointer to next entry */
+} nethack_wid;
+
+typedef struct nhchar
+{
+    int ch;     /* character */
+    int color;  /* color info for character */
+    int attr;   /* attributes of character */
+} nethack_char;
+
+static boolean map_clipped; /* Map window smaller than 80x21 */
+
+static nethack_window nhwins[NHWIN_MAX];    /* NetHack window array */
+
+static nethack_char map[ROWNO][COLNO];  /* Map window contents */
+
+static nethack_wid *nhwids = NULL;  /* NetHack wid array */
+
+static boolean is_main_window(winid wid);
+
+static void write_char(WINDOW *win, int x, int y, nethack_char ch);
+
+static void clear_map(void);
+
+/* Create a window with the specified size and orientation */
+
+WINDOW *curses_create_window(int width, int height, orient orientation)
+{
+    int mapx, mapy, maph, mapw = 0;
+    int startx = 0;
+    int starty = 0;
+    WINDOW *win;
+    boolean map_border = FALSE;
+    int mapb_offset = 0;
+        
+    if ((orientation == UP) || (orientation == DOWN) ||
+     (orientation == LEFT) || (orientation == RIGHT))
+    {
+        if (invent || (moves > 1))
+        {
+            map_border = curses_window_has_border(MAP_WIN);
+            curses_get_window_xy(MAP_WIN, &mapx, &mapy);
+            curses_get_window_size(MAP_WIN, &maph, &mapw);
+        }
+        else
+        {
+            map_border = TRUE;
+            mapx = 0;
+            mapy = 0;
+            maph = term_rows;
+            mapw = term_cols;
+        }
+    }
+    
+    if (map_border)
+    {
+        mapb_offset = 1;
+    }
+    
+    width += 2;    /* leave room for bounding box */
+    height += 2;
+    
+    if ((width > term_cols) || (height > term_rows))
+        panic("curses_create_window: Terminal too small for dialog window");
+    switch (orientation)
+    {
+        case CENTER:
+        {
+            startx = (term_cols / 2) - (width / 2);
+            starty = (term_rows / 2) - (height / 2);
+            break;
+        }
+        case UP:
+        {
+            if (invent || (moves > 1))
+            {
+                startx = (mapw / 2) - (width / 2) + mapx + mapb_offset;
+            }
+            else
+            {
+                startx = 0;
+            }
+            
+            starty = mapy + mapb_offset;
+            break;
+        }
+        case DOWN:
+        {
+            if (invent || (moves > 1))
+            {
+                startx = (mapw / 2) - (width / 2) + mapx + mapb_offset;
+            }
+            else
+            {
+                startx = 0;
+            }
+            
+            starty = height - mapy - 1 - mapb_offset;
+            break;
+        }
+        case LEFT:
+        {
+            if (map_border && (width < term_cols))
+                startx = 1;
+            else
+                startx = 0;
+            starty = term_rows - height;
+            break;
+        }
+        case RIGHT:
+        {
+            if (invent || (moves > 1))
+            {
+                startx = (mapw + mapx + (mapb_offset * 2)) - width;
+            }
+            else
+            {
+                startx = term_cols - width;
+            }
+            
+            starty = 0;
+            break;
+        }
+        default:
+        {
+            panic("curses_create_window: Bad orientation");
+        }
+    }
+    
+    if (startx < 0)
+    {
+        startx = 0;
+    }
+    
+    if (starty < 0)
+    {
+        starty = 0;
+    }
+  
+    win = newwin(height, width, starty, startx);
+    curses_toggle_color_attr(win, DIALOG_BORDER_COLOR, NONE, ON);
+    box(win, 0, 0);
+    curses_toggle_color_attr(win, DIALOG_BORDER_COLOR, NONE, OFF);
+    return win;
+}
+
+
+/* Erase and delete curses window, and refresh standard windows */
+
+void curses_destroy_win(WINDOW *win)
+{
+    werase(win);
+    wrefresh(win);
+    delwin(win);
+    curses_refresh_nethack_windows();
+}
+
+
+/* Refresh nethack windows if they exist, or base window if not */
+
+void curses_refresh_nethack_windows()
+{
+    WINDOW *status_window, *message_window, *map_window;
+    
+    status_window = curses_get_nhwin(STATUS_WIN);
+    message_window = curses_get_nhwin(MESSAGE_WIN);
+    map_window = curses_get_nhwin(MAP_WIN);
+    
+    if ((moves <= 1) && !invent)
+    {
+        /* Main windows not yet displayed; refresh base window instead */
+        touchwin(stdscr);
+        refresh();
+    }
+    else
+    {
+        touchwin(status_window);
+        wnoutrefresh(status_window);
+        touchwin(map_window);
+        wnoutrefresh(map_window);
+        touchwin(message_window);
+        wnoutrefresh(message_window);
+        doupdate();
+    }
+}
+
+
+/* Return curses window pointer for given NetHack winid */
+
+WINDOW *curses_get_nhwin(winid wid)
+{
+    if (!is_main_window(wid))
+    {
+        panic("curses_get_nhwin: wid out of range. Not a main window.");
+    }
+    
+    return nhwins[wid].curwin;
+}
+
+
+/* Add curses window pointer and window info to list for given NetHack winid */
+
+void curses_add_nhwin(winid wid, int height, int width, int y, int x,
+  orient orientation, boolean border)
+{
+    WINDOW *win;
+    int real_width = width;
+    int real_height = height;
+    
+    if (!is_main_window(wid))
+    {
+        panic("curses_add_nhwin: wid out of range. Not a main window.");
+    }
+    
+    nhwins[wid].nhwin = wid;
+    nhwins[wid].border = border;
+    nhwins[wid].width = width;
+    nhwins[wid].height = height;
+    nhwins[wid].x = x;
+    nhwins[wid].y = y;
+    nhwins[wid].orientation = orientation;
+    
+    if (border)
+    {
+        real_width += 2;    /* leave room for bounding box */
+        real_height += 2;
+    }
+    
+    win = newwin(real_height, real_width, y, x);
+    
+    switch (wid)
+    {
+        case MESSAGE_WIN:
+        {
+            messagewin = win;
+            break;
+        }
+        case STATUS_WIN:
+        {
+            statuswin = win;
+            break;
+        }
+        case MAP_WIN:
+        {
+            mapwin = win;
+            
+            if ((width < COLNO) || (height < ROWNO))
+            {
+                map_clipped = TRUE;
+            }
+            else
+            {
+                map_clipped = FALSE;
+            }
+            
+            break;
+        }
+    }
+    
+    if (border)
+    {
+        box(win, 0, 0);
+    }
+    
+    nhwins[wid].curwin = win;
+}
+
+
+/* Add wid to list of known window IDs */
+
+void curses_add_wid(winid wid)
+{
+    nethack_wid *new_wid;
+    nethack_wid *widptr = nhwids;
+    
+    new_wid = malloc(sizeof(nethack_wid));
+    new_wid->nhwid = wid;
+    
+    new_wid->next_wid = NULL;
+    
+    if (widptr == NULL)
+    {
+        new_wid->prev_wid = NULL;
+        nhwids = new_wid;
+    }
+    else
+    {
+        while (widptr->next_wid != NULL)
+        {
+            widptr = widptr->next_wid;
+        }
+        new_wid->prev_wid = widptr;
+        widptr->next_wid = new_wid;
+    }
+}
+
+
+/* refresh a curses window via given nethack winid */
+
+void curses_refresh_nhwin(winid wid)
+{
+    wrefresh(curses_get_nhwin(wid));
+}
+
+
+/* Delete curses window via given NetHack winid and remove entry from list */
+
+void curses_del_nhwin(winid wid)
+{
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        curses_del_menu(wid);
+        return;
+    }
+    
+    if (!is_main_window(wid))
+    {
+        panic("curses_del_nhwin: wid out of range. Not a main window.");
+    }
+
+    nhwins[wid].nhwin = -1;
+}
+
+
+/* Delete wid from list of known window IDs */
+
+void curses_del_wid(winid wid)
+{
+    nethack_wid *tmpwid;
+    nethack_wid *widptr = nhwids;
+    
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        curses_del_menu(wid);
+    }
+    
+    while (widptr != NULL)
+    {
+        if (widptr->nhwid == wid)
+        {
+            if (widptr->prev_wid != NULL)
+            {
+                tmpwid = widptr->prev_wid;
+                tmpwid->next_wid = widptr->next_wid;
+            }
+            else
+            {
+                nhwids = widptr->next_wid;   /* New head mode, or NULL */
+            }
+            if (widptr->next_wid != NULL)
+            {
+                tmpwid = widptr->next_wid;
+                tmpwid->prev_wid = widptr->prev_wid;
+            }
+            free(widptr);
+            break;
+        }
+        widptr = widptr->next_wid;
+    }
+}
+
+
+/* Print a single character in the given window at the given coordinates */
+
+void curses_putch(winid wid, int x, int y, int ch, int color, int attr)
+{
+    int sx, sy, ex, ey;
+    boolean border = curses_window_has_border(wid);
+    nethack_char nch;
+    static boolean map_initted = FALSE;
+
+    if (wid == STATUS_WIN)
+    {
+        curses_update_stats(FALSE);
+    }
+
+    if (wid != MAP_WIN)
+    {
+        return;
+    }
+
+    if (!map_initted)
+    {
+        clear_map();
+        map_initted = TRUE;
+    }
+
+    map[y][x].ch = ch;
+    map[y][x].color = color;
+    map[y][x].attr = attr;
+    nch = map[y][x];
+    
+    (void)curses_map_borders(&sx, &sy, &ex, &ey, -1, -1);
+    
+    if ((x >= sx) && (x <= ex) && (y >= sy) && (y <= ey))
+    {
+        if (border)
+        {
+            x++;
+            y++;
+        }
+
+        write_char(mapwin, x - sx, y - sy, nch);
+    }
+
+    wrefresh(mapwin);
+}
+
+
+/* Get x, y coordinates of curses window on the physical terminal window */
+
+void curses_get_window_xy(winid wid, int *x, int *y)
+{
+    if (!is_main_window(wid))
+    {
+        panic("curses_get_window_xy: wid out of range. Not a main window.");
+    }
+
+    *x = nhwins[wid].x;
+    *y = nhwins[wid].y;
+}
+
+
+/* Get usable width and height curses window on the physical terminal window */
+
+void curses_get_window_size(winid wid, int *height, int *width)
+{
+    *height = nhwins[wid].height;
+    *width = nhwins[wid].width;
+}
+
+
+/* Determine if given window has a visible border */
+
+boolean curses_window_has_border(winid wid)
+{
+    return nhwins[wid].border;
+}
+
+
+/* Determine if window for given winid exists */
+
+boolean curses_window_exists(winid wid)
+{
+    if (nhwins[wid].nhwin == wid)
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+
+/* Return the orientation of the specified window */
+
+int curses_get_window_orientation(winid wid)
+{
+    if (!is_main_window(wid))
+    {
+        panic("curses_get_window_orientation: wid out of range. Not a main window.");
+    }
+
+    return nhwins[wid].orientation;    
+}
+
+
+/* Output a line of text to specified NetHack window with given coordinates
+and text attributes */
+
+void curses_puts(winid wid, int attr, const char *text)
+{
+    anything *identifier;
+    WINDOW *win = NULL;
+    
+    if (is_main_window(wid))
+    {
+        win = curses_get_nhwin(wid);
+    }
+        
+    if (wid == MESSAGE_WIN)
+    {
+        curses_message_win_puts(text, FALSE);
+        return;
+    }
+    
+    if (wid == STATUS_WIN)
+    {
+        curses_update_stats(FALSE);  /* We will do the write ourselves */
+        return;
+    }
+    
+    if (curses_is_menu(wid) || curses_is_text(wid))
+    {
+        if (!curses_menu_exists(wid))
+        {
+            panic("curses_puts: Attempted write to nonexistant window!"); 
+        }
+        identifier = malloc(sizeof(anything));
+        identifier->a_void = NULL;
+        curses_add_nhmenu_item(wid, identifier, 0, 0, attr, text,
+         FALSE);
+    }
+    else
+    {
+        waddstr(win, text);
+        wrefresh(win);
+    }
+}
+
+
+/* Clear the contents of a window via the given NetHack winid */
+
+void curses_clear_nhwin(winid wid)
+{
+    WINDOW *win = curses_get_nhwin(wid);
+    boolean border = curses_window_has_border(wid);
+    
+    if (wid == MAP_WIN)
+    {
+        clearok(win, TRUE); /* Redraw entire screen when refreshed */
+        clear_map();
+    }
+        
+    werase(win);
+
+    if (border)
+    {
+        box(win, 0, 0);
+    }
+}
+
+
+/* Return true if given wid is a main NetHack window */
+
+static boolean is_main_window(winid wid)
+{
+    if ((wid == MESSAGE_WIN) || (wid == MAP_WIN) ||
+     (wid == STATUS_WIN))
+    {
+        return TRUE;
+    }
+    else
+    {
+        return FALSE;
+    }
+}
+
+
+/* Unconditionally write a single character to a window at the given
+coordinates without a refresh.  Currently only used for the map. */
+
+static void write_char(WINDOW *win, int x, int y, nethack_char nch)
+{
+    curses_toggle_color_attr(win, nch.color, nch.attr, ON);
+#ifdef PDCURSES
+    mvwaddrawch(win, y, x, nch.ch);
+#else
+    mvwaddch(win, y, x, nch.ch);
+#endif
+    curses_toggle_color_attr(win, nch.color, nch.attr, OFF);
+}
+
+
+/* Draw the entire visible map onto the screen given the visible map
+boundaries */
+
+void curses_draw_map(int sx, int sy, int ex, int ey)
+{
+    int curx, cury;
+    int bspace = 0;
+#ifdef MAP_SCROLLBARS
+    int sbsx, sbsy, sbex, sbey, count;
+    nethack_char hsb_back, hsb_bar, vsb_back, vsb_bar;
+#endif
+    
+    if (curses_window_has_border(MAP_WIN))
+    {
+        bspace++;
+    }
+    
+#ifdef MAP_SCROLLBARS
+    hsb_back.ch = '-';
+    hsb_back.color = SCROLLBAR_BACK_COLOR;
+    hsb_back.attr = A_NORMAL;
+    hsb_bar.ch = '*';
+    hsb_bar.color = SCROLLBAR_COLOR;
+    hsb_bar.attr = A_NORMAL;
+    vsb_back.ch = '|';
+    vsb_back.color = SCROLLBAR_BACK_COLOR;
+    vsb_back.attr = A_NORMAL;
+    vsb_bar.ch = '*';
+    vsb_bar.color = SCROLLBAR_COLOR;
+    vsb_bar.attr = A_NORMAL;
+
+    /* Horizontal scrollbar */
+    if ((sx > 0) || (ex < (COLNO - 1)))
+    {
+        sbsx = (sx * ((float)(ex - sx + 1) / COLNO));
+        sbex = (ex * ((float)(ex - sx + 1) / COLNO));
+        
+        for (count = 0; count < sbsx; count++)
+        {
+            write_char(mapwin, count + bspace,
+             ey - sy + 1 + bspace, hsb_back);
+        }
+        
+        for (count = sbsx; count <= sbex; count++)
+        {
+            write_char(mapwin, count + bspace,
+             ey - sy + 1 + bspace, hsb_bar);
+        }
+        
+        for (count = sbex + 1; count <= (ex - sx); count++)
+        {
+            write_char(mapwin, count + bspace,
+             ey - sy + 1 + bspace, hsb_back);
+        }
+    }
+    
+    /* Vertical scrollbar */
+    if ((sy > 0) || (ey < (ROWNO - 1)))
+    {
+        sbsy = (sy * ((float)(ey - sy + 1) / ROWNO));
+        sbey = (ey * ((float)(ey - sy + 1) / ROWNO));
+
+        for (count = 0; count < sbsy; count++)
+        {
+            write_char(mapwin, ex - sx + 1 + bspace, count + bspace,
+             vsb_back);
+        }
+        
+        for (count = sbsy; count <= sbey; count++)
+        {
+            write_char(mapwin, ex - sx + 1 + bspace, count + bspace,
+             vsb_bar);
+        }
+        
+        for (count = sbey + 1; count <= (ey - sy); count++)
+        {
+            write_char(mapwin, ex - sx + 1 + bspace, count + bspace,
+             vsb_back);
+        }
+    }    
+#endif  /* MAP_SCROLLBARS */
+
+    for (curx = sx; curx <= ex; curx++)
+    {
+        for (cury = sy; cury <= ey; cury++)
+        {
+            write_char(mapwin, curx - sx + bspace, cury - sy + bspace,
+             map[cury][curx]);
+        }
+    }
+}
+
+
+/* Init map array to blanks */
+
+static void clear_map()
+{
+    int x, y;
+    
+    for (x = 0; x < COLNO; x++)
+    {
+        for (y = 0; y < ROWNO; y++)
+        {
+            map[y][x].ch = ' ';
+            map[y][x].color = NO_COLOR;
+            map[y][x].attr = A_NORMAL;
+        }
+    }
+}
+
+
+/* Determine visible boundaries of map, and determine if it needs to be
+based on the location of the player. */
+
+boolean curses_map_borders(int *sx, int *sy, int *ex, int *ey, int ux,
+ int uy)
+{
+    static int width = 0;
+    static int height = 0;
+    static int osx = 0;
+    static int osy = 0;
+    static int oex = 0;
+    static int oey = 0;
+    static int oux = -1;
+    static int ouy = -1;
+    
+    if ((oux == -1) || (ouy == -1))
+    {
+        oux = u.ux;
+        ouy = u.uy;
+    }
+    
+    if (ux == -1)
+    {
+        ux = oux;
+    }
+    else
+    {
+        oux = ux;
+    }
+
+    if (uy == -1)
+    {
+        uy = ouy;
+    }
+    else
+    {
+        ouy = uy;
+    }
+
+    curses_get_window_size(MAP_WIN, &height, &width);
+    
+#ifdef MAP_SCROLLBARS
+    if (width < COLNO)
+    {
+        height--;  /* room for horizontal scrollbar */
+    }
+
+    if (height < ROWNO)
+    {
+        width--;  /* room for vertical scrollbar */
+
+        if (width == COLNO)
+        {
+            height--;
+        }
+    }
+#endif  /* MAP_SCROLLBARS */
+
+    if (width >= COLNO)
+    {
+        *sx = 0;
+        *ex = COLNO - 1;
+    }
+    else
+    {
+        *ex = (width / 2) + ux;
+        *sx = *ex - (width - 1);
+        
+        if (*ex >= COLNO)
+        {
+            *sx = COLNO - width;
+            *ex = COLNO - 1;
+        }
+        else if (*sx < 0)
+        {
+            *sx = 0;
+            *ex = width - 1;
+        }
+    }
+    
+    if (height >= ROWNO)
+    {
+        *sy = 0;
+        *ey = ROWNO - 1;
+    }
+    else
+    {
+        *ey = (height / 2) + uy;
+        *sy = *ey - (height - 1);
+        
+        if (*ey >= ROWNO)
+        {
+            *sy = ROWNO - height;
+            *ey = ROWNO - 1;
+        }
+        else if (*sy < 0)
+        {
+            *sy = 0;
+            *ey = height - 1;
+        }
+    }
+
+    if ((*sx != osx) || (*sy != osy) || (*ex != oex) || (*ey != oey) ||
+     map_clipped)
+    {
+        osx = *sx;
+        osy = *sy;
+        oex = *ex;
+        oey = *ey;
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -burN '--exclude=.svn' nethack-orig/win/curses/curswins.h nethack-3.4.3/win/curses/curswins.h
--- nethack-orig/win/curses/curswins.h	1969-12-31 19:00:00.000000000 -0500
+++ nethack-3.4.3/win/curses/curswins.h	2010-12-17 14:01:01.898525001 -0500
@@ -0,0 +1,46 @@
+#ifndef CURSWIN_H
+#define CURSWIN_H
+
+
+/* Global declarations */
+
+WINDOW *curses_create_window(int width, int height, orient orientation);
+
+void curses_destroy_win(WINDOW *win);
+
+void curses_refresh_nethack_windows(void);
+
+WINDOW *curses_get_nhwin(winid wid);
+
+void curses_add_nhwin(winid wid, int height, int width, int y, int x,
+ orient orientation, boolean border);
+
+void curses_add_wid(winid wid);
+
+void curses_refresh_nhwin(winid wid);
+
+void curses_del_nhwin(winid wid);
+
+void curses_del_wid(winid wid);
+
+void curses_putch(winid wid, int x, int y, int ch, int color, int attrs);
+
+void curses_get_window_xy(winid wid, int *x, int *y);
+
+boolean curses_window_has_border(winid wid);
+
+boolean curses_window_exists(winid wid);
+
+int curses_get_window_orientation(winid wid);
+
+void curses_puts(winid wid, int attr, const char *text);
+
+void curses_clear_nhwin(winid wid);
+
+void curses_draw_map(int sx, int sy, int ex, int ey);
+
+boolean curses_map_borders(int *sx, int *sy, int *ex, int *ey, int ux,
+ int uy);
+
+
+#endif  /* CURSWIN_H */
diff -burN '--exclude=.svn' nethack-orig/win/tty/termcap.c nethack-3.4.3/win/tty/termcap.c
--- nethack-orig/win/tty/termcap.c	2003-12-07 18:39:14.000000000 -0500
+++ nethack-3.4.3/win/tty/termcap.c	2010-12-17 14:01:01.138525001 -0500
@@ -1173,6 +1173,13 @@
 	/* hilites[] not used */
 	return iflags.use_color;
 #endif
+#ifdef CURSES_GRAPHICS
+    /* XXX has_color() should be added to windowprocs */
+    /* iflags.wc_color is set to false and the option disabled if the
+     terminal cannot display color */
+    if (windowprocs.name != NULL &&
+     !strcmpi(windowprocs.name, "curses")) return iflags.wc_color;
+#endif
 	return hilites[color] != (char *)0;
 }
 
